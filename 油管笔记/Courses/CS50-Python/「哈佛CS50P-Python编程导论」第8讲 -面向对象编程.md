
# 「哈佛CS50P-Python编程导论」第8讲 -面向对象编程

- 视频链接：[CS50P - Lecture 8 - Object-Oriented Programming](https://www.youtube.com/watch?v=e4fwY9ZsxPw&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=10)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---
### 内容介绍

面向对象编程（Object-Oriented Programming, OOP）是现代软件开发中的一种核心编程范式。本讲座旨在系统介绍 Python 中的 OOP 概念及其应用。随着程序规模的增长和复杂性的提高，仅仅依赖过程式或函数式的方法往往不足以有效组织和管理代码，而 OOP 提供了一套强大的思想和工具来应对这些挑战。

讲座内容将从一个简单的问题出发——如何组织和表示现实世界中的实体（如学生信息）。通过对比使用元组、列表和字典等不同内置数据结构的优缺点，逐步引出创建自定义数据类型的需求，进而深入讲解“类”（Class）与“对象”（Object）这两个 OOP 的基石概念。您将学习如何定义类，使用 `__init__` 方法初始化对象的状态（实例变量），定义实例方法（包括特殊方法如 `__str__`）来赋予对象行为，并通过属性（Properties）、getter 和 setter 方法实现数据的封装与验证，确保数据的正确性。

此外，讲座还将探讨类方法、继承（Inheritance）以及运算符重载（Operator Overloading）等高级特性，并揭示您日常使用的 Python 内置类型（如 `int`, `str`, `list`）本身就是类的实例。理解这些将深化您对 Python 工作方式的认识。

### 内容纲要

```
面向对象编程 (OOP) 导论
├── 引言与 OOP 概念
│   ├── OOP 作为一种编程范式
│   └── OOP 对复杂程序的重要性
├── 动机：从过程式到数据结构
│   ├── 初始过程式脚本 (student.py 获取姓名与学院)
│   ├── 函数化重构 (引入 main, get_name, get_house)
│   ├── 整合功能至 get_student
│   └── 遇到问题：函数需返回多个值
├── 使用元组 (Tuple) 组织数据
│   ├── 函数返回多个值与 Python 的元组打包
│   ├── 元组特性：有序集合、不可变性 (immutable)
│   ├── 通过数字索引访问
│   └── 不可变性的演示与局限
├── 使用列表 (List) 和字典 (Dictionary) 组织数据
│   ├── 列表 (List)：可变性 (mutable) 的需求场景
│   └── 字典 (Dictionary / dict)
│       ├── 键值对存储，提供更好语义
│       ├── 通过键访问，更易读
│       ├── 可变性
│       └── 字典操作示例
├── 核心概念：类 (Class) 与对象 (Object)
│   ├── 问题：通用数据结构的局限性
│   ├── 解决方案：使用 `class` 创建自定义数据类型
│   ├── 类 (Class)：对象的蓝图或模板
│   ├── 对象 (Object)：类的具体实例 (instance)
│   └── 属性 (Attributes) / 实例变量 (Instance Variables)
│       └── 通过点 (.) 符号访问和设置
├── 类的关键组成部分
│   ├── 初始化方法 (`__init__`) 与实例变量
│   │   ├── `__init__` 的作用：对象创建时的初始化
│   │   ├── `self` 参数：指向对象实例的引用
│   │   ├── 构造器传参与内部赋值 (self.variable = value)
│   │   └── 实例变量的作用域
│   ├── 实例方法 (Instance Methods)
│   │   ├── 定义：类内部操作实例的函数
│   │   ├── `__str__` 特殊方法：定义对象的字符串表示
│   │   └── 自定义方法：为类添加特定行为 (如 `charm` 方法)
│   └── 封装与数据验证
│       ├── 问题：直接访问实例变量可能绕过验证
│       ├── 属性 (Properties)：受控的属性访问
│       ├── Getter 方法 (`@property`)：获取属性值
│       ├── Setter 方法 (`@<property_name>.setter`)：设置属性值并执行验证
│       └── 内部变量约定：使用下划线 (`_`) 区分内部存储变量
├── 内置类型也是类
│   ├── 揭示：`int`, `str`, `list`, `dict` 等本质上都是类
│   ├── 回顾：我们一直在使用对象及其方法 (如 `.lower()`, `.append()`)
│   └── 使用 `type()` 函数进行验证
├── 高级类特性
│   ├── 类方法 (`@classmethod`) 与类变量
│   │   ├── 类变量：所有实例共享的变量
│   │   ├── 类方法：操作类本身而非实例的方法
│   │   ├── `cls` 参数：指向类的引用
│   │   ├── 应用：工厂方法 (如 `Student.get`)，避免“鸡生蛋”问题
│   │   └── 类作为相关功能的容器 (如 `Hat` 类)
│   ├── 继承 (Inheritance)
│   │   ├── 概念：子类继承父类的属性和方法
│   │   ├── 目的：代码复用与建立层次关系 ("is-a")
│   │   ├── 语法：`class Child(Parent):`
│   │   ├── `super()` 函数：调用父类方法
│   │   ├── 示例：`Wizard` -> `Student`, `Professor`
│   │   └── Python 内置 `Exception` 体系作为例子
│   └── 运算符重载 (Operator Overloading)
│       ├── 概念：让自定义类响应标准运算符 (如 `+`, `-`)
│       ├── 实现：通过定义特殊方法 (如 `__add__`, `__sub__`)
│       ├── 示例：为 `Vault` 类实现 `+` 操作以合并内容
│       └── 回顾：`+` 已被 Python 用于数字、字符串、列表
└── 总结
    ├── OOP 作为强大的代码组织工具
    └── 类与对象在建模现实/幻想世界实体中的价值
```



---

# CS50P 第 8 讲：面向对象编程

## 一、 引言与面向对象编程 (OOP) 概念

[古典音乐]

大家好，这里是 CS50 的 Python 编程入门。我是 David Malan，这是我们关于面向对象编程（Object-Oriented Programming，简称 OOP）的一周。

事实证明，在编程世界中，存在不同的编程语言范式。有不同的用代码解决问题的方式，如果你只学过一种语言，一开始可能很难看出来。但随着时间的推移，如果你学习了除 Python 之外的其他语言，你会开始注意到某些语言具有而其他语言不具备的特定模式和能力。

到目前为止，在 Python 的世界里，你我主要编写的是本质上是过程式的代码，即我们编写过程；我们编写函数；我们从上到下地做事。一切都是按部就班、一步一步进行的，就像你通常对算法所期望的那样。但在此过程中，我们实际上也涉足了另一种称为函数式编程的范式，通过这种范式，我们能够传递函数。几周前我们甚至用过匿名函数。这证明了函数式编程语言的特性，尽管我们只是浅尝辄止。

今天我们专注于另一种范式，并且会更详细地探讨它——即面向对象编程。现在，虽然你们中有些人可能有过编程经验，学过像 Java 这样天生就是面向对象的语言，但 Python 在如何用代码解决问题方面确实提供了一些灵活性。但事实证明，当你的程序变得越来越长、越来越大、越来越复杂时，面向对象编程对于你不可避免会遇到的问题来说，是一个非常有吸引力的解决方案。

因此，对于我们来说，OOP 将成为一个解决问题的方案，它建立在许多过去的经验教训之上。

## 二、 动机：从过程式代码到数据结构

那么，让我们开始吧。让我们首先非常过程化地编写一个程序。打开 VS Code。我将创建一个名为 `student.py` 的程序。在这个程序中，我最初想做一些相对简单的事情，就像我们几周前可能做过的那样，就是询问用户的姓名，或许在哈利波特的世界背景下，询问他们的学院，然后打印出该学生来自哪里。让我们通过逐步增加更多功能来增强这个程序，看看我们是否会遇到一些迄今为止可能没有非常优雅、设计良好的解决方案的问题。但是，如果我们明确地引入面向对象编程作为一种编程技术，我敢打赌我们可以清理我们的代码，并为将来编写更复杂、更长的程序奠定基础。

所以在 `student.py` 中，让我先创建一个 `name` 变量，将其设置为 `input` 函数的返回值，并像这样提示用户输入他们的姓名。然后，让我对 `house` 变量做同样的事情，使用 `input` 提示用户输入他们的学院。现在让我们做一些超级简单的事情。让我们打印一个 f-string，比如 `name from house`，这样我就可以确认这些变量的内容确实如我所料。我现在不会做任何错误检查或修剪之类的事情。我真的只是把我用户刚输入的内容吐出来。

好的，让我运行 `python student.py`。让我们用我们常用的例子，比如哈利（Harry），来自格兰芬多（Gryffindor）。当我按下回车键时，现在看看我是否看到 `Harry from Gryffindor` 确实是这样。

好的，我认为我们现在有了一个可以工作的程序，但现在让我们引入一些很久以前在第零周学到的经验，那时我们开始编写自己的函数，不一定是因为它能更正确地解决问题——我敢说现在这样就是正确的。但它开始为我们提供可以扩展的构建块，以便解决更复杂的程序。

所以，让我回到 `student.py`，现在让我们这样做。让我们把我刚才写的全部逻辑放到我们通常称为 `main` 的方法中，让我缩进那三行，这样它们至少被组合成一个 `main` 方法。但是，不要在第 2 行使用 `input`，在第 3 行使用 `input`，我们暂时假设世界上有一个名为 `get_name` 的函数，并且假设我们有另一个像 `get_house` 这样的函数，它们不接受参数。但它们存在的目的，根据它们的名字，将分别是获取用户的姓名和获取用户的学院。然后我将打印出和以前完全相同的 f-string。

当然，我现在需要实现这些函数。所以让我在文件下方定义一个名为 `get_name` 的函数。括号里什么都没有，因为它不接受参数。我将做类似 `name = input("Name")` 的事情，就像以前一样，然后我将返回 `name`。所以这是一个超级简单的函数，但它是一个抽象。我现在有一个名为 `get_name` 的函数，我不再需要关心它的实现细节了。我只知道这个函数存在。事实上，我可以把它精简一下。如果我立即在第 9 行返回同一个 `name` 变量，那么第 8 行的 `name` 变量就不是必需的了。所以，尽管这不会改变功能，但我还是稍微精简一下，直接返回这里 `input` 函数调用的返回值。

现在让我们对 `get_house` 做类似的事情，它同样不接受任何参数。我将返回 `input` 的返回值，这次提示用户输入他们的学院。我还需要最后一个细节。在最底部，让我们继续我们的习惯，做 `if __name__ == "__main__":`，然后我们实际调用 `main`。回想一下，我们这样做是为了，如果这个文件最终成为模块（一种库）的一部分，我不会意外地盲目调用 `main`。我只在打算从命令行在这个文件上运行 `main` 时才这样做。

好的，如果我没有犯任何错误，让我在终端窗口中再次运行 `python student.py`，回车。让我们输入 Harry，回车。让我们输入 Gryffindor，回车。我们搞定了。`Harry from Gryffindor` 似乎仍然有效。所以我们并没有真正更正确地解决问题，但我已经奠定了基础，也许现在可以做一些更有趣的事情，因为我已经有了这些构建块。

但让我建议，我们可以用稍微不同的方式来做这件事。`get_name`、`get_house` 没问题。但归根结底，我真正想从用户那里得到的是一个学生。我想要他们的名字和学院，而不仅仅是其中一个。所以也许定义一个名为 `get_student` 的函数，让 `get_student` 为我们完成所有这些工作，会更简洁一些。现在，理论上，`get_student` 可以调用 `get_name` 和 `get_house`。但因为这些函数非常短，我认为只定义一个名为 `get_student` 的函数是可以接受的，它同样不接受任何参数。但它要做两件事。它将通过像以前一样提示用户来获取学生的姓名。它将通过像以前一样提示用户来获取学生的学院。

现在，嗯。我想返回学生，但我认为我可能把自己逼到角落里了。因为我现在有两个变量——`name` 和 `house`。然而，到目前为止，我们几乎总是返回一个或另一个。我们返回一个值。那么，对于我刚才给自己制造的这个问题，即我想真正返回一个学生，但我目前有一个 `name` 变量和一个 `house` 变量，有什么建议可以解决吗？我至少想同时返回这两个。

**问：** 我相信我们可以返回一个包含姓名和学院的字典。
**答：** 是的，我们绝对可以返回一个字典——Python 中的 `dict` 对象，其中一个键可能是 `name`；一个键可能是 `house`；它们的值就是这些变量的值。所以我们完全可以这样做。我担心那可能会变得有点复杂。我想知道是否有更简单的方法。还有其他直觉吗——即使你不确定它是否有效？

**问：** 返回 `name` 和 `house` 两个值？
**答：** 返回 `name` 和 `house` 两个值。我喜欢这个说法。听起来很简单。我不需要弄清楚字典会是什么样子。事实上，这种方法也是有效的，即使你以前没有见过。事实证明，在 Python 中，你可以返回多个值，但这有点像善意的谎言。或者我们可以采用 Muhammad 的方法，实际返回一个字典并在其中放入多个键。所以，这里我们又有一个例子，说明如何至少用两种方式解决同一个问题，而且我敢说我们马上会看到更多方式。

## 三、 使用元组 (Tuple) 组织数据

一种解决你想返回多个值的问题的方法是这样做。我可以确实地返回不仅仅是 `name`，我可以用一个逗号，然后也返回 `house`。如果你以前用其他语言编程过，这不一定能在其他语言中做到。这取决于语言。但看起来，多亏了这个逗号，也许我确实可以像 [听不清] 建议的那样返回两个值。

好吧，如果我以这种方式在第 10 行返回两个值，我如何同时获取这两个值呢？有几种方法。让我回到我的 `main` 函数。我知道，至少我必须将 `get_name` 和 `get_house` 改为 `get_student`。但我将把返回值存储在什么里面呢？我想我实际上可以这样做。我们以前见过这种技术，你可以解包（unpack）返回的值序列。事实上，就把它看作是那样。`name, house` 是我返回的值的某种序列——`name`, `house`。所以，如果我想解包它们并将返回值存储在两个独立的变量中，我实际上可以在赋值运算符（等号）的左侧使用逗号来做到这一点。

现在，要清楚的是，我不需要在这里将这些变量称为 `name` 和 `house`。我可以简化它，在这里只用 `n`，在这里只用 `h`，然后我可以只返回 `n` 和 `h`。但我认为这对读者来说不是很清楚发生了什么。所以我认为，在这种情况下，即使我在 `get_student` 和 `get_name` 中以及在 `main` 中使用了相同的变量名是一个巧合，但对像我这样的人来说，它更具可读性。所以我将保持原样。

那么，让我们看看现在这是否有效。让我清空我的屏幕，运行 `python student.py`，回车。让我们再次输入 Harry。再次输入 Gryffindor，回车。瞧，我们仍然看到 Harry 来自 Gryffindor。

但我们实际上在这里做了什么？通过返回这个值，我们实际上做了什么？嗯，事实证明，我们刚才使用的是元组（tuple）。元组是 Python 中的另一种数据类型，它是值的集合——x, y 或 x, y, z。从这个意义上说，它在精神上类似于列表（list），但它是不可变的（immutable）。它不是可变的（mutable）。

现在，这是什么意思呢？列表，正如我们之前看到的，是 Python 中的一种数据结构，你可以更改其中的值。你可以访问 `bracket 0`（即 `[0]`）获取第一个位置并更改那里的值。你可以访问 `bracket 1`, `bracket 2`, `bracket 3` 并实际更改列表中的值。但是，如果你无意更改变量的值，并且想要有效地返回多个值，你甚至不必将其作为列表返回。你可以将其作为元组返回，只需使用逗号即可。

事实证明，我们可以明确指出——这就是那个善意的谎言。我实际上并不是严格意义上返回两个值。每当你在第 9 行像这样使用逗号时，你实际上是在返回一个值，那就是一个元组。现在，那个元组内部有两个值。所以它在精神上类似于返回一个包含两项的列表。这里我返回一个包含两项的元组。仅仅使用逗号而没有其他东西，就告诉 Python 我确实想返回一个元组。

但是有更明确的语法我们可以使用。我可以更详细地——在这些元组的值周围加上显式的括号，只是为了让我和读者更清楚地知道，这不是严格意义上的两个值。这是一个包含两项的值。然后我实际上可以做的是——我不必像上面那样在这里解包。我实际上可以到这里，也许给一个更恰当的名字，比如 `student`，我可以命名我存储 `get_student` 返回值的变量为，引号里的，“student”。所以也许这现在是一个稍微好点的设计，因为我有点在抽象化一个学生是什么。它目前是作为一个包含两个值的元组来实现的。但至少，我现在有一个名为我所指的——一个学生的变量。

但会有一个问题。在第 3 行，我仍然想打印出那个学生的名字和他们的学院。但我不再有一个 `name` 变量，也没有一个 `house` 变量了。而且我也没有像之前建议的那样有一个字典，所以我甚至不能按名称访问那些键。但元组是什么呢——它在精神上与列表非常相似，但它确实是不可变的。我的意思是，我仍然可以通过数字索引来访问它，通过说 `student[0]` 获取该元组中第一个位置的项。然后在这里，代替 `house`，我可以说 `student[1]`。`student[1]` 将给我该元组中的第二个位置。

让我清空我的终端窗口。再次运行 `python student.py`。让我们输入 Harry。输入 Gryffindor，回车，我们仍然有一些可用的代码。

现在让我暂停一下，看看关于这种返回元组并以这种方式索引它的技术是否有任何问题。

**问：** 我想知道，相比于列表或其他类似的东西，什么时候你会实际使用元组？
**答：** 这是一个非常好的问题。什么时候你会使用元组而不是列表？当你想要进行防御性编程时，或者，总的来说，当你知道这个变量中的值不应该改变时，那么你为什么要使用一个允许它们被改变的数据类型呢？这只会招致错误，导致将来出现 bug，无论是你自己还是与你的代码交互的同事。所以元组只是你工具箱中的另一种工具，你可以通过不允许任何人（包括你自己）更改其中的内容来增加正确性的概率。所以它只是你工具箱中的另一个工具。

但让我们明确一下，我所说的“不可变”是什么意思。再说一遍，我声称“不可变”意味着你不能改变值。那么，让我们尝试这样做。让我再按原样运行一次这个程序——`python student.py`。让我输入，例如——帕德玛（Padma）的名字怎么样？我将说帕德玛在格兰芬多，就像电影里那样。我们看到——`Padma from Gryffindor`。但技术上讲，我在深入研究哈利波特时发现。技术上，在书中，我相信帕德玛是来自拉文克劳（Ravenclaw）的。所以这实际上是一个错误，或者是电影和书籍之间的不一致之处。让我们看看我们是否能在代码中修正这种不一致性。

那么我们这样做怎么样？如果输入的学生姓名等于帕德玛，为什么我们不覆盖掉学院是什么，并将其正确地更改为拉文克劳呢？让我来做 `if student`——现在，如果我想获取帕德玛的名字，我必须做 `student[0]`。我必须知道名字在这个元组中的哪个位置。但如果那个值等于帕德玛，让我们用这个 `if` 语句来做一个更改。让我们更改 `student[1]` 的值。也就是第二个值，如果我们是从零开始索引的话——让我们把它改成哈利波特世界中的另一个学院，叫做拉文克劳。所以我只是在修正用户可能的输入。他们看了电影，所以他们输入了 Padma Gryffindor，但是，嗯嗯，在书中，是 Padma from Ravenclaw。

好的，让我到我的终端窗口，清空终端，然后执行 `python student.py`，回车。我将输入 Harry 和 Gryffindor，只是为了演示那仍然按预期工作。让我再次清空屏幕，然后运行 `python student.py` 输入 Padma，我也会把她放在格兰芬多，就像电影里那样，然后按回车。现在我只看到屏幕上一大堆错误。某种异常被抛出了。确实，发生了一个 `TypeError`。我正在使用一种数据类型，其中存在错误，那个错误是什么呢？嗯，`'tuple' object does not support item assignment`。它的表达有点晦涩难懂——也就是说，它不是很用户友好。但如果你思考一下这些词的意思，'tuple' 对象不支持项赋值。所以赋值是从右到左的复制。所以不知何故，这是无效的。这就是元组不可变性的体现。你不能改变位置 0 或 1 或里面的任何东西。这是一个特性。这是元组的设计。

## 四、 使用列表 (List) 和字典 (Dictionary) 组织数据

如果我想覆盖它，我想我将不得不使用我们以前用过的另一种数据类型——也就是列表，那没问题。如果你想让你自己和使用你代码的同事能够更改该容器的内容，那么，我们可以返回不是使用显式圆括号或没有括号只有逗号的元组，而是使用方括号。如果我在左边和右边都使用方括号，这确实明确地是一个列表。同样的想法，但它是可变的。也就是说你可以改变列表的内容。所以，不做任何其他更改，只是返回一个带有方括号的列表，而不是带有圆括号或只有逗号的元组。

现在让我执行 `python student.py`，回车。让我再次输入 Harry 和 Gryffindor。那仍然有效。很高兴看到。让我再运行一次，输入 Padma 和 Gryffindor，就像电影里那样，但是不，现在我们已经将其修正为书中的 Padma from Ravenclaw。

现在关于元组与列表，或者这种不可变性与可变性的概念，有什么问题吗？

**问：** 我们可以在 Python 中使用嵌套元组吗，就像嵌套列表一样？
**答：** 当然可以。你不仅可以在 Python 中有嵌套列表，其中列表中的一个元素可以是另一个列表——所以你外面有一些方括号；你里面可能有一些其他的方括号。你绝对可以用元组做同样的事情。对于你可以在里面放什么类型的值没有限制。在这种情况下我们没有机会这样做。我只是返回一个包含两个元素的简单元组。但是是的，你绝对也可以那样做。

还有其他关于元组与列表的问题吗？

**问：** 好的，例如，当我看到方括号时，它主要是用于列表吗？
**答：** 哦，一个非常好的问题。算是吧。所以当你创建像列表这样的值时，你使用方括号，那确实会是一个视觉指示器，表明这绝对是一个列表。如果你看到的是圆括号，那在创建值时是一个视觉指示器，表明它绝对是一个元组。然而，有点令人困惑的是，列表和元组在访问它们的内容时都使用方括号。当你索引到它们的位置 0 或位置 1 时，你总是使用方括号。所以这就是区别所在。好问题。

请允许我现在建议，如果可以的话，我们用另一种方式来解决这个问题，让我们看看我们是让事情变得更好还是更糟。回想一下，字典（dict objects）在 Python 中也存在。字典是键和值的集合。特别是，字典的好处是它们有更好的语义。你不必仅仅假设名字总是在位置 0；学院总是在位置 1。这种事情，特别是如果你有三个、四个或更多的值——最终你或某人会感到困惑并忘记顺序，然后你会写出有 bug 的代码。所以字典更强大一些，因为你可以语义化地将键（小的描述）与值相关联——分别是那些键和那些值。

所以让我这样做，我们可以用几种不同的方式来完成。但让我建议我们专注于这里的 `get_student`。让我们这样做。让我删除 `get_student` 现有的实现。让我创建一个 `student` 变量并将其初始化为一个空字典。我可以用两个花括号来做到这一点。然后让我继续在那个字典里面设置两个键。在 `student` 里面，将会有一个，引号里的，“name”键，它的值将是我提示用户输入姓名时 `input` 函数的返回值。然后，同一个 `student` 字典里的“house”键，将是用户为他们的学院输入的任何内容的返回值。最后，我将返回 `student`。

所以现在我仍然确实只返回一样东西，但这次它是一个 `dict`，而不是元组，也不是列表。但里面仍然有两样东西，技术上是四样东西，如果你算上键和值的话。但有两个键值对。

现在，我上面的代码需要做一点改变。让我们简化一下，例如，现在移除帕德玛的 `if` 语句，只关注手头正在改变的东西。让我现在保留第 2 行不变。我仍然会有一个 `student` 变量，它被赋予 `get_student` 的返回值。但我现在想做的是实际访问那个字典内部的键——不是通过数字索引（那是用于元组和列表的）——0 和 1，而是通过键的方式。现在，通常，我可能会习惯于，像我个人一样，在里面使用双引号——引号里的 "name"，在里面使用引号里的 "house"。但在我运行这段代码并向你展示一个错误之前——在屏幕上看到一个错误，有人想指出我在这里做错了什么吗？这只是一个 f-string。我只想打印出这个字典中 `name` 键的值和 `house` 键的值。

**问：** [听不清]
**答：** 你的音频对我们来说有点含糊不清。但我想我听到了双引号和单引号。所以我将假设，确实，你精确地指出了问题所在。我现在只会让 Python 感到困惑。即使这是一个在双引号内的 f-string，前缀是 `f`，我实际上不能在我的双引号内使用双引号，因为那可能会让 Python 混淆。如果我现在运行这个程序，`python student.py` 并按回车，我得到一个语法错误。所以程序甚至没有完全运行。它只是无法被理解，因为它被那些双引号搞糊涂了。所以最简单的修复方法确实是只使用单引号而不是双引号来包围键，或者反过来，将外面的双引号改成单引号，然后在里面使用双引号。你只需要保持一致。所以这是一个微妙的细节，但这现在是特定于字典语法的。这与我们当前解决手头问题的方式无关。

好吧，让我们试试这个。现在让我运行 `python student.py`。让我们输入 Harry。输入 Gryffindor。希望 Harry 回到了 Gryffindor。没有语法错误。没有其他错误。我想我现在又回到正轨了。

我确实喜欢明确使用字典的一点是，它让我有更好的语义。再说一次，我不必记住、记忆、记录 0 是 name；1 是 house。相反，“name”就是 name，“house”就是 house。它只是更清晰、更具表现力。这通常是件好事，特别是如果我们存储关于学生的更多数据，而不仅仅是他们的名字和学院——如果你有三个字段、四个、五个、十个不同的字段——没有人会想或能够永远记住哪个是 0、哪个是 1、哪个是 2 等等。最好引入像本例中的 "name" 和 "house" 这样的名称。

但让我进一步精简它。我通常的习惯是除非能让代码更具可读性，否则不引入不必要的变量。一种格式化相同代码的替代方法是这样的。严格来说，我不需要创建一个空字典，然后向其添加一个键，再向其添加第二个键，然后返回那个字典。我实际上可以将所有这些合并到一个语句中，如果你愿意的话。让我这样做。让我说 `name` 等于 `input` 的返回值，`house` 等于 `input` 的返回值，然后，不返回任何名为 `student` 的变量（我将建议它不再需要存在），让我一次性创建并返回字典。让我在这里用小写字母做引号里的 "name"，然后是变量。它存储用户的名字。然后，引号里的 "house"，作为我的第二个键，它的值将是变量 `house`。

现在，这样更好吗？也许是，也许不是。也许第一种方式更具可读性一些，如果变量能提高代码的可读性，创建它们是完全可以的。但要知道，你也可以像这样即时创建并返回一个字典，可以说是，全部在一行内，我认为在这种情况下这可以说是相当合理的。为什么？它只是非常短。如果它变得越来越长，我可能就不会这样做了。我可能至少会开始将我的键值对移到不同的行。但这只是一种稍微更紧凑的完成方式。

但让我建议我们再做一个改变。让我们引入对帕德玛的同样特殊处理，例如将她的学院从格兰芬多修正为拉文克劳。我们如何用字典来做到这一点？嗯，字典，像列表一样，是可变的。你可以改变它们里面的内容，就像你可以改变列表一样。你怎么做呢？只是语法上有点不同。

所以让我们回到 `main` 中进行这个修正。如果 `student` 变量有一个 `name` 键的值等于帕德玛，那么，缩进后，继续更改那个 `student` 字典内部 `house` 键的值为，引号里的，“Ravenclaw”。所以这在精神上与我们用列表所做的非常相似。但不是使用位置 0 和 1，我们更清晰、更明确、更语义化地使用，引号里的，“name”和，引号里的，“house”，因为你使用数字索引列表和元组，但你使用字符串索引字典，就像我在这里做的那样。

好的，让我运行 `python student.py`。我们将再次输入 Harry 来自 Gryffindor。我想一切都好。让我再运行一次，这次是 Padma，她在电影里是来自 Gryffindor，但实际上应该来自 Ravenclaw。

那么，关于从元组到列表再到字典的这个演进过程，有什么问题吗？我们并没有必然引入任何新的东西，除了那些一直可用的元组。但目前的目的是展示这些不同数据类型之间的区别以及它们各自的工作方式略有不同。

**问：** 如果我们的元组中有一个列表的组合呢？我们可以改变列表，因为元组是不可变的但列表是可变的？
**答：** 正确。你可以改变列表的内容，而且你可以把几乎任何你想要的东西放进去——其他列表或字符串，就像我做的那样，整数，或其他任何东西。元组你可以做完全相同的事情，但是一旦你创建了它们，你就不能改变它们。字典更像列表，因为它是可变的。你可以改变它。但是你索引字典的方式是通过这些键，这些字符串，正如我们一直说的，而不是通过数字——那些数字索引。

## 五、 核心概念：类 (Class) 与对象 (Object)

好的，那么，让我建议还有另一种解决这个问题的方法。而且我认为现在有一个机会摆在面前。尽管这个程序并不是特别复杂——我所做的只是从用户那里收集一个名字和一个学院——你可以想象，长期来看，想要收集更多的信息，比如学生的守护神或魔法咒语，或者一大堆可能属于一个学生的其他信息。而现在，我们只是在使用 Python 中这些非常通用的数据类型——用元组将一些值组合在一起；用列表做同样的事情，但允许我们稍后更改它；用字典，它更强大，因为它更有结构性。它确实有键和值，而不仅仅是值。

但是你知道吗？如果 Python 的作者们给了我们一种叫做 `student` 的数据类型，我们就不会进行这场讨论了。如果我可以在我的代码中创建一种名为 `student` 的变量类型，那岂不是很好？那样我们就不用去想，我们是用元组、列表还是字典？但这很合理。你可以想象，如果一门语言的创造者必须预测像你我这样的程序员想要在程序中存储的所有可能的数据类型，那将是多么难以驾驭的斜坡。所以他们只给了我们这些通用的工具。

但他们给了我们另一个通用的工具，它将允许我们创建自己的数据类型，并实际给它们命名，这个术语就是类（class）。类就像是数据片段（对象）的蓝图。类是你定义并命名的模具。当你使用那个模具或那个蓝图时，你会得到完全按照你想要的方式设计的数据类型。简而言之，类允许你在 Python 中发明自己的数据类型并给它们命名。这是面向对象编程的一个主要特性，能够以这种方式创建你自己的对象，并且在 Python 的类中，甚至可以给它们自定义名称。

这在实际中意味着什么呢？好吧，让我回到 VS Code 这里，让我建议我们引入一点新的语法。我将先清空我的终端窗口。我将去到我的文件顶部，我将开始一个想法但暂时不完成它。我将使用这个用于类的新关键字，叫做，字面上就是，`class`。所以我们将在这里有一个新的关键字。如果你回到我们的幻灯片，这里会是官方 URL，你可以在那里阅读更多关于 Python 这个特性的内容。在官方教程中，`class` 是我们可以使用的一个新关键字。现在，这恰好与学生有关，因为学生上课（take classes），但这与我们正在处理学生的事实无关。`Class` 在很多语言中是一个通用的术语——Python 也是其中之一——它允许你为数据片段定义这些具有自定义名称的自定义容器。

所以让我们回到 VS Code。让我们使用这个新关键字。让我建议我们创建一个名为 `Student` 的类。按照惯例，我将在这里使用大写字母 S，然后，用一个冒号，稍后进入这个类的实现。所以我只使用三个点 `...`，这暂时是一个有效的占位符，它只是向我表明我稍后会回来实现它。但截至目前，它确实存在。我现在有了一个为我定义的 `Student` 类，我现在可以在我的代码中使用它了。

我将如何使用它呢？嗯，首先，让我到 `get_student` 函数，让我更改这段代码，不再使用字典，而是使用这个类。我将这样做。我将给自己一个名为 `student` 的变量，就像我之前做的那样，但我将把它设置为等于大写的 `Student()`。所以我将要做看起来像是调用一个函数的事情，那个函数，`Student` 带大写 S，注意，与我在文件顶部给这个类的名称相匹配。

好的，接下来我想要做什么？我将给这个学生一个名字。现在，如果我仍然使用字典，我会说 `student['name']`，使用方括号。但这不是一个字典。事实证明，类有所谓的，我们暂时称之为属性（attributes），某种性质，允许你在其中指定值。碰巧用于此的语法是一个点（dot）。我们以前见过点。我们在模块和更广泛的库的上下文中用过它。这是点的另一个类似用法的例子，它允许你访问某物内部的东西。所以 `student.name` 将是我用来给这个学生命名的语法。这个名字将是 “Name” 提示符的 `input` 函数的返回值。然后我将继续说 `student.house` 来给出另一个名为 “House” 的属性，并将 `input` 在这里提示用户输入 house 的返回值赋给它。然后，像以前一样，我将只返回 `student`。

但现在类真正强大的地方，以及更普遍的面向对象编程，在于我创建了这个自定义数据类型，字面上称为 `Student`，大写 S。我将这样一个学生存储在一个变量中，就像我总能做的那样，变量名为 `student`，小写 s。但我可以叫它任何我想要的名字。只是叫它 `student` 也很合理，但用小写以示清晰。然后我返回那个变量。并且由于我在第 14 和 15 行的语法，其结果是在那个类内部放入了一个 `name` 属性和一个 `house` 属性。

我只需要在这里再做一个更改。我将删除我们的帕德玛代码，这样我们就可以只关注新的内容，而不是修正她的学院。我将进入这里并更改以前用于字典的语法。再次强调，字典使用方括号，然后是引号中的字符串——单引号或双引号，取决于上下文。但在这里，我将把它改为 `student.name`，在这里，我将把它改为 `student.house`。这将是我获取名为 `student` 的类的内容的新语法。

让我重新运行 `python student.py`，回车。让我们像以前一样输入 Harry 的名字。让我们把他放在 Gryffindor，像我们经常做的那样交叉手指，Harry 确实来自 Gryffindor。

那么，我做了什么呢？让我们在这里引入另一个术语。事实证明，我可以使用 `class` 关键字创建一个类。但是任何时候你使用一个类，你都在创建所谓的对象（objects）。这就是面向对象编程（OOP）中的“对象”这个词。让我回到我的代码这里。即使我根本没有实现多少——我真的只是留下了点点点 `...`——这已经足够了，第 1 行和第 2 行的代码，就足以发明一种名为 `Student`（大写 S）的新数据类型，它可能有也可能没有一些未来的功能。这足以创建一个类。

那么，我在第 11 行做什么呢？在第 11 行，我技术上正在做的是创建那个类的一个对象。所以这又是另一个术语。你从类创建对象。所以如果我们回到那个比喻，一个类就像一个房子的蓝图，或者一个类就像一个模具，一个对象就是当你使用那个蓝图来建造一个特定的房子时，或者是当你实际使用那个模具来创建这样一个对象时，从模具中出来的东西——比如石膏制品。所以类，再次强调，是一个新数据类型的定义。对象是它的化身，或者技术上说是实例化（instantiation）。对象的另一个术语实际上是实例（instance）。你也有类的实例。

所以这是很多词汇。但归根结底，它就归结为这一点。你可以定义自己的类，这实际上是你自己的数据类型。然后你可以使用点表示法在其中存储属性。然后你可以使用像这里这样的代码访问那些相同的属性。现在，我有了一个合适的 "student" 数据类型，我不必使用元组、列表甚至字典来拼凑一些东西。我现在有了一个合适的名为 "student" 的数据类型，这不是 Python 的作者给我的；是我自己给自己的。

现在关于类，这个新的关键字 `class`，或者这些对象或其实例的概念，有什么问题吗？

**问：** 类对象是可变的还是不可变的？
**答：** 好问题。我们显然为现在讨论每种数据类型都奠定了基础。我们会看到它们是可变的，但你可以让它们变得不可变。所以你可以两全其美。现在，通过编写一些实际的代码——我们将编写比点点点更多的代码，稍后会看到。关于类或其对象的其他问题？

**问：** 那么这些类的属性会是什么？
**答：** 所以目前，属性——或者我到目前为止称之为的特性（attributes）——就是 "Name" 和 "House"。事实证明，类中可能还有其他内置的属性，我们可能很快就会看到。但就目前而言，我关心的仅有的两个属性是我自己创建的——即 "Name" 和 "House"，或者，我再次称之为属性。稍后，我们将开始更技术性地称这些相同的属性为实例变量（instance variables）。"Name" 和 "House"，正如我在 VS Code 中展示的那样，实际上只是名为 "name" 和 "house" 的变量，位于类型为 `student` 的对象内部。

好的，那么我们还能用这些类做什么更多的事情呢？再次强调，第 11 行是我们实例化 `Student` 类的一个对象并将其赋给 `student` 变量的地方。然后我们正在添加属性——分别是 "Name" 和 "House"——在当前的第 12 和 13 行。这两个属性的值技术上都是字符串（strs），因为这是 `input` 函数的返回值。但那些属性值实际上可以是任何数据类型。我们只是保持简单，专注于用两个字符串——"Name" 和 "House"——来定义学生。然后在第 14 行，我们返回那个变量。我们返回那个对象给 `main`，这样我们就可以实际打印出谁来自哪个学院。

好吧，让我们在这里添加更多功能，因为现在，在第 12 和 13 行，这有点手动。而且我只是把任何我想要的东西放进这个 `student` 对象里，这有点鲁莽。事实证明，与字典不同，使用类，我们可以更加标准化那些属性可以是什么，以及你可以将它们设置为什么类型的值。

所以让我这样做。让我建议，实际上如果能这样会非常好，而不是像现在这样做，让我按如下方式简化我的代码。让我创建一个名为 `name` 的局部变量，并将其设置为 `input` 的返回值，就像我们已经做过很多次的那样。让我暂时再创建一个名为 `house` 的变量，并将其设置为 `input` 的返回值，同样提示用户输入他们的学院。现在，不是先创建我的 `Student` 类的一个 `student` 对象，然后手动将 `name` 属性放入其中，将 `house` 属性放入其中，让我做一些更强大的事情。让我这样做。让我调用那个 `Student` 函数，它与类名完全相同——只要定义一个类，你就会得到一个名字与类名完全相同（包括大写字母）的函数。但是，不只是做开括号、闭括号，让我传入我想要填充这个对象的名字，以及我想要放入那个对象的学院。现在让我像以前一样将返回值设置为 `student` 等于这样。

## 六、 类的关键组成部分

那么我做了什么不同的事情呢？从根本上说，我仍然以相同的方式获取用户输入。我在第 11 行使用 `input`，在第 12 行使用 `input`。我只是碰巧将那些返回值存储在局部变量中。现在我们正在为类和更普遍的面向对象编程的更强大特性奠定基础。注意，我故意将 `name`, `house` 传递给这个大写 S 的 `Student` 函数——我正在向函数传递参数。现在，`Student` 类还不知道如何处理那些参数，但我现在正在标准化我如何将数据传递到这个 `Student` 类中。最终，它将给我一个机会来检查这些输入的错误，确保名字是有效的，它有值而不是用户只按了回车键。它将允许我确保这是一个有效的学院，它是 Gryffindor 或 Hufflepuff 或 Ravenclaw 或 Slytherin，而不是用户只按回车键或输入的某个随机值。因为我将 "Name" 和 "House" 传递给 `Student` 类，这个特定的函数，我将对我的数据的正确性有更多的控制。

所以现在让我们回到 `Student` 类，到目前为止，我只留下了点点点 `...`。事实证明，在类的上下文中，不仅有你可以放入其中的属性或实例变量，还有方法（methods）。类带有一些特定的方法，或者说类内部的函数，你可以定义它们，它们只是由于 Python 的工作方式而以特殊的方式表现。这些函数允许你以标准方式确定行为。从这个意义上说，它们是特殊方法。

现在，这是什么意思呢？好吧，让我回到 VS Code 这里。让我建议我开始定义一个标准的函数，叫做 `__init__`（双下划线 init 双下划线，缩写为 Dunder init），然后我将做开括号，然后我将在这里放入，字面上就是，单词 `self`。稍后会详细介绍。但是现在，在这个函数内部，我将有机会自定义这个类的对象。也就是说，这个 `__init__` 方法，或 Dunder init 方法，特别被称为实例方法（instance method），它的名字就是这样。这是由 Python 的作者设计的。如果你想初始化一个类的对象的内容，你定义这个方法，我们将看到它即将做什么。

让我回到 VS Code，让我做类似这样的事情。`self.name = name`，以及 `self.house = house`。但我不想只是非常通用地初始化这个对象。我希望这个名为 `init` 的方法不仅接收 `self`，还要接收 `name`, `house`。

现在，这到底是怎么回事？因为这里有很多奇怪的语法。有这个 Dunder `init` 方法——双下划线，init，双下划线。突然之间，有一个名为 `self` 的参数。然后有这个新语法——`self.name` 和 `self.house`。现在你真正看到了面向对象编程的一种体现。它与我们几周来用字典做的事情，比如向字典添加键，并没有根本的不同。但在这种情况下，我们正在向对象添加变量，也就是，向对象添加实例变量。

现在，发生了什么？让我们反过来看。让我们回到我们之前写的代码行。在第 15 行，我正在将这个类的名称——`Student` 带大写 S——当作一个函数来对待。我正在传递两个值——"Name" 和 "House"。我在屏幕上高亮的这里，在第 15 行，通常被称为构造器调用（constructor call）。这是一行将为我构造一个 `student` 对象的代码。用同义词来说，它将为我实例化（instantiate）一个 `student` 对象。

再说一次，它将如何创建那个对象呢？它将使用 `Student` 类作为模板，作为一种模具，这样每个学生都以相同的方式结构化。每个学生都会有一个名字。每个学生都会有一个学院。但是因为我可以向这个 `Student` 函数（大写 S）传递参数，我将能够自定义那个对象的内容。

所以如果你想想现实世界——如果你曾经在一条街道或一个社区，那里所有的房子看起来都一样，但它们可能被漆成不同的颜色；它们可能在外面装饰得有点不同，所有那些房子可能都是用完全相同的蓝图建造的——一个模具，如果你愿意的话。但是然后你可以专门化那些房子的细节。通过将外面漆成不同的颜色或种植不同的树木，你可以以不同的方式设计它们。这里的精神类似，我们有一个 `Student` 蓝图，它总是会有一个名字和一个学院，但由你我来传入我们想要的任何名字和任何学院。

现在，这个函数在哪里？我调用 `Student`（大写 S），然后是一个开括号和一个闭括号，里面有参数，这表明在世界上的某个地方有一个用 `def` 定义的函数将被调用。那么，你可能已经猜到了，根据 Python 类的工作原理定义，将始终被调用的函数是名为 `__init__`（双下划线 init 双下划线）的函数。为什么？这是一个疯狂的名字，但这正是 Python 的作者选择用来实现 Python 对象初始化的方式。

现在，唯一奇怪的事情——特别奇怪，我承认，是这个。对我来说，如果 `init` 仅有的两个参数只是 `name`, `house`，那会清晰得多。这就是我们到目前为止在类中定义每个函数的方式。你只需指定你希望函数接受的参数。这与我在第 15 行所做的一致。我只向 `student` 函数传递了两样东西。但事实证明，Python 的作者需要在这里给我们一点帮助，因为假设你将 "Name" 和 "House" 传递给这个 `init` 方法。而方法只是类内部的一个函数。你将如何处理名字和学院呢？字面上说，你将把它们放在哪里？如果你想为这个学生记住名字和学院，你必须能够将这些值存储在某个地方。你如何将它们存储在刚刚被“实例化”的当前对象中呢？

嗯，Python 的作者决定，惯例将是这个 `init` 方法也半秘密地接受第三个参数，它必须排在第一位。按照惯例，它被称为 `self`，但技术上你可以叫它任何你想要的名字。但惯例是总是叫它 `self`。而 `self`，正如其名所示，让你能够访问刚刚创建的当前对象。这是什么意思？再说一次，现在，在第 14 行，现在它向下移动了一点，这一行是一个构造器。它构造了一个 `student` 对象。但最初那个对象里什么都没有。没有名字；没有学院。但对象存在于计算机的内存中。现在由你来将名字和学院存储在那个对象内部。你该怎么做呢？

嗯，Python 会自动为你调用这个 `init` 方法，它会自动传入一个参数的引用，该参数代表它刚刚在内存中为你构造的当前对象，而由你来用值填充它。这意味着，在你的 `init` 方法内部，你可以字面上做 `self.name` 来在那个原本空的对象内部创建一个新的属性，也就是一个实例变量，并将这个 `name` 放入其中。它允许你做 `self.house` 并存储那个 `house` 的值。现在，你可以叫这些东西任何你想要的名字。它们可以是 `n`。它们可以是 `h`，像以前一样。但这真的不是很不言自明。更好的做法是遵循这种惯例。`self.name = name`。`self.house = house`。这就像在原本空的对象中安装 `name` 和 `house` 的值，并将它们存储在对象中，实际上是同名的实例变量中。再说一次，对象只是类的一个实例。

现在，我知道那是很多词汇。那是很多奇怪的语法。那么关于这个 `init` 方法，它存在的目的，再次强调，是在你首次创建对象时初始化一个原本空的对象，有什么问题吗？

**问：** 那么 `init` 方法和默认构造函数有什么区别？
**答：** 好问题。所以在其他语言中——如果你以前编程过。例如，Java——有一些函数被明确称为构造函数，它们构造一个对象。它们用值初始化它。Python 技术上称这个 `init` 方法为初始化方法。它初始化值。现在在我的代码的第 15 行，如果我向下滚动，我技术上正在构造对象。事实证明，在 Python 中还有另一个特殊方法，我们今天不会详细讨论，叫做 `__new__`（双下划线 new 双下划线），它实际上处理为我们在内存中创建一个空对象的过程。但是，一般来说，你，程序员，不需要操作 `new` 函数。它为你工作。相反，你在这里定义你自己的 `init` 方法，在你的类内部定义 `init` 函数，那个方法初始化对象的内容。所以技术上讲，用 `new` 构造对象和用 `init` 初始化它之间是有区别的。但在 Python 的世界里，你几乎只需要关心 `init` 方法。Python 通常会为你做另一部分。好问题。其他问题？

**问：** 如果你想存储多个名字或多个学院怎么办？
**答：** 好问题。如果你想存储多个名字或多个学院，你可以用不同的方式来做。你可以创建其他属性——技术上称为实例变量——比如 `self.name1`, `self.name2`。但我们过去已经看到，仅仅拥有多个变量来存储多个东西并不是一个很好的设计。也许，你可以有一个名为 `self.names`（复数）的实例变量，并将其设置为一个名字列表或一个学院列表。现在，在这种情况下，我认为这并不能真正解决问题，因为我试图实现一个学生（单数），所以拥有多个名字并没有真正的意义。也许一个昵称，也许一个姓氏，所以我们也可以添加那些。但我认为我们本身不需要多个名字，在这种情况下，也不需要多个学院。但绝对地，你可以使用我们熟悉的一些构建块，比如列表来做到这一点。其他问题？

**问：** 类或对象在内存中是如何表示的？
**答：** 类和对象在内存中是如何表示的？所以类技术上只是代码。它是我文件顶部的代码——第 1 到 4 行——定义了那个蓝图，那个模板，如果你愿意的话。对象通过占用一定数量的字节存储在计算机的内存中。所以你可能熟悉字节、千字节或兆字节。有一块字节，可能都在计算机内存或 RAM 中的同一个位置，对象就存储在那里。但那是 Python 这个程序为你处理的。Python 解释器会找出在计算机内存的哪个位置放置它。你我，程序员，可以在这个层面上思考和解决问题。Python 解释器为你处理那些较低级别的细节。关于类和对象的最后一个问题怎么样？

**问：** 所以我的问题是，如果我们用字典也能做同样的事情，那为什么要用类呢？
**答：** 好问题。如果你能用字典做同样的事情，为什么要用类呢？因为我们现在才刚刚开始触及你能用类做什么的表面。请允许我现在回到我的键盘，向你展示更多你能用类做的事情。但简而言之，你可以用类做更多的事情。你可以用类来更确保你数据的正确性。你可以检查错误。总的来说，你可以更有效地设计更复杂的软件。我们今天将继续看到 Python 和更普遍的面向对象编程的特性，使我们能够做到这一点。

事实上，让我建议，首先，让我们把当前的实现精简一下，这再次让我们有了一个 `init` 方法，它只声明了两个实例变量——`self.name` 和 `self.house`，这再次强调，只是在原本空的对象内部创建那些变量，并分别给它们赋值 `name` 和 `house`。让我在这里做一件小事。我并不真的需要这个 `student` 变量。让我把它精简一下，这样每次我们改进或更改代码时，我们都真正只关注最小的变化。所以我根本上没有做任何不同的事情。我只是去掉了变量名，我只是返回这个 `student` 函数的返回值，它为我构造了我的新对象。所以我只是像我们过去多次做的那样精简事情。

那么，如果在创建这个学生时出了问题怎么办？例如，如果用户没有给我们一个名字，而只是在提示输入名字时按了回车键。我不想在我的计算机内存中放入一个没有名字的虚假 `student` 对象。理想情况下，我希望在创建它之前就检查错误，这样我就不会创建一个没有名字的学生。拥有一个没有名字的对象会很奇怪，而且可能是一个 bug。同样，我也不想让用户能够输入一些随机的东西作为他们的学院。至少在哈利波特的世界里，霍格沃茨（Hogwarts）真的只有四个学院。再强调一下，有格兰芬多（Gryffindor）、赫奇帕奇（Hufflepuff）、拉文克劳（Ravenclaw）和斯莱特林（Slytherin）——一个包含四个有效学院的列表。如果我能以某种方式验证用户的输入确实在该列表中，那就太好了。

现在，我可以在我的 `get_student` 函数中完成所有这些验证。我可以检查，名字是否为空？如果是，则不创建 `student` 对象。学院是否是那四个学院之一？如果不是，则不创建 `student` 对象。但这将与学生本身相当脱节。`get_student` 目前只是我 `student.py` 文件中自己的一个函数。但是类——以及更普遍的面向对象编程——鼓励你将与该类相关的所有功能封装（encapsulate）在类内部。所以如果你想验证一个名字是否存在——如果你想验证一个学院是否正确，这从根本上就属于名为 `student` 的类本身，而不是你写在别处的某个随机函数。再说一次，这只是方法论，因为，再次强调，如果我们考虑编写越来越长、越来越复杂的代码，如果你将所有与学院相关的代码——所有与名字和所有与学院相关的代码都放在 `student` 中，这应该具有直观意义，这只是更好的组织。将所有相关的代码放在一起，这可能会为你带来更多成功。事实上，这正是面向对象编程方法论的一部分。

让我现在更改我的 `Student` 类的 `init` 方法来做这个。如果名字是空的——所以 `if not name`——我们以前见过这种语法。如果你在 Python 中，用 Pythonic 的方式说，`if not name`，那就像是在做这样：`if name == ""`——但我可以更优雅地做到这一点。只说 `if not name` 会更 Pythonic。那么，我想返回一个错误。我可能想做类似这样的事情：`print("missing name")`。但这还不够好。仅仅打印出 "missing name" 然后让剩下的代码继续执行是不够的。

好吧，那我还能做什么呢？过去，我们见过另一种技术，我可以使用 `sys.exit`，然后说类似 "missing name" 的话，我可以到上面导入 `sys`。但这对于问题来说是一个非常令人讨厌的解决方案。仅仅因为你或者可能是你的同事搞砸了，用一个无效的名字调用了一个函数，你就要退出我的整个程序？这真是一种非常极端的响应，如果你的程序正在运行中，你可能不想这样做。你可能想清理一些东西。你可能想保存文件，你不想仅仅因为输入无效就在某个任意行退出程序。所以我想我们也不想这样做。

但是，我们现在确实有了一种发出错误信号的机制。不幸的是，我不能做类似这样的事情。我可以尝试返回 `None` 并说，啊哈，这个学生不存在。我将把 `None` 还给你。但是太晚了。如果我们向下滚动回到我创建学生的地方，现在在第 17 行，我高亮了这段代码。学生已经被创建了。在计算机内存的某个地方有一个对象，它的结构是 `student`。它只是里面没有任何值。但因此，返回 `None` 已经太晚了。那艘船已经开走了。对象存在。你不能突然说，不不，没有对象。有一个对象。由你来发出错误信号。你如何发出错误信号呢？

嗯，我们实际上以前见过这个，但我们没有机会创建我们自己的错误。事实证明，在 Python 中，还有一个与异常（exceptions）相关的关键字，Python 本身用它来引发（raise）我们过去讨论过的所有那些异常。当你捕获像 `ValueError` 或 Python 自带的其他此类异常时，嗯，事实证明，你，程序员，也可以在某些事情真的出错时引发——也就是创建你自己的异常——不是错到你想退出整个程序，但足以让你需要以某种方式提醒程序员发生了错误。发生了异常的事情，以一种非常糟糕的方式——发生了异常的事情，让他们根据需要尝试捕获那个异常。

所以让我回到 VS Code 这里，建议，如果用户传入一个无效的名字——它只是空的，所以没有名字。那么，我真正想做的是这个。我想引发一个 `ValueError`。我们以前见过 `ValueError`。我们以前意外地创建过 `ValueError`。通常，你我都试图在它们发生时捕获它们。嗯，Python 这种异常特性的另一面是，你，程序员，也可以在异常情况发生时引发异常。你甚至可以更精确。你不必引发一个通用的 `ValueError` 然后让程序员自己弄清楚哪里出了错。你可以像对待函数一样对待 `ValueError` 和 Python 中的所有异常，并实际向它们传递一个解释性的消息，比如，引号里的，“Missing name”，这样至少程序员在遇到这个错误时知道，哦，我搞砸了。我没有确保用户有一个名字。

现在，你想做什么呢？好吧，现在，如果你是程序员，你可以做类似这样的事情。你可以尝试（try）创建一个学生，除非（except）出现 `ValueError`。然后你可以用某种方式处理它。我将用点点点 `...` 来示意你将如何处理它。但你会像我们过去那样使用 `try` 和 `except` 来处理它，那将允许你，程序员，尝试创建学生。但如果出了问题，好的，我还是会处理它。

所以这里的新东西，再次强调，是这个 `raise` 关键字，它只是让你我可以实际引发我们自己的异常来发出这些错误信号。

好吧，让我回到我的代码这里，我暂时不打算尝试或捕获这个错误。现在，我们将只专注于引发它，并假设，根据我们对异常的回顾，你可以在需要的地方添加 `try` 和 `except`。

让我回到代码这里，建议关于 `house` 可能还有其他问题。如果有一个名字，我们没问题。但是如果我们得到了一个 `house` 但它是无效的，我们也应该为此引发一个异常。那么我们这样做怎么样？如果 `house` 不在包含 "Gryffindor"、引号里的 "Hufflepuff"、引号里的 "Ravenclaw"、引号里的 或 "Slytherin"、引号里的 这个列表中，那么，用我的冒号，让我们引发另一种类型的 `ValueError`。但不是引发一个通用的 `ValueError`，让我们传入一个参数，引号里的，“Invalid house”。

所以现在我们看到了一个我们可以用类做到而用字典做不到的能力。如果你向字典添加一个属性，一个键，无论如何它都会进去。即使名字是空的，即使学院是一个完全随机的文本字符串，不是这四个学院之一，它也会进入那个字典。但是有了类，并且通过这个 `init` 方法，你我现在可以精确地控制将要被安装，如果你愿意的话，在这个对象内部的东西。你现在对正确性有了更多的控制。

所以现在让我向下滚动回到我的终端窗口并清空它。让我运行 `python student.py`。让我输入像 Harry 这样的名字。让我输入 Gryffindor，回车，我们看到，确实，Harry 来自 Gryffindor。但如果我犯了一个错误呢？如果我运行 `python student.py` 并输入 Harry 作为名字，但这次输入 Number Four, Privet Drive（他在那里长大），而不是他正确的霍格沃茨学院。现在让我按回车键，现在你看到了一个 `ValueError`。但这并不是 Python 本身为我们生成的。是我引发了这个错误。因此，如果我进入我的 `get_student` 函数并编写更多代码，我也可以用我们通常的 `try except` 语法捕获这个错误。

所以我们现在不仅在工具箱中有了类，而且在异常方面有了更多的能力，不仅能自己捕获它们，还能自己引发它们。

现在关于这种使用类和 `init` 以及现在这种在初始化内部出错时引发异常的能力，有什么问题吗？

**问：** 如果用户有中间名怎么办——名、中间名和姓？你会怎么解决？
**答：** 好问题。如果你想让学生有一个名、中间名和姓，我们可以用很多不同的方式来做。最简单的，不过，如果——让我清空我的屏幕，让我暂时这样做。让我建议 `init` 方法接收一个 `first` 参数，一个 `middle` 参数，和一个 `last` 参数。然后我认为我最终会在这里做的是 `self.first = first`，然后我会对 `middle` 和 `last` 做同样的事情。所以 `middle` 和 `middle`，然后 `last` 和 `last`。然后我在这里需要做的是，当我实际向用户询问他们的名字时，我可能真的需要全力以赴。我可能需要先问他们的名字（first name）并将其存储在一个名为 `first` 的变量中，因此传入 `first`。我可能同样需要问他们的中间名并将其存储在一个变量中，然后传入第二个参数 `middle`。然后最后，如果你愿意的话，让我创建第三个名为 `last` 的变量，获取他们姓氏的输入，并将其作为第三个参数传入。

我也可以只使用一个 `input` 并只问他们的全名。所以输入 David Malan，回车，或者 David J. Malan——所有三个，也许我可以使用 Python 的 `split` 函数，也许使用正则表达式来将其分开。那可能会很麻烦，因为会有人不止有两三个名字。他们可能有四个或五个。所以也许有时候有多个提示更好。但这不是问题，因为有了类，如果我们想，我们有表达能力来接收更多的参数。如果我们想，我们甚至可以接收一个列表。但我认为我们可能需要更多的错误检查，不仅是针对 `name`，还有 `first`，然后可能是 `middle`，然后可能是 `last`。所以这只是越来越多的代码，尽管有办法也许可以整合它。让我撤销所有这些，看看现在关于类是否有其他问题。

**问：** 我假设类是我可能在项目开始时会做的事情。我可以把它们放在一个不同的文件里，然后在需要的时候把它们导入到我的项目或我的主代码中吗？
**答：** 当然可以。一个非常好的问题。你可以想象想要使用这个 `Student` 类，不仅在 `student.py` 中，也在你的其他文件或其他项目中。绝对可以，你可以通过将 `Student` 类放入你自己的模块或包中来创建你自己的类库，根据我们过去关于库的更广泛的讨论。绝对可以这样做。今天晚些时候，我们会看到我们实际上一直在使用类——你和我——以前，在第三方库中。所以你，也绝对可以做同样的事情。关于类的最后一个问题怎么样？

**问：** 你可以在类中有可选变量吗？还有，你可以有自己的错误名称吗，比如——让我们自负一点说我想引发 Eric 错误？
**答：** 简短回答，是的。这些 `init` 函数就像 Python 函数更普遍的情况一样，尽管它们特殊之处在于它们会被 Python 自动为你调用。但是如果你想让 `house` 成为可选的，你可以这样做。你可以在 `init` 函数的签名中，可以说是——在那第一行代码的第 2 行——给它一个默认值。那将允许我不必传入 `house`。在这种情况下，我将继续总是传入 `name` 和 `house`，但你可以让事情变得可选。是的，对于你的第二个问题，如果你想拥有自己的错误消息，比如一个 Eric 错误，你实际上可以创建你自己的 Eric 错误异常。稍后我们会看到，实际上存在一整套异常，你也可以发明那些。

不过，让我建议我们现在引入这方面的另一个方面，我们尝试打印出一个学生看起来像什么。目前，如果我向下滚动回到我的 `main` 函数，我仍然非常手动地打印学生的姓名和学院。我进入对象内部，执行 `student.name`，然后我再次进入对象内部并获取 `student.house`，只是为了看看学生来自哪里。但是如果我能像我几周来打印任何 `int`、`float`、`str` 或任何其他数据类型那样，只打印学生，那岂不是很好？

好吧，让我们看看如果我只尝试打印学生，而不是手动进入内部并尝试自己创建那个句子会发生什么。好吧，在我的终端窗口中——让我再次运行 `python student.py`。让我输入 Harry。输入 Gryffindor。然后瞧，Harry——哇，好的，`__main__.Student object at 0x102733e80`。那么，发生了什么？嗯，如果你运行同样的代码，你可能实际上在你的计算机上看到关于那个数字的不同东西。但你真正看到的是这个特定对象的底层字符串表示。特别地，你看到的是它在计算机内存中的位置。这个数字，`0x102733e80`，本质上指的是计算机内存或 RAM 中的一个特定位置。这对我或你或，一般来说，程序员来说并不是那么有趣，但这只是通过 `print` 描述这个东西是什么的默认方式。

但我也可以覆盖这个。事实证明，在 Python 中关于类还有其他特殊方法——不仅仅是 `__init__`（双下划线 init 双下划线），而且，延续同样的模式，`__str__`（双下划线 str 双下划线）。所以这也是一个特殊方法，如果你在你的类中定义它，Python 会在任何其他函数想要将你的对象视为字符串时自动为你调用这个函数。`print` 想要将你的对象视为字符串。但默认情况下，如果你的类中没有定义这个方法，它将打印出那个非常丑陋、深奥的化身，它会说 `__main__.Student object at 0x...`。

那么我如何定义我自己的 `str` 函数呢？好吧，回到 VS Code，让我建议我进入并定义不仅仅是 `__init__`，让我在这个类中定义第二个函数，如下所示——`def __str__(self)`。有两个下划线。即使 VS Code 中的字体把两个下划线放得如此之近，以至于它看起来像一个更长的下划线。在左边和右边确实有两个，就像 `init` 一样。这个只接受一个参数，按照惯例总是称为 `self`，这样你就可以访问它。然后，在冒号后的缩进下面，我将创建一个格式化字符串并返回它。所以让我先返回一些通用的东西，比如 `"a student"`。所以我甚至不打算费心去弄清楚这个学生的名字或学院是什么。我总是只返回 `"a student"`。

现在让我回到我之前的代码，它在第 16 行有 `print(student)`。让我清空我的终端窗口并重新运行 `python student.py`，回车。输入 Harry，输入 Gryffindor。上次，我看到了那个非常神秘的输出。这次，我更通用地看到 `"a student"`。更易读但不是很启发性。这是哪个学生？

嗯，注意 `__str__` 方法默认接收这个 `self` 参数。这只是 Python 作者设计这个方法的方式。它总是会被传递一个对当前 `student` 对象的引用。这是什么意思？当第 6 行的这行代码被调用时，`print`，因为它希望得到一个字符串，将触发 `__str__` 方法被调用。而 Python，为你，会自动将一个对试图被打印的对象的引用传递给那个方法，这样你，程序员，就可以做类似这样的事情。这是一个带有双引号的 f-string，像往常一样。我将使用一些花括号并说打印出 `self.name from self.house`。所以我刚刚做的并没有什么新东西。它只是一个 f-string——开头的 f，两个双引号，几对花括号。但是因为，自动地，这个 `str` 方法被传递了 `self`，可以说，一个对当前对象的引用，我可以进入那个对象内部并获取名字。我可以再次进入那个对象内部并获取学院。

所以现在，当我回到我的终端窗口时——之前它只打印出一个学生。但是现在，如果我运行 `python student.py`，回车——输入 Harry，输入 Gryffindor，再按一次回车，Harry 又来自 Gryffindor 了。但如果我再运行一次——例如，我们让 Draco 来自 Slytherin，回车。Draco 来自 Slytherin。现在它根据我们试图打印的具体对象进行了定制。

关于这个函数——这个 Dunder `str` 方法，有什么问题吗？

**问：** `__str__` 方法还能做其他事情吗？第二个问题是，`str` 和 `repr` 有什么区别？
**答：** 好问题。所以 Python 类附带了许多其他以双下划线开头的方法。我们只是触及了表面，我们将主要关注这些。但是是的，还有很多其他的，我们稍后至少会看到另一个。其他的包括一个叫做 `repr` 的，它是 Python 对象的表示（representation）。一般来说，`__repr__`（双下划线 repr 双下划线）方法是为开发者准备的。它通常比 "Harry from Gryffindor" 包含更多信息。它还会说明它是什么类型的对象，比如 `Student`，大写 S，而 `__str__`（双下划线 str 双下划线）通常是为用户准备的——程序的用户，并且它旨在更加用户友好。但这两个都可以根据你的需要被覆盖。

好吧，让我现在建议我们从我们中断的地方继续讨论 `student`，并添加更多功能，但不仅仅是像 `__init__` 和 `__str__` 这样的特殊方法。让我们创建我们自己的方法，因为如果你我作为程序员可以发明特定于学生的新功能，那么类的真正力量和灵活性就在于此。

例如，霍格沃茨的学生在校期间学会了如何施放某种类型的咒语。所以当他们说，“Expecto Patronum”（呼神护卫）时，通常会从他们的魔杖中出来一些类似于动物或其他东西的东西。这是一种他们必须不断练习的特殊咒语。那么，让我们看看我们是否不仅能存储学生的名字和他们的学院，还能存储他们的“守护神”（patronus），也就是他们使用这个咒语时实际召唤出来的东西。

好吧，让我清空我的终端窗口。在我代码的顶部，在 `Student` 的 `init` 方法中，让我开始期望第三个参数，除了自动传入的 `self` 之外，叫做 `patronus`。我现在不打算担心从一个有效的守护神官方列表中验证守护神（patronus 或 patroni）。我将只是盲目地将其赋给 `self.patronus = patronus`，我们将让用户暂时输入任何他们想要的东西。但如果我想将守护神限制在一个特定的列表中，我当然可以在这里添加更多的错误检查。

现在让我继续提示用户输入这个守护神，通过——在我的 `get_student` 函数中——定义一个名为 `patronus` 或其他任何名称的变量，提示用户输入他们的守护神。现在我将在这里传入第三个变量。所以再次强调，与向类添加越来越多属性的精神类似，我将传入所有这三个值，而不仅仅是两个。我暂时不会用那个值做任何有趣的事情。但只是为了确保我没有通过破坏我的代码让事情变得更糟，让我运行 `python student.py`。我将输入 Harry。我将输入 Gryffindor。事实证明他的守护神是一只雄鹿（stag）。然后按回车。我还没有在我的输出中看到他的守护神是什么，因为我还没有更改我的 `str` 方法。但至少我没有任何语法错误。所以至少我没有让任何事情变得更糟。

但假设，现在，我想要的功能不仅仅是初始化一个学生和打印出一个学生。如果我的类真的是要代表一个学生，我能做的不仅仅是记住关于学生的数据信息。类与单独的字典不同，其强大之处在于类不仅可以有变量或实例变量——那些我们不断创建的属性。它们还可以内置函数，也就是方法（methods）。当一个函数在类内部时，它被称为“方法”，但它仍然只是一个函数。

到目前为止，我们已经看到了两个函数——两个方法——叫做 `__init__` 和 `__str__`，但那些是特殊方法，因为它们就是能工作。如果你定义了它们，Python 会自动为你调用它们。但是如果你想为学生创建更多功能，以便你的类真正代表这个现实世界，或者也许是“幻想”世界中的学生概念，学生不仅有名字、学院和守护神；他们还有功能。他们可以执行动作，比如施放一个魔法（charm）、咒语。

我们能否因此实现一个名为 `charm` 的函数，它实际使用他们的魔法知识？好吧，让我们继续定义我们自己的函数，如下所示。让我清空我的终端窗口，向上滚动回到我的 `Student` 类。而不是创建另一个带有双下划线的特殊函数，我将在这个类内部发明我自己的函数，或方法。我想给 Harry、Hermione 和所有其他学生施放魔法的能力，所以我将定义一个我可以完全自己命名的函数，叫做 `charm`。我可以叫这个函数任何我想要的名字。但因为它是一个类内部的方法，惯例是它总是至少接受一个名为 `self` 的参数，按照惯例，这样即使你本身不打算使用它，你也可以访问当前对象。

好吧，让我建议我们以这样一种方式实现 `charm`，即该方法返回一个适合每个学生守护神的表情符号。如何实现这个——嗯，在 `charm` 方法内部，让我们对 `self.patronus` 进行匹配（match），这是包含代表每个学生守护神的字符串的实例变量。在它匹配雄鹿（stag）的情况下，例如对于 Harry，让我们返回也许最接近的表情符号——这里的这匹马 🐎。对于水獭（otter）的情况怎么样？嗯，在这种情况下，让我们返回，哦，也许与水獭最匹配的——可能是这个表情符号 🦦。让我们看看，在——对于 Ron 而不是 Hermione——杰克罗素梗（Jack Russell terrier）的情况下，让我们返回——这里的选项不多。为什么我们不返回那种情况下最可爱的可用狗 🐕。在没有识别出守护神的情况下，就像可能涵盖像 Draco 这样的人，让我们使用下划线 `_` 作为默认情况，就像过去一样，让我们为此返回——哦，如果有人没有守护神应该发生什么？为什么我们不只看到一根似乎熄灭了的魔法棒 ✨，就像这种情况？

好的，那么，现在，不只是打印学生，让我们打印他们实际的守护神。所以我将回到我的 `main` 函数。我仍然使用 `get_student` 函数获取一个学生。但不打印 `student`，让我们声明 `"Expecto Patronum!"`，只打印纯文本。现在让我们打印出，不是学生，而是他们自己的 `charm` 方法的返回值。

所以让我回到我的终端窗口，运行 `python student.py` 并回车。姓名——让我们从 Harry 开始。他住在 Gryffindor。守护神是雄鹿。让我们看看——Expecto Patronum! 当然，我们会看到雄鹿表情符号 🐎。像 Draco 这样的人怎么样，至少在书中，他没有已知的守护神？好吧，让我们清空我的终端窗口，重新运行 `python student.py`，这次，让我们输入 Draco 作为名字，Slytherin 作为学院，守护神是未知的。所以我只按回车键。现在，Expecto Patronum! 它只是嘶嘶作响 ✨。

好吧，让我现在建议我们移除这个守护神代码，只是为了简化我们的世界，并专注于类的一些其他核心能力。所以冒着让大家失望的风险，我将去掉所有这些漂亮的表情符号和魔法，我将不再询问用户的守护神。我将停止在这里将其传入 `init`。我将停止在这里做这个。我将改为恢复我们使用 `print(student)` 的方式。我将在这里去掉 `patronus`。所以基本上撤销我们刚刚创建的所有有趣的魔法。

所以我们现在回到了故事的这一点，我们有一个 `Student` 类，只有两个方法——`init` 和 `str`。第一个当然接受 `self` 作为第一个参数，因为它总是会的，外加现在两个——`name` 和 `house`，不再有 `patronus`。我们在这里验证 `name`。我们在这里验证 `house`。然后我们将 `name` 和 `house` 分别赋给两个也称为 `name` 和 `house` 的实例变量。但是我们使用 `self` 来访问当前对象，以便在那里存储那些值。然后我们仍然有我们的 `str` 方法在这里，它接受一个参数——默认是 `self`，就这样。这个函数会在任何时候你想将 `student` 对象转换为字符串时被自动调用，就像 `print` 可能想在这里做的那样。

所以让我先确保我没有破坏任何东西。让我运行 `python student.py`。我将输入 Harry。我将输入 Gryffindor，回车。好的，我们又回到正轨了。魔法和守护神不见了，但至少我回到了有名字和学院的情况。

但事实证明，目前，我们对类的使用不是很健壮，即使我们有这个机制，非常聪明地，如果我可以这么说的话，在我们的 `init` 方法中确保我们验证 `name` 和 `house`，确保 `name` 不为空，并确保 `house` 是那四个霍格沃茨学院中的一个有效学院。事实证明，类仍然会让我通过点表示法访问那些属性，那些所谓的实例变量。

让我向下滚动，尝试有点对抗性地这样做。假设在第 16 行我调用 `get_student`，它像以前一样存在，然后我将返回值存储在一个 `student` 变量中——再次强调，在第 16 行。这将确保 `get_student` 被调用，它会调用 `input` 和 `input`。然后它调用 `student` 构造函数，这会自动调用这个 `init` 方法。所以通过我们布局代码的方式，我们将确保 `name` 不为空，并且 `house` 绝对是那四个值之一。我的错误纠正——或者说错误检查已经就位了。

但如果我有点对抗性，我仍然可以绕过它。假设——好吧，要我输入 Harry 和 Gryffindor？我将输入 `student.house = "Number Four, Privet Drive"`，你将无法阻止我。为什么？嗯，事实证明，对于类及其对象，你我仍然可以使用这个熟悉的点表示法访问那些实例变量。这就是我们开始类故事的方式——只是自己设置这些属性。但你也可以读取这些属性本身，如果你想的话，稍后可以更改它们。这将有效地规避我们 `init` 方法中的 `if` 条件和另一个 `if` 条件，因为那只在你首次创建 `student` 对象时被调用。目前，没有什么能阻止我事后更改 `house` 或 `name`。

所以如果我现在清空我的终端窗口并运行 `python student.py`，我仍然会输入 Harry 和 Gryffindor 来满足我的要求，即学院必须是那四个之一。但是当它被打印出来时，注意，我仍然覆盖了它。所以看起来，虽然类确实允许我们对我们存储的数据有更多的控制，但它并不一定阻止用户——或者更确切地说是程序员——无论是我自己还是可能是我的同事，仍然把事情搞砸。

所以在这里，本着更防御性编程的精神，请允许我介绍 Python 的另一个特性——即属性（properties）。属性实际上只是一个具有更多防御机制的属性，由你实现一些额外的功能来防止像你我这样的程序员搞砸这些属性。所以再说一次，属性将是一个你我对其有更多控制的特性。如何做到？我们只需使用一些 Python 约定编写更多的代码。我们将如何做到这一点，将在稍后使用一个特性——一个名为 `@property` 的关键字，它技术上是一个函数。`property` 是 Python 中的一个函数。但我们即将看到一些新的 `@` 语法，允许你装饰（decorate）函数。这又是另一个术语。在 Python 的世界里，你可以有装饰器，它们是修改其他函数行为的函数，如果你愿意的话，我们就说到这里，不再深入细节。我们将通过例子看到你如何使用这些装饰器，特别是定义属性。

所以让我回到 VS Code 这里。让我建议我这样做。我将创建一个——名为 `house` 的属性怎么样，如下所示。在我的 `Student` 类内部，我将——在我的 `init` 方法和 `str` 方法下面，我将定义一个名为 `house` 的函数，它像往常一样必须至少接受一个参数，名为 `self`。我现在要做的是返回 `self.house`。所以我只是定义了一个名为 `house` 的方法，它存在的唯一目的是返回 `house` 的值。

但我将定义另一个方法，奇怪的是也叫 `house`，但它将接受两个参数——`self` 像往常一样，还有一个名为 `house` 的值。我现在将这样做。我将做 `self.house = house`。现在，我做了什么？嗯，让我暂时在这里添加一些注释。稍后，我们将开始普遍地称这个为 getter（获取器）。在这里，我将称这个为 setter（设置器）。这是你在 Java 世界中经常看到的术语。你们中有些人以前用 Java 编程过。但正如其名所示，getter 是一个类的函数，用于获取某些属性。setter 是某个类中的函数，用于设置某个值。

现在，即使我们还没有完成，并且在我已经编写的代码中有一点错误，直观地看，我们将要做的是这个。我们试图阻止程序员，包括我自己，绕过我为 `name` 和 `house` 设置的错误检查。我该怎么做呢？嗯，我们在编程中没有那么多的构建块。我们有像用于数据的变量，和用于动作的函数。那么我们为什么不这样做呢？为什么我们不以某种方式要求，为了访问一个属性，你必须通过某个函数。让我们要求，为了设置某个属性，你必须通过某个函数。按照惯例，那些函数被称为 getter 函数和 setter 函数。为什么我们使用函数，或者在这种情况下，类内部的方法？嗯，一旦你有了函数，那些只是你我可以自己创建的动作或动词。我们可以在这些函数中放入任何我们想要的错误纠正，因为它是将从上到下执行的代码。

那么我现在如何阻止用户将 `house` 设置为一个无效的值呢？让我借用之前的一些逻辑，而不是盲目地这样做——只是将 `self.house` 设置为传入的 `house` 值——让我们在那里添加我们的错误检查。所以 `if house not in` 以下列表 Gryffindor 或 Hufflepuff 或 Ravenclaw 或 Slytherin，就像以前一样，让我们引发一个 `ValueError`，只是为了表明，啊哈，出错了。我会更明确。我会包含一条消息，比如，引号里的，“invalid house”。否则，我现在将在第 21 行继续设置 `self.house` 为 `house`。所以我只是复制了，如果你愿意的话，或者在我的这个所谓的 setter 函数内部重新输入了我的错误检查。

现在，我为什么那样做呢？嗯，要清楚的是，每当用户或程序员编写像 `student.house = ...` 这样的代码时，即将神奇地发生的是 Python 不会仅仅让程序员直接访问 `student.house`——那个属性，那个实例变量，也就是 `self.house`。它会神奇地自动为我调用这个 setter 函数。Python 如何知道要这样做呢？嗯，如果它看到，在左侧，有 `self.house`，其中 `house` 是 getter 或 setter 的名称，然后它看到一个等号，表示赋值，这足以作为一个视觉线索说，等一下。我不会让你直接访问那个属性。我将改用 setter。为什么？因为等号意味着我试图设置。我试图将一个值从右到左赋给那个属性。所以 Python 将自动为我调用这个函数。这太棒了，因为现在我可以执行代码——一个算法来检查，我是否想让用户——程序员将那个属性设置为那个值？如果不允许，我将引发一个 `ValueError`，你就不能这样做。如果允许，好的。我会为你设置它。

但为了做到这一点，我们需要更多的语法。我将去掉我的注释，我将使用那个装饰器。我需要告诉 Python 将这个方法视为一个 getter。然后 setter 的语法有点不同。你现在说 `@house.setter`。我希望一个是 `@getter`，另一个是 `@setter`。这不是他们设计的方式。当你想定义一个 getter 时，你只需在函数上方说 `@property`。你将函数命名为与你希望属性被调用的名称完全一样——引号里的，“house”。一旦你这样做了，你现在可以使用一个为你自动创建的新装饰器，叫做 `@house`，因为我叫它 `house`。然后你字面上说，`@house.setter`。这整行，在第 17 行，是对 Python 的一个线索，表明这里来了一个函数，它的名字是相同的——但注意它接受两个参数——`self`，这样你就可以访问对象的内容，还有 `house`，这将只是一个来自程序员、来自人类输入返回值的字符串，这样你也可以设置那个值。

但是现在我需要在这里做一个修正。我认为其他一切仍然是好的。然而，看这个。我不再需要这里的这个错误检查了。为什么？因为，如果我向下滚动回到我的代码这里，我刚才声称像 `student.house = ...` 这样的代码会自动让 Python 为我调用我的 setter。猜猜怎么着？即使在这里，在我的 `init` 方法中，调用 `self.house = ...` 也会调用我的 setter 方法，这太棒了，因为现在我可以将我所有的错误检查放在 setter 中的一个地方，它现在会在我首次创建对象时被调用，因为 `init`，或者即使程序员试图绕过那个 `init` 方法并更改这个属性的值，我的 setter 也会被调用。任何时候我访问 `.house`，我的 setter 都会被调用。

但我需要做一个修正。不幸的是，我的名字冲突了。现在，如果我们回到这里，在第 5 行，这是一个实例变量。它是我的 `self` 内部的一个字符串，在当前 `student` 对象内部，名为 `name`。这是另一个名为 `house` 的实例变量。不幸的是，如果我有一个名为 `name` 和 `house` 的实例变量，我就不能同时拥有名为 `house` 的函数。它们会冲突。你必须决定。你想让变量被称为 `house` 吗？还是你想让函数被称为 `house`？不幸的是，你不能两者兼得，因为现在 Python 会将一个误认为是另一个。所以对此的常规修正是这样做——让 setter 不将传入的值存储在 `self.house` 中，而是使用一个几乎相同的名字，但使用一个小指示符，表示你知道这样做是正确的。按照惯例，你通常在实例变量的名称前加一个下划线。当你在这里返回它时，你同样加一个下划线。所以现在，技术上，我的实例变量叫做 `_house`，但我的属性，如果你愿意的话，它是一个更高级的属性，叫做 `house`，没有下划线。我知道这有大量的语法，但这是一个非常强大的特性。再次强调，这就是为什么你可以从单独使用字典毕业，并拥有如此多的功能供你使用。

让我清空我的终端窗口并运行 `python student.py`，回车，名字。好的，让我们输入 Harry。让我们输入 Gryffindor。像往常一样交叉手指。现在，看，“Invalid house”。这是件好事。为什么？因为，注意，在我的 `main` 函数中，我仍然试图，恶意地，如果你愿意的话，将 Harry 的学院更改为不是那四个有效学院之一。我试图将其更改为他童年的家 Number Four, Privet Drive。但是因为 Python 知道，等一下，你试图赋值——也就是设置一个值——而那个值，也就是 `house`，现在被定义为一个属性，你将不得不通过 setter 函数来更改那个值。并且因为我有这个 `raise ValueError`。如果 `house` 不符合预期，你将不被允许将其更改为一个无效的值。所以我保护了数据在进入时，通过 `init` 方法，我甚至在你试图在那里覆盖它时防御了数据。

所以我认为对我这个程序员来说，唯一的解决方案是，不要试图破坏我自己的代码。让我删除那一行，因为它就是行不通。让我运行 `python student.py`，然后，再次输入 Harry；输入 Gryffindor，回车，Harry 确实来自 Gryffindor。如果我做了不正确的事情，比如 Harry 来自 Number Four, Privet Drive，回车，我们将再次看到 `ValueError`，因为我的代码现在既不允许通过手动输入也不允许通过那种对抗性的更改让那个值进入。

好的，这信息量很大。但是关于属性有什么问题吗？

**问：** 为什么我们先用 getter 再用 setter？这只是为了我们能在代码中找到那个方法，那个函数吗？
**答：** 我费力定义这个 getter 或 setter 的原因是因为我想确保程序员不能做像这样的事情。如果我费力去验证这些 `student` 对象的属性，我不希望你能够进去随意更改它们。我想对那个对象有一些控制，这样你就可以相信它会按照设计的那样是正确的。所以使用 getter 和 setter 实际上只是让 Python 能够自动检测到你何时试图手动设置一个值。等号和点，正如我在这里高亮的，足以让 Python 意识到，等一下，你试图设置一个值。让我看看这个类是否定义了一个 setter。如果是这样，我将调用那个，我不会盲目地将值从右到左赋值。所以它只是给了我更多的控制。关于属性的其他问题。

**问：** 当我们使用 getter 时，我们只有一个参数。而如果我们使用 setter，它总是会有两个参数？这是正常的吗？
**答：** 正确。getter 总是会有一个参数——`self`，setter 会有两个参数——`self` 和其他东西。对此的直觉是，如果你正在获取一个值，你不需要传入任何其他东西，因为你已经知道对象了。在这种情况下它叫做 `student`。所以你只是获取那个属性的值。但是如果你想将属性设置为其他东西，你必须传入那个参数。你必须传入你想要设置的值。所以它总是 0 或 1。然而，你看到的是 1 或 2，因为，再次强调，类内部的任何函数，也就是方法，都会被自动传递 `self`，这样你就可以访问内存中的当前对象。关于属性的另一个问题怎么样？

**问：** 为什么我们不在 `init` 方法中使用同样的 `_house`？
**答：** 好问题。所以即使我在这里，在我的 setter 中，使用 `_house`，在这里，在我的 getter 中，使用 `_house`，我故意没有在这里使用它。原因在于，通过使用 `self.house` 和这个等号，这是我希望 Python 识别的相同模式。我希望 Python 自动调用 setter，即使我是通过 `init` 方法传入 `house` 的。如果我将其更改为这样做，那将绕过 setter，现在 `init` 中就没有任何错误检查了。所以这是一条非常细微的界线。我们与错误检查或没有错误检查之间唯一的区别就是这个下划线的存在与否。但这通常是惯例。通过在那里不使用下划线，确保即使那个赋值也通过 setter 进行，这样，老实说，我就不必在两个地方复制粘贴相同的错误检查。我可以只把它放在 setter 里。所以这是一个更好的设计，这就是为什么我一开始手动重新输入了它，但后来我从 `init` 中删除了它。

好吧，请允许我建议我们对这个文件做另一个更改。不妨也为 `name` 定义一个属性。让我这样做——也许在 `house` 属性之上，只是为了保持与我之前定义它们的顺序相同。让我给自己另一个属性。这个将被称为 `name`。它将像往常一样接受一个名为 `self` 的参数。这个，非常类似地，将只返回 `self._name`。所以我将预料到我将不得不重命名 `name`，这样我就不会有和以前一样的冲突了。

但现在让我继续定义另一个 setter——这次是为 `name`。所以惯例是 `@name.setter`。为什么是 `name`？因为我刚刚创建的属性叫做 `name`。所以 getter 和 setter 以这种方式协同工作，如果你愿意的话。让我到那个 `name` setter 下面，定义另一个函数，也叫做 `name`。但这里的关键是它并不完全相同。它不是完全相同的函数名和完全相同的参数数量。setter，再次强调，接受第二个参数。我可以叫它任何我想要的名字，但我将叫它 `name`，因为那是传入的东西。我将把我的错误检查放在这里。`if not name`，就像我们过去常做的那样，让我们引发一个 `ValueError`，让我们放一个解释性的消息，比如 "Missing name"，引号里的。否则，让我们继续更新 `self._name` 等于 `name`。

我不需要更改 `init`，除非是为了去掉现在这个重复的错误检查，因为，再次强调，如果我在这里使用 `self.name = ...` 并且在这里使用 `self.house = ...`，没有下划线，这两个赋值都将通过我的两个 setter 函数进行。

在我们运行这个之前，让我去掉这个对抗性的代码，我们知道它不会工作，因为我们正在捕获它。让我回到我的终端窗口并运行 `python student.py`，回车。让我们输入 Harry。让我们输入 Gryffindor。这似乎有效。不过，让我们再试一次，运行 `python student.py`，输入 Harry 来自 Number Four, Privet Drive。这将不起作用。一个带有 "Invalid house" 的 `ValueError`，因为那不是四个霍格沃茨学院之一。现在，为了确保起见，让我们再运行一次。让我们甚至不给它一个名字。让我们在提示时只按回车键。我可以为学院输入任何东西。我还是给它 Gryffindor，回车。现在我们得到了另一个 `ValueError`，但这次是针对 "Missing name"。

所以我们现在似乎有了一个更强大的防御机制来确保 `name` 如我们所期望的那样。它必须有一个非空的值。并且 `house` 如我们所期望的那样。它必须是那四个值之一。

但冒着打破大家幻想的风险，让你想知道，我们为什么要经历所有这些，不幸的是，Python 真正关注的是约定，而不是硬性约束。我的意思是这个。如果我回到我的 `main` 函数，在我第 30 行获取了一个 `student` 之后，我试图对抗性地做类似这样的事情——`student.house = "Number Four, Privet Drive"`，我们知道这不会工作，因为我的 `house` 的 setter 会捕获这个。再看一次。`python student.py`。让我们输入 Harry。让我们输入 Gryffindor，这至少会通过由 `init` 引起的我们的检查。但是第 31 行将触发同一个 setter 被调用，我们将引发一个 `ValueError` 说 "Invalid house"。

不幸的是，如果你们中有些人已经在对抗性地思考了，悲剧的是，看看你能做什么。你可以将 `.house` 改为 `._house`。为什么？嗯，实例变量现在叫做 `_house`。属性叫做 `house`，没有下划线。但是作为实例变量实现的底层属性仍然叫做 `_house`。悲剧的是，`python student.py`。让我们输入 Harry。让我们输入 Gryffindor，这是正确的。但是看现在发生了什么。哦，我的天。我们溜过去了。

那么，我强调以“正确的方式”，Python 的快速方式，通过拥有这个 getter 和 setter 来做事情的重点是什么呢？嗯，不像 Java 这样的语言，它们就是阻止你做这样的事情，Python 本身允许你指定某些实例变量可以是公共的（public），任何人都可以访问，或者是受保护的（protected），或者是私有的（private），这意味着没有其他人应该能够更改这些值。在 Python 的世界里，这只是荣誉系统。语言本身并没有内置可见性的概念，公共的或私有的，甚至介于两者之间的受保护的。相反，你是在荣誉系统上。一般的惯例是，如果一个实例变量以下划线开头，请不要碰它。就是不要。如果你碰了那个变量并破坏了东西，那是你的责任。下划线旨在表示一个约定，即这应该是“私有的”，但这实际上只是意味着，请不要碰这个。有时，如果有两个下划线，你也可以使用，那是程序员更大的努力表示，真的不要碰这个。但技术上讲，没有什么能阻止你或我绕过所有这些机制，这些属性，这些 getter 和 setter。我们最终只是在荣誉系统上，当我们看到以一个，或者甚至两个下划线为前缀的实例变量时，不要这样做。

## 七、 内置类型也是类 (Built-in Types as Classes)

好的，所以这一下子信息量很大——这个面向对象编程的介绍。但这可能会让人非常惊讶，即使我们可能在过去的几周里按名称识别了 OOP，我们所有人在这门课中已经使用类和对象好几周了。

事实上，如果你回想一下我们在这门课中做的最早的事情之一，我们使用了整数并从用户那里获取了整数。但是如果你还没有——如果你去深入研究整数的文档，再次强调，它位于这个 URL 这里，你实际上会发现 `int` 本身在几周内一直是并且现在也是一个类。事实上，这是 `int` 的构造器调用的签名，你传入像数字这样的 x，引号里的 "50" 或者，引号里的其他东西——你可选地传入基数——10 代表十进制，2 代表二进制或其他。那个 `int` 函数实际上一直以来都返回给你一个 `int` 类型的对象。也就是说 `int` 是一个类。它是一个模板，一个用于在内存中创建整数的蓝图。任何时候你我都将一个字符串，例如，转换为一个 `int`，你我都在创建一个 `int` 类型的对象，它显然调用了 `__init__` 方法，这是其他人——Python 的作者们——写的，用来给我们返回那个合适的整数。

除此之外，如果你能相信的话，Python 中的字符串 `str` 从这门课的第一周开始也一直是类。如果你查找 `str` 的文档，它位于那里一个类似的 URL，你会发现，当你实例化——也就是创建——一个 `str` 时，它可选地接受一个名为 `object` 的参数，其默认值只是引号里的空字符串 `""`，这允许你，实际上，创建一个空字符串，一个空白字符串，如果你愿意的话。但是任何时候你我都创建了 `str` 或者甚至明确地使用了 `str` 函数，你都在得到一个 `str` 类型的对象。任何时候你我都强制一个字符串变为小写，根据文档，使用像这样的语法，你我都在获取一个 `str` 类型的对象，并通过调用一个名为 `lower` 的方法将其全部强制为小写，这是 Python 作者们内置到 `str` 类中的一个方法，但它从一开始就存在，所以方法的概念甚至在今天也不是新的。你不会一直这样做。如果你曾经调用 `strip` 来移除 Python 字符串开头和结尾的空白，你正在调用另一个 Python 自带的方法——由 Python 的作者们编写。即使我们当时没有称它为类，`str`，一直以来，都是一个类。字符串的实例本身就是对象。因此那些对象带有这些内置的函数——也就是方法，允许我们做像强制转为小写和从开头和结尾剥离空白这样的事情。

让我们再做一个。`list`——任何时候你创建了一个列表，无论是语法上用方括号，还是字面上用 `L-I-S-T`，开括号，闭括号，这也是可能的，你都在使用一个类。如果你去查看 `list` 的文档，在这个类似的 URL 这里，或者更具体地说，Python 中关于列表的教程这里，你会看到 `list` 自从这门课的早期几周以来，一直并且现在也是一个类本身。那个 `list` 类，作为其初始化的一部分，接受一个可选的可迭代对象（iterable），某种可以被迭代的东西——比如 1, 2, 3，或者一些值的列表，然后你可以得到一个包含那些相同的可迭代值的列表。如果你曾经在这门课中向一个列表追加（append）过东西，就像我自己在过去做过的那样，你一直在使用一个名为 `append` 的方法，它来自 `list` 类，根据这里的 `x`，它接受一个参数，允许你向当前列表追加某物，也就是在那个方法的上下文中是 `self`。

我们可以整天这样做。如果你在 Python 中使用过字典或 `dict`——我实际上，一直以来，都称它们为 `dict` 对象，这是有原因的。`dict` 本身在 Python 中是一个类，如果你调出它的官方文档这里。你会看到它确实被定义为它本身就是一个类。那个类也带有方法。所以任何时候我们操作字典，我们都是在底层，使用所有那些相同的方法。

事实上，如果我们真的好奇，我们可以看到这一点。让我回到 VS Code 这里。让我创建一个新文件，非常简单地做一些玩弄数据类型的事情。让我创建一个新文件，例如，叫做，比如说，`type.py`，只是为了我能探查一些值内部。在 `type.py` 中，我将只做这个。我将打印出，比如说，数字 50 的类型是什么。这是一个你未必见过我用过的函数，而且它也不是你经常会在自己的代码中使用的函数。如果你需要检测一个变量的类型，还有其他方法。但在这种情况下，`type(50)` 只是告诉我然后打印出那个值的数据类型是什么。现在，希望我们所有人都能猜到 50 确实会是一个整数——也就是一个 `int`，但我们可以用这种方式看到它。这也正是了解一点编程的强大之处。如果你想知道一个问题的答案，就像我在这里一样，试一试就行了。

所以让我运行 `python type.py`，回车。就在那里。当你打印出数字 50 的类型时，你会在屏幕上看到，以这种神秘的语法，`class 'int'`。这可能不是你想展示给用户的东西。但如果你自己只是想探查一下，看看发生了什么，或者也许以某种方式使用那些信息，你当然可以使用这个 `type` 函数来达到这个目的。

让我们稍微改变一下。不将 50 作为 `int` 传递给 `type` 作为参数，让我们输入一些我们同样熟悉的东西，比如 `"hello, world"`，用双引号或单引号。让我回到我的终端窗口，清空屏幕，然后再次运行 `python type.py`。现在，瞧，就在那里。一直以来，`str` 也是一个类。

我们可以再做几次。例如。让我们把 `"hello, world"` 改成只是一个空列表——开方括号，闭方括号。这开始看起来有点神秘了，但是，再次注意我在做什么。方括号里是一个空列表。我们以前做过。那是这个新 `type` 函数的唯一参数。它只是被传递给 `print` 函数，这样 `type` 的返回值就是 `print` 的参数。所以如果我现在运行这段代码，`python type.py`，就在那里。`list` 也是一个类。

你可能记得我说过你也可以通过字面上做 `list()` 来创建一个空列表。这有点不一致，因为我们现在可以识别出 `int` 和 `str` 以及现在的 `list`——它们技术上都是小写的。而我费了很大劲创建我的 `Student` 类使其具有大写 S。这是一个约定。因为 `int`、`str`、`list` 等是 Python 自带的，他们决定让他们的内置数据类型——即使它们是类——全部小写。但是约定，Python 社区在创建你的类时的建议是首字母大写，就像我在像 `Student`（大写 S）这样的东西里做的那样。但是 `list()` 实际上与仅仅两个空方括号是相同的。如果我清空我的屏幕并再次运行 `type.py`，你会看到完全相同的东西。这个类叫做 `list`。

让我们再做一个。让我把列表改成不是方括号而是花括号。我们以前做过这个。任何时候我做了两个中间没有任何东西的花括号，这当然是一个空字典，或者 Python 中的 `dict` 对象。嗯，我们现在可以看到。让我清空我的屏幕，运行 `python type.py`，回车，就在那里——`class 'dict'`。它一直都在那里。我们只是直到今天才称它为类。我同样可以明确地这样做。不用两个花括号，让我们写出 `dict` 带两个圆括号。现在我们又有很多圆括号了，就像 `list` 一样。但这只是更清楚地表明 `dict` 对象的类型确实是类 `dict` 本身。

所以这是想说，尽管今天的很多想法和语法可能很新，你实际上可能在不知不觉中已经使用了好几周了。我们现在只是有了术语来描述我们一直以来在做什么。你现在有了表达能力，通过一些练习，可以创建你自己的类，在其中有你自己的实例变量，也许用那些属性包裹起来，还有你自己的实例方法。

## 八、 高级类特性

但事实证明，世界上还有其他类型的方法。到目前为止，我一直故意称我们所有的变量为实例变量（instance variables），我们所有的方法为实例方法（instance methods）。事实证明，还有其他类型的变量和方法存在，其中之一叫做类方法（class methods）。

事实证明，有时候将一个函数与类的对象关联起来并不是真正必要或明智的，而是与类本身关联。一个类的实例或对象是它的一个非常具体的化身。再说一次，在那个有很多看起来相同的建筑的社区里，但它们都因为不同的油漆等而有点不同，有时候你可能有一些与那些房子相关的功能，但对于任何房子来说都不是独特的或唯一的。这是无论涉及哪个房子都完全相同的功能。面向对象编程的世界里也是一样。有时候你想要一些功能，一些动作与类本身相关联，而不管具体对象的自身值或实例变量是什么。为此，我们有一个叫做 `@classmethod` 的关键字。这是另一个装饰器——实际上是另一个函数——你可以用它来指定这个方法不是，默认情况下，隐式地是一个可以访问 `self`（对象本身）的实例方法。这是一个类方法，它不能访问 `self`，但它确实知道它在哪个类里面。

那么这是什么意思呢？好吧，让我回到 VS Code 这里。让我建议我们这次创建一个新文件，实现哈利波特世界里的——同样为了保持主题——分院帽（sorting hat）的概念。我将运行 `code hat.py`。在 `hat.py` 中，让我们实现分院帽的概念。如果不熟悉，在书和电影中，确实有一个尖顶帽子，当学生把它戴在头上时，那个分院帽，可以说，决定学生应该在哪个学院——是格兰芬多还是其他。所以让我们在代码中实现这个分院帽的概念，这样，当我们向分院帽传递一个学生的名字时，比如，引号里的，“Harry”，这个用代码实现的分院帽将告诉我们那个学生应该在哪个学院。

好吧，让我们这样做。在 `hat.py` 中，首先，让我们定义一个名为 `Hat` 的类，然后让我们回到实现它本身。我发现这是一个有用的技术，不仅在教学时，也在编写代码时。我知道我想要一个 `Hat` 类。我还不一定知道我希望它做什么，所以我将创建这个占位符，点点点 `...`，所以我稍后会回到那里。现在让我们尝试使用这个类，就好像它存在一样。从那里，我或许能意识到那个类究竟需要什么功能来支持我的用例。

让我创建一个全小写的名为 `hat` 的变量，并实例化一个 `Hat` 对象。所以不管 `Hat` 类最终看起来像什么，这是实例化某个类的对象的通用语法。过去，我们看到 `student` 全小写，等于大写 `Student`，开括号，闭括号，然后最终我们加入了像 `name` 和 `house` 这样的东西。现在，让我们假设帽子比学生简单得多，它只有分院的能力。所以我甚至不打算在那里传递任何参数。

让我假设分院帽有一个函数——一个方法在里面，叫做 `sort`。所以如果我做 `hat.sort("Harry")`，让我们假设那会打印出那个学生应该在哪个学院。就这样。我将封装——也就是把所有这些必要的功能塞进一个 `Hat` 类里——然后我将在屏幕上打印出帽子——Harry 属于哪个学院。

现在我想我需要深入到实际初始化这个类的细节中去。好吧，让我这样做。如果我不关心参数化 `Hat`——我只想，例如，排序值，让我们先定义这个 `sort` 函数。所以让我们定义 `sort`，接受第一个参数 `self`，这在定义像以前一样的实例方法时总是如此。但是 `sort` 方法显然从程序员我这里接受一个参数——即学生的名字。我们之前见过这种二分法。即使我试图传入一个参数，当我定义方法时，它必须接受那么多参数，再加一个——`self`，它总是会被 Python 自动首先传入。

我想做什么？好吧，让我们做类似这样的事情。打印，这个名字——比如说 `"is in"`，`"some house"`。我将再次使用一些占位符代码，因为我不太确定如何完成实现这个分院帽。但我认为这足以测试我的代码现在处于什么状态。让我运行 `python hat.py` 并按回车。看起来，确实，Harry is in some house。我们还没完成，因为它显然没有做任何有趣的事情，但它至少正确运行了，没有错误。

好吧，让我们现在决定——Harry 实际上应该在哪个学院，通过引入一点随机性并随机选择一个学院。虽然我可以用几种方式来做，让我这样做。我需要在某个地方有一个学院列表。那么我可以把它放在哪里？我可以用不同的方式解决这个问题。让我建议我这样做。让我定义一个名为 `init` 的方法，就像我之前做的那样，它接受 `self`，但没有其他参数。每当分院帽被实例化时，让我们这样做。让我们创建一个名为 `houses` 的实例变量（复数），它等于这个列表——Gryffindor, Hufflepuff, Ravenclaw, Slytherin。就是我们之前用过的完全相同的列表，我将它存储在这个类内部的一个实例变量中。我没有向 `init` 传递除 `self` 之外的任何参数，但我只是需要这个值的列表在某个地方，例如。

那么我在这里能做什么呢？好吧，让我把 "some house" 替换成实际的学院。那么我在这里能做什么呢？嗯，我想在那里放一个学院。好吧，让我们创建一个名为 `house` 的变量。如果你回想一下我们关于库的讨论，在 `random` 模块中，有一个名为 `choice` 的函数，如果你传入一个选项列表，比如 `self.houses`，它将从那四个中随机选择一个学院。然后在第 7 行，我可以将其传入。如果我想精简它，让我只高亮那段代码，去掉变量。它技术上是不必要的。因为这行代码仍然很短，我可以在一行内完成所有事情。但我当然可以像我刚才那样使用变量。

那么我做了什么？在我的 `init` 函数中，我定义了对象的初始化，它在 `self.houses` 中存储了四个学院的列表。然后，在 `sort` 中，我访问同一个列表，但我随机选择那里的学院集合。

现在，我为什么以这种方式做呢？这也是通用的约定。任何时候你有一个事物的列表，它们——谁知道呢？也许会随着时间的推移而改变。像哈佛这样的地方多年来建造了新的学院，所以你可能不得不更改可用学院的列表。这在哈利波特的七本书或八部电影中没有发生。但你可以想象也许霍格沃茨最终会有第五个学院，所以在文件顶部、类的顶部放置常量列表通常是有价值的，这样值的列表就很明显了。你不想必然地把它藏在像 `sort` 这样的某个函数里，特别是如果你可能想在多个函数中使用那个函数——抱歉，特别是如果你想在多个函数中使用那个列表，而不仅仅是 `sort`。但如果我继续向这个类添加东西，你可能想在多个函数中使用同一个学院列表。所以让我们通过将其存储在 `self.houses` 中来将其保留在对象本身中。

好的，好吧，我们即将在这里改变历史的进程。让我执行 `python hat.py`，我想我们即将随机地将 Harry 分配到那四个学院之一。嗯，`NameError`。名字 'random' 没有定义。嗯，等一下，我哪里出错了？回想一下我们关于库的课程，为什么我的代码坏了，没有告诉我 Harry 应该去哪里？

**问：** 你没有导入 random 库。
**答：** 完全正确。如果 `random` 库或模块是我想要使用的东西，我需要在我的文件顶部告诉 Python。所以让我到上面做 `import random`。然后，在下面，让我清空我的终端窗口并重试。`python hat.py`，交叉手指，看看 Harry 会去哪里。好的，截至目前，Harry 正式进入了赫奇帕奇，尽管你读过或看到过的一切。好吧，让我们再运行一次。让我清空我的窗口并运行 `python hat.py`，现在他在拉文克劳。这与使用 `random` 是一致的。让我们清空它再运行一次。他还在拉文克劳，但这可能发生，即使有四个选择。让我们再做一次。赫奇帕奇——回到了赫奇帕奇。我们似乎得不到正确的答案。现在他在格兰芬多，尽管是随机的。所以我们似乎有一个程序，基于这些有限的测试，似乎正在随机地将 Harry 分配到一个学院。

现在我有点懒惰地让 `sort` 打印出这个值。我可以做其他事情，比如返回一个字符串，然后让我在第 13 行替我做打印。但就目前而言，我认为我们有一个名为 `Hat` 的类的例子，它仍然应用了我们今天到目前为止学到的一些经验，我创建了一个类——因为分院帽，坦率地说——嗯，我正要说是现实世界的实体，但实际上是幻想世界的实体。确实，这可能是一个常见的启发式或心智模型。你什么时候应该使用一个类来表示你的代码中的某物？通常，当你试图表示某个现实世界的实体或幻想世界的实体时，比如学生，这是现实世界中的东西，比如分院帽，好吧，它不存在，但帽子肯定存在，所以为帽子创建一个类是相当合理的。情况并非总是如此，类总是代表现实世界的实体。但我们到目前为止已经看到 `int`、`str`、`list` 和 `dict`——这些都是你可能在现实世界中拥有的结构。我们有整数和文本字符串以及其他东西。所以用类来更技术性地表示那些东西也是相当有意义的。你可以只用一个字典来表示一个学生或一顶帽子。但是再次强调，有了类，就会有所有这些以及更多的功能。

但我老实说，在这里并没有真正以“正确的方式”使用类。为什么？嗯，在哈利波特的世界里，据我所知，真的只有一个分院帽。然而，在这里，我已经实现了一个名为 `Hat` 的类。再说一次，类就像一个蓝图，一个模板，一个模具，允许你创建它的一个或多个对象。现在，到目前为止，我的大多数程序都相当简单，我只创建了一个学生。但当然，如果我花更多时间编写更多代码，你可以想象编写一个程序，它有一个学生列表——比我们一直演示的那个多得多的学生。然而，实例化一个、两个、三个或更多的分院帽会有点奇怪——这与哈利波特的现实或幻想世界有点不一致。真的只有一个。真的只有一个单例（singleton），如果你愿意的话，这在很多编程上下文中是一个术语。

所以让我建议我们实际改进分院帽的设计，这样我们就不必实例化一个分院帽了，因为现在这有点像允许我做 `hat1 = Hat()`, `hat2 = Hat()`, `hat3 = Hat()`, 等等。我并不真的需要那个能力。我真的只需要用一个类来代表分院帽，但我并不真的需要实例化它。为什么？因为它已经存在了。我只需要一个。

所以事实证明，在 Python 中，到目前为止，我们一直在使用，正如我一直称呼它们的，实例方法——在类内部编写函数，这些函数会自动被传递一个对 `self`（当前对象）的引用。但有时候你就是不需要那个。有时候只知道类是什么就足够了，并假设甚至可能没有任何该类的对象。所以在这种意义上，你可以真正地将一个类用作数据和/或功能的容器，这些数据和/或功能只是在概念上以某种方式相关——与分院帽相关的东西。还有这个其他的装饰器或函数叫做 `@classmethod`，它允许我们做到这一点。

所以让我回到我的代码这里。让我建议，如果我不打算实例化多个学院（注：此处应为帽子），我并不真的需要这个 `init` 方法，因为那真的是用来从那个蓝图、那个模板、那个模具初始化特定对象的。所以让我去掉这个。但如果我去掉这个，我就无法再访问 `self` 了。但这没关系，因为事实证明，除了存在的类方法之外，还有我们可能称之为类变量（class variables）的东西。类变量存在于类本身内部。对于它的所有对象来说，那个变量只有一个副本。它们都共享，如果你愿意的话，同一个变量——无论是 `int`、`str`，还是，在这种情况下，一个列表。

所以我在这里做的是在我的 `Hat` 类内部定义了一个名为 `houses` 的类变量——我没有说 `self`，因为 `self` 不再相关了。`self` 指的是特定的对象。我想要这个类内部的一个变量，也就是一个类变量，它等于那个列表。因为它现在在这个 `Hat` 类内部，我可以在我的任何函数中使用那个列表。我现在只有一个叫做 `sort` 的函数。但如果我添加更多，它也将对所有那些方法可用。

对于 `sort`，在一个特定的分院帽内进行排序也没有真正的意义，因为，再次强调，我只希望有一个。所以我实际上可以通过说 `@classmethod` 来指定这是一个类方法。我不再传入 `self` 了。我实际上，按照惯例，传入一个对类本身的引用。它通常写成 `cls`。为什么？嗯，如果你写 `C-L-A-S-S`，那实际上会与我们一直在这里使用的关键字 `class` 冲突。所以世界意识到，哎呀，我们不能在这里重用同一个短语。所以让我们就叫这个 `cls` 吧。

这在某些上下文中很有用，包括这个。为什么？嗯，注意我现在能做什么。我现在可以将 `self` 改为只是 `cls`。为什么？因为 `houses` 现在——不是一个可以通过 `self.houses` 访问的实例变量。它现在是一个类变量，可以通过 `cls.houses` 访问，或者技术上在这种情况下是 `cls.houses`。

但现在最后的点睛之笔是这个。现在，我不必像我以前在第 13 行那样实例化任何 `Hat` 对象了。我可以只使用这个类自带的功能。所以我将完全删除那一行。我将在这个新的第 13 行将 `Hat` 大写，然后只说 `Hat.sort("Harry")`。

那么我做了什么？我没有费心去实例化一个 `Hat` 类型的对象。我只是在访问 `Hat` 类内部的一个类方法，它——你知道吗？就是能工作。这就是类方法的工作方式。你使用类的名称，包括大写字母，点号，方法名，传入你想要的任何参数。Python 会自动传入某个变量，通过它你可以在你类内部实现的那个函数中引用那个类，这样我就可以做类似这样的事情。不是说我想要一个在这个函数本地名为 `houses` 的变量，我想要与当前类关联的名为 `houses` 的变量，这样我仍然可以访问我在第 6 行定义的同一个列表。

现在，如果我回到这里的终端并运行 `python hat.py`，回车，Harry 再次进入了赫奇帕奇。Harry 再次进入了赫奇帕奇。Harry 回到了格兰芬多，至少是随机的。

现在关于这些类变量或这些类方法，有什么问题吗？它们与实例变量和实例方法形成对比。至少，有点奇怪的一件事是，即使有一个叫做 `@classmethod` 的装饰器，却没有一个叫做 `@instancemethod` 的。当你定义一个没有任何装饰器的方法时，它就自动是一个所谓的“实例方法”。

**问：** 你可以在一个类里面再定义一个类吗？
**答：** 可以。你可以在一个类内部定义另一个类。一般来说，这不常做，但在某些情况下它可能很有用，特别是对于更大、更复杂的程序。所以是的，这是可能的。其他问题。

**问：** 问题是关于 `self.houses` 的。当我们移除它并传递数据时，变量是自己创建的，这就是我们移除 `self` 的原因吗？
**答：** 所以在之前的例子中——无论是 `Hat` 的演示还是所有 `Student` 的演示——我们都是通过调用 `Student`（大写 S），开括号，闭括号，最终传入 `name` 和 `house` 来创建一个 `student` 对象。然后我们使用 `__init__` 方法来初始化其中的 `self.name` 和 `self.house` 实例变量为相应的值。在这个最新版本的分院帽中，我根本没有使用 `self`，只是因为，从概念上讲，我不需要也不希望世界上有多个帽子。我只是把类作为一个容器来捆绑这个学院列表，这个排序功能。也许最终我会给它添加更多的功能。但仅此而已。所以有时候你可以用这种稍微不同的方式使用面向对象编程，当你想要有功能但它不特定于任何一个特定的帽子时。它特定于分院帽本身。最后一个关于这些类变量或方法的问题怎么样——这只是使用面向对象编程的另一种方式，但解决的是一个稍微不同的问题？

**问：** `Hat` 类和 `Hat` 函数有什么区别？
**答：** 好问题。那么我们为什么要用一个类而不是仅仅有一个名为 `hat.py` 的文件，里面有一个名为 `houses` 的变量和一个名为 `sort` 的函数呢？我们为什么要增加这种复杂性？在这个特定的例子中，我们不一定需要。我绝对可以进入这里。我可以去掉类。我可以撤销这个缩进。我可以去掉这个装饰器。我可以去掉 `Hat.`。我可以只做这个，另外，比如说，让我们去掉这里的 `cls`。让我们去掉这里的 `cls`。现在运行 `python hat.py`，回车，它仍然有效。把 Harry 放在了错误的学院，但这就是随机发生的情况。那也没关系。

我们今天通过面向对象编程引入的，只是对世界建模的一种不同方式。对于像这样一个相对简单的例子，坦率地说，它并不是很吸引人。它不是很复杂。没有太多的功能。老实说，我们刚才输入的版本——这 10 行——这样就可以了。这解决了这个问题。但是当我们的代码变得更长，当我们开始与其他人合作，当我们试图用代码解决的问题变得更复杂时，你会发现你的代码很快就会变得混乱。你会发现，例如，一个文件中有大量的函数。其中一些是相互关联的，但有些则不是。那么，在那个时候，只是以稍微不同的方式组织它们岂不是很好？在哈利波特的世界里，让我们为学生创建一个类；让我们为教授创建一个类；让我们为分院帽创建一个类；让我们为其他东西创建一个类。所以一旦你的世界变得比我们在这里课堂上做的一些演示复杂得多，当我们想要专注于单个想法时，面向对象编程只是一种封装相关数据——即变量——相关功能——即方法——到有名称的事物内部的方式。这些事物被称为类。

所以这只是解决问题的另一种方式。当我们几周前回顾库的时候，那也是解决同样问题的另一种方案。你可以定义你自己的模块或包，把你的一些数据和/或功能放进去，那也没关系。有时候你应该使用哪一个会重叠。如果你熟悉维恩图，重叠区域可能意味着你可以使用一个类；你可以使用一个模块或一个包；你可以只使用一个本地文件。随着时间的推移，你会培养出一种直觉，甚至可能是一种个人偏好，选择使用哪种工具。

好的，让我现在建议，我们也应用这个类方法的相同想法来清理另一件事。让我关闭 `hat.py` 并重新打开我们之前留下的 `student.py`，让我稍微简化它一点。我将去掉属性，不是因为它们有任何问题，只是因为我希望我们专注于我们开始这个程序时的一些关键思想。所以我将保留 `main`。我不会对抗性地尝试更改 Henry（应为Harry）在那里的地址。我将改为只打印 `student`。

但这是我想关注的事情。这，在我们之前的 `student` 例子中，是一个清理我的代码的错失良机。那么，我这是什么意思呢？嗯，在这个文件的顶部——即使我已经通过去掉属性和所有那些错误检查简化了它——因为我想现在专注于这个类的本质——只是学生的名字和学院以及它们的打印。这，根据类和面向对象编程的性质，理论上，应该是我所有特定于学生的功能。也就是说，如果我有与学生相关的功能和数据，你，程序员，我的同事，会假设它都捆绑、封装，可以说，在 `Student` 类内部。然而，如果你向下滚动，这是什么？有一个名为 `get_student` 的函数，它只是存在于这个文件的其他地方，它提示用户输入名字，提示用户输入学院，创建 `student` 对象，然后返回。

那没有错。它能工作。我们看到很多很多次它都持续工作。但这有点奇怪，因为，如果这是一个帮助你获取学生的函数，帮助你获取学生的名字和学生的学院，为什么那个功能不在类本身内部呢？毕竟，随着我的代码变得越来越复杂并做更多的事情，我将会查看 `Student` 类以获取所有与学生相关的功能。我不会向下滚动，期望，哦，也许在这个文件的后面某个随机的地方还有一些其他的学生功能。所以这没有错。但这又是可能设计不良的证据——对于这个小程序来说可能不那么严重。但这又是一个代码异味（code smell）的例子。这里有些东西闻起来有点不对劲。通过分离相关功能，这可能会让我们陷入麻烦。所以再次强调，这是一个设计原则，而不是正确性问题。

但是类方法允许我们也解决这个问题。让我这样做。我将完全删除 `get_student`，只留下 `main` 作为我这里的另一个函数。在我的 `Student` 类内部，我将这样做。我将定义一个更简单地叫做 `get` 的函数。根据类方法的工作方式，它将接受类本身的名称或对其的引用作为参数。我将把 `get_student` 的功能移到 `Student` 类中。我将这样做——`name = input("Name")`，`house = input("House")`。然后这个函数要做的是通过调用 `cls`（再次强调，这只是一个自动传入的对类本身的引用），传入 `name` 和 `house`，来返回一个新的 `student` 对象。我承认这个语法看起来有点奇怪，我现在调用 `cls` 并且我传入这些参数。

但让我做最后一个修正。让我到这个函数的顶部，更明确地说这是一个类方法。这解决了一个潜在的先有鸡还是先有蛋的问题，可以说，即一个必须在另一个之前出现，潜在地。

那么我在这里做什么呢？在我的 `Student` 类内部，我现在有一个名为 `get` 的函数。我将声称，它是一个类方法。这是什么意思？这只是意味着我可以调用这个方法而无需先实例化一个 `student` 对象。这其中就存在潜在的先有鸡还是先有蛋的问题。如果不熟悉，那是一种表达，意思是，嗯，世界上是先有鸡然后下蛋，还是先有蛋然后孵出鸡，但蛋是怎么来的？这是一个奇怪的循环问题。这就是我们在这里面临的。如果你必须创建一个 `student` 对象才能调用 `get`，以便获取另一个 `student` 对象，那会很奇怪。那听起来很麻烦。

让我们只通过一个类方法来获取一个学生，根据定义，它不需要你先创建 `student` 对象。就像帽子，在其最终形式中，我们使用 `Hat` 类只是说 `Hat`（大写 H），点号，`sort`。我们不需要先创建一个帽子。我们只是使用了类本身。

那么我现在要做什么呢？让我回到 `main`。不用说 `get_student`，注意我现在能做什么。`Student.get`，其他一切都可以保持不变。

我现在所做的只是将我所有的逻辑从 `get_student`（它是一个独立的函数，但通过名字明显与学生相关）迁移了。我将相同的代码，实际上，移到了 `Student` 类内部一个更简单命名的函数 `get` 中。但如果我愿意，我仍然可以叫它 `get_student`。只是在 `Student` 类中叫它 `get_student` 似乎有点多余，所以我正在简化。所以我有一个名为 `get` 的方法，但我称它为类方法以避免那个先有鸡还是先有蛋的问题。我想能够在我的宇宙中还没有 `student` 对象的情况下调用 `get`。这样做的语法是 `@classmethod`。惯例是给这个方法至少一个参数，按照惯例称为 `cls` 代表类，它只是对类本身的一个引用。第 11 和 12 行与它们一直以来的样子相同。`get_student`——这里唯一的新语法是这个，但这，再次强调，是面向对象编程的特性之一。你现在可以通过只使用传入的 `cls` 来实例化一个 `student` 对象。我技术上可以使用 `Student`（大写 S），但事实证明我正在做更常规的事情，因为这既能解决问题，也能避免将来更复杂代码的问题。这一行，在第 13 行，只是意味着创建当前类的一个对象。那个类是什么？嗯，无论 `cls` 是什么。嗯，根据它全部工作原理的定义，那将是 `Student`。我希望你像往常一样用 `name` 和 `house` 来初始化它。

所以现在，向下滚动，我的代码是这样的。这读起来很舒服。你可能需要培养对这个的品味——我说“这读起来很舒服”听起来有点奇怪。但确实，`Student.get` 就告诉我发生了什么。我将得到一个学生。我不需要我自己写的、在文件本身中的一个名为 `get_student` 的独立函数。`get` 功能是内置在类中的。我现在所有与学生相关的代码都在一起了。

所以让我到我的终端窗口运行 `python student.py`，回车。让我们输入 Harry。让我们输入 Gryffindor。我们又回到了我们开始的地方。但是，但是，但是，现在所有与学生相关的东西都在这个类里面了。文件中唯一其他的东西是 `main` 和我们总是用来避免在制作模块或包等时意外执行 `main` 的条件语句。

所以再次强调，一个问题的解决方案——对于一个相对较小的程序来说不是一个大问题，但是当你最终遇到程序变得越来越长，有越来越多的实体需要表示时，你会遇到的问题。

现在关于这个类方法的使用有什么问题吗？

**问（Michael）：** 类必须在 `main` 函数之前定义吗，就程序的顺序而言？
**答：** 一个非常好的问题。所以当有疑问时，让我们试试这个。让我们尝试改变顺序。让我们把 `main` 移到顶部，这是我经常鼓励的。所以让我们，在类之上，这样做。现在注意，技术上，第 2 行提到了 `student`，它直到第 6 行及以下才存在。让我清空我的终端并运行 `python student.py`。到目前为止，一切顺利。Harry——Gryffindor，好的。确实，Harry 来自 Gryffindor。Michael，在这种情况下顺序无关紧要的原因是因为我们实际上直到最后才调用 `main`。就像过去一样，这意味着 Python 有机会从上到下、从左到右地读取所有内容。所以一切都存在。我想说，通常类是在文件顶部定义的。然而，将类的定义移到它自己的文件中然后导入它可能会更清晰，所以本质上是通过将其放入你自己的模块或包中来制作可重用代码，这样不仅这个程序，许多其他程序也可以使用那个 `student` 的定义。现在关于类、类方法等还有其他问题吗？

**问：** 我想问，有没有一种方法可以声明类的所有可能的——所有可能的属性？因为它看起来如此不一致。
**答：** 嗯，所以我的理解是这是 Python 对这些原则的处理方式。不同的语言，比如 Java，只是采取不同的方法，但有非常相似的特性。语法只是倾向于不同。这就是 Python 社区选择实现这个想法的方式。最终，正确的心智模型是这些实例变量、实例方法属于或操作特定的对象——一个特定的学生，一个特定的帽子。类变量和类方法操作整个类本身，或者反过来，该类的所有对象，我们没有看到这方面的演示，但它是一个更高级别的概念。

事实证明，除了这些类方法（它们与那些实例方法不同，公平地说，实例方法没有自己的装饰器——它们只是，默认情况下，是实例方法），在 Python 的类中还有其他类型的方法。它们倾向于被称为静态方法（static methods），它们也带有另一个叫做 `@staticmethod` 的装饰器，这是一个我们不会深入探讨的兔子洞。但要意识到，在面向对象编程中，你还可以利用其他功能。

但我们想做的是真正专注于一些你不仅在 Python 中看到，在其他语言中也看到的最终核心特性。也许面向对象编程最引人注目的特性之一，我们还没有明确使用——尽管事实证明我们在过去的几周里已经隐式地看到了——是这个继承（inheritance）的概念。

事实证明，通过面向对象编程，实际上有机会以分层的方式设计你的类，即一个类可以从另一个类继承或借用属性——即方法或变量——如果它们都有这些共同点。那么我这是什么意思呢？好吧，让我建议我们在 VS Code 这里实现一个全新的文件，叫做 `wizard.py`。让我运行 `code wizard.py`。然后让我们像以前一样开始，定义一个名为 `Student` 的类。让我们首先定义 `__init__` 方法，它当然至少会接受一个传统上称为 `self` 的参数。在这种情况下，让我们也让它像以前一样接受一个 `name` 和一个 `house`。然后在 `init` 方法中，让我们继续赋实例变量——`self.name = name`，和 `self.house = house`。让我们假设这个类中还有一些其他的功能——点点点 `...`。

但现在让我们继续实现巫师世界中教授（Professor）的概念。所以对于这个类，我们叫它 `Professor`。一个教授，我们说，也将有它自己的初始化方法。所以 `__init__`。它将接受 `self`——总是作为第一个参数。一个教授也有一个名字。所以我们也将那个作为第二个传入。即使有些教授是学院的院长，让我们假设一个教授真正由他们的名字和他们的学科领域——他们教的课——来识别。所以我们将这个第三个参数称为 `subject`。现在，像以前一样，让我们继续赋 `self.name = name`，让我们赋 `self.subject = subject`。像以前一样，让我们假设还有一些与教授相关的更多功能。

那么你在这里，在我对 `Student` 和 `Professor` 的定义中，已经注意到了什么？通常，我们有点不愿意在我们的代码中允许任何冗余。在这里，我觉得我的 `init` 方法为 `Student` 接受一个 `name`；我的 `init` 方法也为 `Professor` 接受一个 `name`；我有这些完全相同的代码行，比如 `self.name = name`。如果我现在去添加一些错误检查，这只会加剧。例如，比如说 `if not name`，我们可能应该养成习惯引发像 `ValueError` 这样的东西，并附带一条解释性消息，比如 "Missing name"。你知道吗？如果一个教授缺少他们的名字，我可能应该把那段代码复制粘贴到这里。这时就应该亮起红灯了，即一旦你开始复制粘贴代码，可能就有更好的方法，这样我们可以编写一次代码，并可能以某种方式重用它。

在这里，面向对象编程也提供了一个解决方案。事实证明，Python 中的面向对象编程也支持继承，你可以定义多个以某种方式相互关联的类。它们不需要像这样并行存在。它们之间实际上可以存在某种层次结构。例如，在巫师世界中，我们可以认为学生和教授，归根结底，都是巫师（Wizard）。所以也许我们真正应该定义的是第三个类，例如，叫做 `Wizard`，它具有学生和教授共有的任何共同属性。目前，我们保持得相对简单。他们唯一的共同点分别是 `Student` 和 `Professor` 中的 `name` 和 `name`。那么为什么我们不至少先把那个提取出来呢？

好的，所以让我在这里。只是为了保持组织性，在我文件的顶部，让我们定义第三个类，叫做 `Wizard`。一个巫师将有它自己的初始化方法。所以 `def __init__(self)`，像往常一样。一个巫师，我们暂时说，将只用他们的名字以这种方式初始化。现在，我将做一些错误检查。所以 `if not name` 将在 `Wizard` 类中引发一个 `ValueError`。否则，我们将继续做 `self.name = name`，而且，哎呀，点点点 `...`，也许还有一些其他功能。但不是特定于教授的 `subject`，也不是我声称特定于学生的 `house`。

现在，我想我们可以开始也许移除我们其他类中的一些冗余了。例如，对于 `Student`，为什么我不去掉这里的错误检查，去掉这个 `self.name = name` 的赋值，因为我已经在 `Wizard` 中这样做了。类似地，在下面的 `Professor` 中，为什么我不做同样的事情呢？让我们去掉错误检查。让我们去掉 `self.name = name`，因为，再次强调，我已经在上面的 `Wizard` 中这样做了。

但目前，即使它们都在同一个文件中，我还没有告诉 Python 一个学生是一个巫师，一个教授是一个巫师。所以我真的需要将这两者联系起来。规定继承的方式，即一个类应该从另一个类继承，或者反过来说，一个类应该派生自另一个类——我们可以这样做。我可以说 `class Student`。但在冒号之前，我可以在括号里说，一个 `Student` 继承自，或者是 `Wizard` 的子类（subclass），后者反过来说是 `Student` 类的超类（superclass）。所以这只是意味着，当我定义一个 `Student` 类时，继续继承一个巫师的所有特性。我将对 `Professor` 做同样的事情。所以在类名 `Professor` 之后加上 `(Wizard)`，这将让我能够访问一些相同的功能。

但是因为我的 `Student` 类和我的 `Professor` 类仍然有它们相同的 `init` 方法，那些是将要被调用的方法。每当我在代码中创建一个 `Student` 或我在代码中创建一个 `Professor` 时，我需要以某种方式明确地说我也想使用 `Wizard` 类 `init` 方法中的功能。在 Python 中做到这一点的方法如下。让我进入 `Student` 的 `init` 方法，让我调用 `super()`，不带参数，这是对这个类的超类的一个引用。所以如果这个类是 `Student`，超类——也就是父类——是 `Wizard`。所以 `super()` 将起到访问超类的作用。然后我将明确地调用它的 `init` 方法，我将把 `Student` 的 `init` 方法被传递的 `name` 传递给 `Wizard` 的 `init` 方法。我将在下面的 `Wizard`（应为 Professor）中做同样的事情。这是一行复制粘贴。但我认为我在这里可以接受，因为它仍然允许我在 `Wizard` 类中完成所有的名字赋值和错误检查。我想我们现在通过为 `Student` 和 `Professor` 都调用 `super().__init__` 就可以了。

现在，诚然，这个语法绝对是有点特别——我们调用 `super()` 带括号和点号，以及 `init` 左右两边的双下划线，但这只是这两个想法的结合。`super()` 是一种以编程方式访问当前类的父类或超类的方法，而 `__init__`，当然，只是指代那个类自己的初始化方法。

现在，根据点点点 `...`——所以这些类中可能还有很多其他事情在发生。但现在的好处是 `Wizard` 作为一个类负责了所有巫师名字的赋值，无论那个巫师是学生还是教授。它甚至做了一些错误检查，以确保名字确实被传入了。与此同时，`Student` 继承了所有这些功能，并通过调用超类自己的 `init` 方法来使用它。但它额外地接受了大概是传递给 `student` 构造函数的 `house`，并将其赋给它自己的实例变量——`self.house`，类似地，`Professor`，或者说在 `self.subject` 中存储了传递给那个的 `subject`。

现在，我们可能如何使用这些类呢？好吧，我们将继续在这里稍微省略一些细节。但是在这个文件的底部，或者任何导入了这个文件的其他文件中，我现在可以编写像这样的代码。我可以创建一个 `student` 变量，并将其赋给 `Student` 构造器调用的返回值。也许那个学生名叫 Harry，那个学生的学院，例如，可能是 Gryffindor。与此同时，我可能做类似这样的事情。`professor = Professor` 在这里。注意左边的小写 s，右边的大写 S。对于左边的 `professor` 也是一样——分别是小写和大写。`Professor`，引号里的，“Severus”，他的学科就设为黑魔法防御术（Defense Against the Dark Arts）吧？与此同时，如果我们想要，更通用地，只是一个巫师，他目前既不是学生也不是正在积极授课的教授，我们甚至可以这样做。我们可以做 `wizard = Wizard`，在等号右侧用大写 W，因为它是类的名称。像 Albus 这样的人——只传入 Albus 的名字——没有学院，没有学科，因为，在这种情况下，他只被称为一个巫师。

与此同时，对于这些调用中的每一个，这里的这行代码将确保 `Wizard` 类的 `init` 方法被调用。这里的这行代码将确保 `Student` 类的 `init` 方法被调用，并且进而，超类 `Wizard` 的 `init` 方法也被调用。然后最后，在这最后一行代码上，这个语法将确保 `Professor` 类的 `init` 方法被调用，后者进而也调用了超类的 `init` 方法。

现在关于这个继承的概念有什么问题吗？这是许多面向对象编程语言的一个关键特性。

**问（Michael）：** 从我目前看到的来看，很多时候，有很多嵌套。如果你使用 `super()`，它会向上一级吗？有没有可能它也嵌套在另一个类中，比如说，在 `Wizard` 之上？
**答：** 一个非常好的问题。如果你有一个超超类（super superclass）——所以你的层次结构比我们目前拥有的两级层次结构更高，绝对可以。继承的好处，正如其名所示，是，就像你作为一个人可能从你的祖父和祖母或你的曾祖父或曾祖母那里继承了某些特征一样，在代码的上下文中，其中一些属性实际上也可以传递给你。所以当你派生自另一个类时——也就是说，当你子类化一个超类或一个超超类时，你实际上确实继承了所有功能，不仅来自你上一级，也来自两级或三级，所以你确实也可以访问其中一些功能。你甚至可以覆盖它，如果你希望其中一些类的行为与其他类略有不同。关于继承的其他问题。

**问：** 这与上一个类似，但是你可以在同一级别上有两个父类吗？
**答：** 一个非常好的问题。所以有方法可以实现从多个父类派生。有不同的方法可以做到这一点，不仅在 Python 中，在其他语言中也是如此。不过，我们在这里通过单一继承路径保持了简单。好问题。关于继承的最后一个问题怎么样？

**问：** 我们可以在 `super().__init__` 中有多个参数吗？
**答：** 可以，但在这种情况下，我在第 18 行只传递了一个 `name`，我在第 10 行只传递了一个 `name`。为什么？因为，在第 2 行，当我为 `Wizard` 类定义 `init` 方法时，我只期望一个参数。但我绝对可以有其他共同的功能。我可以加入一个守护神。如果学生和教授都有可以从魔杖中出来的守护神，我可以有两个参数。

我们现在已经以异常的形式使用面向对象编程的这个特性相当长一段时间了。确实，如果你查看 Python 中异常的官方文档，你会看到甚至不止我们在课堂上见过的那些，比如 `ValueError` 等。还有很多其他的，但它们本身都是具有层次结构的。这只是 Python 内置的可用异常的一个子集。你实际上，作为程序员，也可以创建你自己的异常。但正如这张图在这里按层次结构捕捉到的，我们到目前为止看到的所有异常实际上都派生自或继承自已有的超类。

例如，在这个列表的底部是 `ValueError`，我们已经见过很多次了。如果你沿着这张图的 ascii 渲染直线向上看，你会看到 `ValueError` 有一个父类，或超类，叫做 `Exception`。而 `Exception` 类，同时，有一个父类叫做 `BaseException`。Python 的作者们为什么要这样做？嗯，事实证明，无论你遇到的是 `ValueError` 还是 `KeyError` 还是 `AssertionError` 或其他任何数量的错误，所有那些类型的错误都有很多共同的功能，你希望——你希望程序员能够使用。所以事实证明 Python 的作者们决定，你知道吗？我们不要有十几个或更多的不同类，它们都只是复制粘贴了相似的功能。让我们创建这个层次结构，这样，即使这个列表底部的异常非常精确，它们至少继承了——也就是借用了——上面一些非常共同的功能。

所以事实证明，当你在 Python 中使用 `try` 和 `except` 关键字时，一般来说，我们试图捕获非常具体的异常，比如 `ValueError`。但技术上，你可以捕获给定异常的父类甚至祖父类异常，特别是如果你不一定确定哪一个会被引发。或者，更好的是，可能会有很多异常被引发，但你想以相同的方式处理它们，你不想必然地在括号里用逗号分隔来枚举它们。你想说你想以大致相同的方式处理某个超类的所有异常。所以这一直是潜在的，任何时候我们看到、使用、捕获或者现在，引发异常，Python 内置的就是这个层次结构。如果你要发明你自己的异常，通常，你不会想从头开始。你会想派生自——也就是子类化，这些现有异常之一，并添加你自己的特色，你自己的功能。

好吧，面向对象编程还有一个最后的特性，我们今天想和大家分享，然后它可能会让你大开眼界，了解到既然你有了类供你使用，你真正能做什么。

这，同样，令人惊讶的是，一直是一个你我几周来都理所当然地使用的特性。这只是能工作，但它的实现方式是你现在可以自己利用的。事实证明，Python，以及其他一些语言，也支持这个运算符重载（operator overloading）的概念，即你可以采用非常常见的符号，比如加号或减号或其他键盘上的此类语法，你可以实现你自己的对其的解释。加号不一定等于加法。减号不一定等于减法。事实上，你我已经见过加号意味着其他东西的另一种上下文。在 Python 中，加号并不总是意味着加法本身。Python 还用加号做了什么？

**问：** 连接？
**答：** 用于连接（concatenation）。用于连接两个字符串，用于向列表添加，你也可以使用加号。所以加号实际上，有趣的是，已经被 Python 的作者们为我们重载了。所以我们可以用大致与加法相同的方式使用同一个符号，但用不同的数据类型来解决稍微不同的问题。

好吧，让我建议我们回到 VS Code 这里，让我创建一个新的最终文件，叫做 `vault.py`。所以 `code vault.py`。让我建议我们实现古灵阁（Gringotts）金库（vault）的概念，继续保持主题，即哈利波特世界里有一家银行。在这家银行内部，家庭和个人拥有金库，里面装着巫师世界里各种各样的钱币。哈利波特世界里存在的钱币类型是称为加隆（galleons）、西可（sickles）和纳特（Knuts）的硬币，它们按价值降序排列。所以一个金库里面可能有一大堆硬币——基本上是金、银和铜，每种都有那些面额，藏在里面。

那么我如何首先实现一个金库的概念，以便我可以存储，例如，哈利波特的家族金库里有多少钱币，或者罗恩·韦斯莱（Ron Weasley）的也一样？好吧，让我进入 `vault.py` 并首先创建一个名为 `Vault` 的类，本质上是为了表示一个银行金库。完美，又一个我想用代码表示的现实世界，或幻想世界的实体。我可以使用元组或列表或字典。但是再次强调，我将通过类获得更多的功能，我们将看到运算符的最后一个点睛之笔。

在这个 `Vault` 类内部，让我们这样做。让我定义我的 `init` 方法，接受它的第一个参数 `self`。让我为这个定义三个参数。当你创建我的代码这里的金库时，我希望能够用一定数量的加隆、一定数量的西可和一定数量的纳特来初始化它。我希望用户，程序员，能够理想地传入这些值中的一个或多个。但它们可以是可选的，所以我将给它们默认值。所以让我们定义一个名为 `galleons` 的参数，其默认值为 0；`sickles`，其默认值也将为 0；以及 `knuts`，其默认值也将为 0。所以程序员可以传入其中一个或两个或三个甚至一个都不传，它们都将有一些隐含的默认值。

我希望如何记住那些传入的值？嗯，让我这样做。`self.galleons = galleons`。以及 `self.sickles = sickles`。以及 `self.knuts = knuts`。所以我可以添加一些错误检查，特别是如果你没有传入一个数字。我可以将这些变成属性来做更多的验证。但让我们保持简单，并像往常一样，只关注新的想法。所以我将只相信这些值被传入了，我将立即将它们赋给这些实例变量。

现在，我想做什么？好吧，让我们想出一种方法来最终打印出某人金库里的东西。但首先让我们这样做。让我们通过赋值创建一个新的金库，为波特家创建一个金库。我们说波特家有 100 加隆，50 西可和 25 纳特（原文是 24，后文计算和打印按 25，此处按 25 修正）。那就在那个金库里。让我们打印出，例如，`potter`。好的，让我们运行这段代码，看看它现在如何工作。让我运行 `python vault.py`，回车。似乎有效。没有语法错误或其他任何东西。但这不是很启发性。我该如何解决这个问题，回想一下我们之前做过的事情？

**问：** 你必须使用 `__str__`。
**答：** 完全正确。我需要使用那些类自带的特殊方法之一，并为自己定义我希望金库如何作为字符串打印出来。所以让我这样做。让我定义 `str` 方法，接受 `self` 作为其唯一参数。让我们只返回一个非常简单的字符串，它只揭示金库里的东西。所以我将返回一个格式化的 f-string，里面是 `self.galleons` 然后是单词 "galleons"，这样我就知道那些是哪个。然后让我们做 `self.sickles`，让我们输出单词 "sickles"。然后最后让我们输出 `self.knuts`，然后是 "knuts" 在这里。所以我知道，在这个字符串中，这个特定家庭的金库里每种硬币有多少。

好的，让我继续运行 `python vault.py`，不更改其他任何东西，除了 `str` 方法。现在，瞧，我们确实看到 Harry 有 100 加隆，50 西可和 25 纳特。

好的，好吧，让我们在这里再做一件事。在那下面，让我们定义一个 `weasley` 变量。Ron 似乎从来没有像 Harry 那样在金库里有那么多钱。所以我们说韦斯莱家的金库将有 25, 50 和 100。所以我只是颠倒了那些面额的顺序，而不是 Harry 的 100, 50, 25。现在让我继续打印 `weasley`，像这样。让我们清空我的终端窗口，运行 `python vault.py`。这次，那个 `str` 方法将被调用两次，每个金库对象一次。我们会看到，确实，Harry 的第一个有 100, 50 和 25，分别是，而 Ron 的是 25, 50 和 100，分别是。

但现在让我们做一些有趣的事情。假设你想合并两个金库的内容，无论是 Harry 的和 Ron 的，还是任何其他两个人的。你将如何在代码中做到这一点？好吧，如果我想合并某人的金库，我可以这样做。嗯，我可以做 `galleons = potter.galleons + weasley.galleons`。这给了我一个名为 `galleons` 的变量，它包含了 Harry 和 Ron 的加隆总和。接下来让我们做 `sickles = potter.sickles + weasley.sickles`。然后最后，让我们做 `knuts = potter.knuts + weasley.knuts`。我有三个变量。我现在可以用这些值做什么？嗯，让我们创建第三个——一个新的金库。`total` 将是这个变量的名称，等于一个新的 `Vault`，注意是大写 V。现在，让我们传入那三个新变量——`galleons`, `sickles`, 和 `knuts`。就这样，让我们打印出这个 `total` 金库。所以我们现在应该看到三个金库——一个 Harry 的，一个 Ron 的，以及两者的组合——相加。

让我重新运行 `python vault.py`，我们得到了。原来是 100, 50, 25 和 25, 50, 100，现在通过加法合并，是 125, 100, 125。所以非常直接，使用了几周前的技术，我们只是声明了几个新变量并做了一些加法。

但如果我能做类似这样的事情，那岂不是很酷？如果我能以某种方式，不手动创建我自己的金库并做所有这些烦人的数学运算——如果我能只做 `potter + weasley` 并去掉所有这里的逻辑，那岂不是很酷？如果我能重载我们称为加号的运算符，就像 `str` 做的那样，就像 `list` 做的那样——允许我在左边和右边将两个金库加在一起，那岂不是很棒？

嗯，事实证明在 Python 中以及通过运算符重载，有一种方法可以做到这一点。如果你查阅文档，有这个以及许多其他类自带的特殊方法。我们在这里将看到的第三个是这个——`__add__`。你会看到它在文档中非常通用地被描述为适用于任何对象，无论是 `Vault` 还是 `str` 还是 `list` 或其他东西。按照惯例，它将接受一个名为 `self` 的第一个参数，然后它将接受某个其他参数，按照惯例称为 `other`。`self`，实际上，将引用加号左侧的任何对象。`other` 将引用加号右侧的任何对象，从而为我们提供一种在代码中描述运算符（中间的加号）左侧的操作数和右侧的操作数的方式。也就是说，如果我回到 VS Code 这里，我试图做的是实现对这个的支持。

好吧，让我尝试，不写任何其他代码——`python vault.py`，回车——`TypeError: unsupported operand type(s) for +: 'Vault' and 'Vault'`。也就是说 Python，此刻，不知道将两个金库加在一起意味着什么。你我可能有一个直觉。可能想要分别将加隆、西可和纳特组合起来。Python 不知道那个。它只知道你有一个名为 `Vault` 的新类。

但让我们教 Python 这样做。让我清空我的终端窗口。让我向上滚动回到类本身，目前，我只有两个特殊方法——`init` 和 `str`。但让我们添加这第三个。让我进入类这里并定义 `__add__`，然后将其第一个参数指定为 `self`，像以前一样，然后这个特定方法的第二个参数，按照惯例，称为 `other`。现在，像往常一样，我可以叫那些参数任何我想要的名字，但我将在这里坚持惯例。

现在，在这个方法内部，我是否将不得不将两个金库的内容加在一起？嗯，哪两个金库？嗯，如果我们向下滚动到我们手头的目标，目标，当然，是将这个金库加上这个其他金库——分别是 `potter` 加上 `weasley`。嗯，事实证明，在 Python 中，当你确实重载像加号这样的运算符时，将自动发生的是，一旦 Python 看到那个，它将调用那个 `__add__` 方法，它将向其传递两个参数——左侧的操作数是什么——在这种情况下是 `potter`——以及右侧的操作数是什么——在这种情况下是 `weasley`。那些值将分别作为 `self` 和 `other` 传入。这意味着我们可以在我们 `add` 的实现中像下面这样访问它们的内容。

让我定义一个名为 `galleons` 的局部变量，并将其设置为，例如，`self.galleons`（在这种情况下是 Potter 金库里的东西）加上 `other.galleons`（在这种情况下是 Weasley 金库里的东西）的总和。让我对 `sickles` 做同样的事情。`self.sickles + other.sickles`。让我最后对 `knuts` 做同样的事情。所以 `self.knuts + other.knuts`。

但归根结底，我将需要返回一个全新的、更大的金库，它包含所有那些内容在一起。如果我们最终想将那个更大的金库赋给像这里的 `total` 这样的变量，在左侧，我们最好从这个 `add` 方法返回一个值。所以我将给自己一个全新的金库，通过返回大写 `Vault`，这当然会调用我的 `Vault` 函数，我现在可以向其传递一些初始化参数。那么我希望这个全新的金库包含多少加隆、西可和纳特呢？嗯，我希望它包含这么多加隆，这么多西可，和这么多纳特。所以最终，我们在 `add` 的这个实现中所做的就是将那些加隆、西可和纳特加在一起，将它们传递给 `Vault` 函数，这样我们就得到了一个全新的、更大的金库，并将其一起返回。

所以现在我定义了这个新的特殊方法叫做 `add`，它现在应该让加号对两个金库起作用了。让我们看看。让我到我的终端窗口运行 `python vault.py` 并按回车。瞧，现在我们实现了一个重载的运算符，加号，来做你我作为人类希望在将两个金库加在一起时发生的事情。但我现在更具体地编写了代码来教 Python 将两个金库加在一起具体意味着什么。实际上，Python 在底层为两个字符串做这件事，将它们连接在一起，将两个列表合并成一个新列表，以及许多其他类，也是用非常相似的代码。

现在关于运算符重载或这里的这个例子有什么问题吗？

**问：** 你将如何创建一个用于添加学生和金库（两个不同的类）的函数？那可能吗？
**答（Eric）：** 让我看看这里会发生什么。我不知道。让我们这样做。让我们创建一个 `str` 看看会发生什么。如果我添加 `potter` 加一个 `str`——`str` 对象。是的，所以它会工作。我只是边做边弄清楚，Eric。所以要清楚的是，我所做的只是将 `weasley` 改为 `str`，只是为了看看当我添加一个 `Vault` 加一个 `str` 时会发生什么，理论上它会工作。为什么？因为只要左侧值的类型实现了 `add` 方法，`other` 可以是你想要的任何类型。你只需要决定并在代码中确定在概念上添加一个 `Vault` 加一个字符串意味着什么，在这种情况下，可能根本没有任何意义，但这是可能的。它将是左侧的操作数。我正在推断这一点。我刚才不知道答案。我正在推断这一点，因为我在这里第 11 行得到了一个 `AttributeError`，因为 Python 不喜欢这个。`other.galleons` 不起作用，但我可以通过弄清楚一些事情让它起作用。非常好的问题。我自己都不知道那个。关于运算符重载的其他问题？

**问：** 你能在 Python 中定义新的运算符吗？
**答：** 我不这么认为。有一个非常长但精确的你可以重载的运算符列表。我相信你不能将任意字符指定为 Python 中的运算符。让我请教一下聊天中的 Carter——好的，我看到我的两个同事说，不，不可能。所以我将坚持我的第一直觉，不。否则，那会有点酷。你可以让表情符号做任何你想做的事情。最后一个关于运算符重载的问题怎么样？

**问：** 这是你能做的唯一操作吗——你能做减法吗？
**答：** 你可以。你可以做很多其他的。如果 Carter 你不介意调出这个 URL 这里——所以这个链接这里——特殊方法名称和今天的幻灯片，你会看到一个长长的列表，列出了所有你可以重载的运算符。你可以做小于、等于、加等于、减等于。几乎任何你在屏幕上看到我输入的符号都可以在类的上下文中被重载。

## 九、 总结

所以即使今天我们完全专注于面向对象编程，这也是我们实际上从这门课的第一周开始就一直在使用的技术，因为那些 `int`、那些 `str`、那些 `float`、那些 `list`、那些 `dict` 以及更多的东西，一直以来都在底层是类及其对象。但是你现在，作为程序员，有能力创建你自己的类，有你自己的实例或类变量，有你自己的实例或类方法，有你自己的属性，甚至有你自己对运算符的自定义行为。所以最终，你绝对可以继续使用那些简单的元组或列表或那些字典或其他结构。但是面向对象编程，以及随之而来的类和现在的这些对象，只是你工具箱中的另一个工具。而且我敢说，随着你的代码变得更加复杂，你的问题变得更大，你会发现能够用类和相关的数据及功能来建模这些现实世界甚至幻想世界的实体，最终只会让你定义出不仅正确而且设计精良的代码。

这里是 CS50。

---

# 要点回顾

**一、 引言与面向对象编程 (OOP) 概念**
- OOP 是一种编程范式，与过程式、函数式编程并列。
- Python 语言支持多种编程范式，包括 OOP。
- OOP 对于构建更大、更复杂的程序特别有用，有助于解决代码组织和维护问题。
- 本讲座将通过逐步改进一个简单程序来引入 OOP 的概念和优势。

**二、 动机：从过程式代码到数据结构**
- 初始示例：一个简单的过程式 `student.py` 脚本，用于获取学生姓名（name）和学院（house）并打印。
- 代码重构：将逻辑封装到 `main` 函数中，并引入 `get_name` 和 `get_house` 函数来提高模块化。
- 进一步重构：将获取学生信息的功能合并到 `get_student` 函数中。
- 遇到问题：`get_student` 函数需要返回多个值（姓名和学院）。

**三、 使用元组 (Tuple) 组织数据**
- 解决方案1：函数可以返回多个值，Python 会隐式地将它们打包成一个元组。
    - 语法：`return name, house` 或显式 `return (name, house)`。
- 元组特性：
    - 是有序的值的集合。
    - **关键特性：元组是不可变的 (immutable)**，创建后其内容不能修改。
- 访问方式：通过数字索引访问元素，如 `student[0]`、`student[1]`。
- 适用场景：当你希望数据集合创建后不被更改时，提供了一种“防御性编程”的方式。
- 不可变性演示：尝试修改元组元素（如 `student[1] = "Ravenclaw"`）会导致 `TypeError`。

**四、 使用列表 (List) 和字典 (Dictionary) 组织数据**
- 列表 (List):
    - 如果需要修改数据（例如修正帕德玛的学院），可以使用列表代替元组。
    - 语法：使用方括号 `[]` 创建，如 `return [name, house]`。
    - **关键特性：列表是可变的 (mutable)**。
- 字典 (Dictionary / dict):
    - 另一种返回多个值的方式，提供了更好的语义。
    - 语法：使用花括号 `{}` 创建键值对，如 `{'name': name_value, 'house': house_value}`。
    - 访问方式：通过键（通常是字符串）访问值，如 `student['name']`、`student['house']`。
    - 优势：键名使得代码更易读、更清晰，尤其是在属性较多时，无需记住索引顺序。
    - **关键特性：字典也是可变的 (mutable)**。
    - 字典操作演示：创建空字典，添加键值对，或直接创建并返回包含键值对的字典。

**五、 核心概念：类 (Class) 与对象 (Object)**
- 面临问题：元组、列表、字典都是通用数据结构。如果能创建自定义的 `Student` 类型会更方便、更符合逻辑。
- 解决方案：使用 `class` 关键字定义自己的数据类型。
- **类 (Class):**
    - 定义对象的蓝图或模板。
    - 语法：`class Student:` （类名按惯例首字母大写）。
- **对象 (Object):**
    - 类的一个实例 (instance)。是根据类的蓝图创建出来的具体实体。
    - 创建对象（实例化）：`student = Student()`。
    - **属性 (Attributes) / 实例变量 (Instance Variables):** 与对象关联的数据。
        - 通过点符号 (`.`) 来访问和设置：`student.name = "Harry"`，`print(student.house)`。

**六、 类的关键组成部分**
- **初始化方法 (`__init__`) 与实例变量:**
    - `__init__` (dunder init - 双下划线 init): 一个特殊方法，在创建对象时自动调用（构造器调用），用于初始化对象的状态（设置初始属性）。
    - 语法：`def __init__(self, arg1, arg2, ...):`。
    - `self`: 实例方法的第一个参数（约定俗成命名为 `self`），代表正在操作的具体对象实例。由 Python 自动传递。
    - 实例变量：属于特定对象的变量，通常在 `__init__` 方法内部使用 `self.variable_name = value` 来定义和赋值。例如：`self.name = name`。
    - 构造器传参：`student = Student("Harry", "Gryffindor")` 会调用 `__init__(self, "Harry", "Gryffindor")`。
- **实例方法 (Instance Methods):**
    - 定义在类内部、操作对象实例的函数。
    - 第一个参数总是 `self`。
    - **特殊方法 (`__str__`):**
        - `__str__` (dunder str): 定义对象的“非正式”或用户友好的字符串表示形式。
        - 当使用 `print(object)` 或 `str(object)` 时自动调用。
        - 语法：`def __str__(self): return f"{self.name} from {self.house}"`。
        - 若未定义，`print(object)` 会输出默认的、不太易读的表示（如 `<__main__.Student object at 0x... >`）。
    - **自定义方法:**
        - 程序员为类定义的特定功能的函数。
        - 示例：为 `Student` 类定义 `charm(self)` 方法，根据学生的守护神 (`self.patronus`) 返回相应的表情符号。
        - 调用方式：通过对象实例调用，如 `student.charm()`。
- **封装与数据验证 (属性 Properties, Getters, Setters):**
    - 问题：实例变量默认可以从类外部直接访问和修改（如 `student.house = "Invalid House"`），这可能绕过在 `__init__` 中设置的验证逻辑。
    - 目标：控制对属性的访问，确保数据在创建后修改时也能被验证。
    - **属性 (Properties):** 行为像普通属性，但其访问（读取、写入）由特定方法（getter、setter）控制。
    - **Getter 方法:**
        - 用于获取属性值。
        - 使用 `@property` 装饰器。
        - 语法：
          ```python
          @property
          def house(self):
              # 通常返回一个内部变量的值
              return self._house
          ```
    - **Setter 方法:**
        - 用于设置属性值，可以在赋值前进行验证。
        - 使用 `@<property_name>.setter` 装饰器。
        - 语法：
          ```python
          @house.setter
          def house(self, house_value):
              # 在此添加验证逻辑
              if house_value not in ["Gryffindor", ...]:
                  raise ValueError("Invalid house")
              # 设置内部变量的值
              self._house = house_value
          ```
    - **内部变量约定:** 为了避免与 getter/setter 方法名冲突，实际存储数据的实例变量通常以单下划线开头（如 `self._house`）。这是一种约定，提示该变量是内部使用的，但在 Python 中并非强制私有。
    - 优势：验证逻辑集中在 setter 中，无论是在 `__init__` 中通过 `self.house = ...` 赋值，还是之后通过 `student.house = ...` 修改，都会触发验证。
    - 错误处理：在 `__init__` 或 setter 中使用 `raise ValueError("错误信息")` 来阻止无效数据的赋值。

**七、 内置类型也是类 (Built-in Types as Classes)**
- 揭示：Python 中常用的内置类型，如 `int`, `str`, `list`, `dict`, `float` 等，实际上都是类。
- 我们一直在不知不觉中使用对象和它们的方法（如 `my_string.lower()`, `my_list.append()`）。
- `type()` 函数可以验证这一点：`print(type(50))` 输出 `<class 'int'>`。
- 命名约定：内置类型类名通常小写（如 `list`），而用户自定义类推荐使用驼峰式大写（如 `Student`）。

**八、 高级类特性**
- **类方法 (`@classmethod`) 与类变量:**
    - **类变量 (Class Variables):** 定义在类作用域内（不在 `self` 下），由该类的所有实例共享。例如，在 `Hat` 类中定义 `houses = ["Gryffindor", ...]`。
    - **类方法 (Class Methods):**
        - 操作类本身而不是特定实例的方法。
        - 使用 `@classmethod` 装饰器。
        - 第一个参数是类本身，约定命名为 `cls`（而非 `self`）。
        - 可以通过 `cls.class_variable` 访问类变量。
        - 通常直接通过类名调用：`Hat.sort("Harry")` 或 `Student.get()`。
        - 适用场景：当方法逻辑与类相关，但不需要访问特定实例的状态时（例如，工厂方法，像 `Student.get()` 用于从用户输入创建 `Student` 对象，避免了先有实例才能创建实例的“鸡生蛋”问题）。
        - 优点：有助于更好地组织代码，将与类紧密相关的功能（如对象的创建逻辑）封装在类定义内部。
- **继承 (Inheritance):**
    - 允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法。
    - 实现代码复用和建立类之间的层次关系（“is-a”关系，例如 `Student` is a `Wizard`）。
    - 语法：`class ChildClass(ParentClass):`。
    - 子类可以重用父类代码，也可以添加自己的特定属性和方法，或覆盖（override）父类的方法。
    - `super()` 函数：在子类中调用父类的方法（常用于 `__init__` 中调用父类的初始化逻辑）。例如：`super().__init__(name)`。
    - 示例：创建 `Wizard` 作为父类，包含 `name` 属性及验证；`Student` 和 `Professor` 类继承自 `Wizard`，并添加各自特有的属性（`house`, `subject`）。
    - Python 内置的 `Exception` 体系就是继承的一个典型例子。
- **运算符重载 (Operator Overloading):**
    - 允许自定义类对内置运算符（如 `+`, `-`, `*`, `<`, ` == ` 等）的行为。
    - 通过实现特定的双下划线方法（dunder methods）来实现，例如：
        - `__add__(self, other)` 对应 `+` 运算符。
        - `__sub__(self, other)` 对应 `-` 运算符。
        - `__str__(self)` 也是一种特殊方法重载。
    - 示例：在 `Vault` 类中定义 `__add__` 方法，使得两个 `Vault` 对象可以使用 `+` 相加，返回一个新的包含两者总和的 `Vault` 对象。`self` 代表左操作数，`other` 代表右操作数。
    - 好处：使自定义类的对象能像内置类型一样自然地使用运算符，提高代码可读性。
    - 我们早已体验过运算符重载：`+` 用于数字相加、字符串拼接、列表合并。

**九、 总结**
- OOP 提供了一种强大的方式来组织和构建代码，尤其适用于复杂系统。
- 通过类，可以创建具有特定属性（数据）和方法（行为）的自定义数据类型。
- `__init__`, `__str__`, `__add__` 等特殊方法提供了与 Python 核心机制集成的能力。
- 属性 (Properties) 提供了对数据访问和修改的更好控制。
- 类方法和类变量适用于与类本身相关的功能和数据。
- 继承实现了代码复用和层次化设计。
- 运算符重载让自定义对象的操作更自然。
- 虽然元组、列表、字典仍然有用，但类和对象为建模真实世界（或幻想世界）实体提供了更结构化、更强大的工具。
- OOP 不仅仅关乎代码正确性，更关乎代码设计的健壮性、可维护性和可扩展性。
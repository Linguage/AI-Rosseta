
# 「哈佛CS50P-Python编程导论」第7讲 - 正则表达式

- 视频链接：[CS50P - Lecture 7 - Regular Expressions](https://www.youtube.com/watch?v=hy3sd9MOAcc&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=9)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---

### 内容介绍

欢迎阅读 CS50P 第七讲关于正则表达式的演讲实录。在编程实践中，我们经常需要处理和验证文本数据，尤其是用户输入。正则表达式（Regular Expressions，或 Regex）提供了一种强大而灵活的方式来定义文本模式，从而高效地完成查找、匹配、替换和提取等任务。

本讲座将引导您逐步了解正则表达式的核心概念和应用。我们将从一个实际问题出发——验证电子邮件地址——首先尝试使用 Python 内置的字符串方法解决，以此揭示传统方法的局限性，说明为何需要更专业的工具。随后，讲座将系统介绍 Python 的 `re` 库，详细讲解正则表达式的基本语法，包括元字符、字符集、锚点、分组与捕获等关键元素，并通过实例阐释它们的具体用法和组合方式。

讲座中，我们将通过 `validate.py`、`format.py` 和 `twitter.py` 等多个具体的代码示例，演示如何应用正则表达式来解决实际问题，如验证邮箱格式（并探讨其复杂性）、统一姓名格式、以及从 URL 中准确提取用户名，同时处理各种常见的输入变体。您还将了解到 `re.search`、`re.sub` 等核心函数的用法，以及非捕获组、标志位（如忽略大小写）和较新的海象运算符等进阶特性。讲座强调了迭代开发和测试的重要性，帮助您掌握构建和调试正则表达式的有效方法。


### 内容纲要

```
CS50P 第 7 讲：正则表达式
├── 一、正则表达式简介
│   ├── 定义：作为模式 (Pattern) 的文本字符串
│   └── 用途：验证输入、查找模式、清理与提取数据
├── 二、不使用正则表达式进行验证的局限性 (`validate.py` 示例)
│   ├── 尝试：使用基本字符串方法验证邮箱 (in, split, endswith)
│   ├── 问题：简单检查过于宽松，增加检查导致代码复杂脆弱
│   └── 结论：传统方法对复杂模式不够健壮、难维护
├── 三、Python `re` 库入门
│   ├── 引入：`import re`
│   └── 核心函数：`re.search(pattern, string, flags=0)` 及其基本用法
├── 四、正则表达式基本模式语法
│   ├── 元字符：`.`, `*`, `+`, `?`, `{m}`, `{m,n}` 的含义与示例
│   ├── 字面量：普通字符的匹配
│   └── 转义与原始字符串：`\.` 匹配点本身，`r"..."` 的使用建议
├── 五、锚点与边界
│   ├── `^`：匹配字符串开头
│   ├── `$`：匹配字符串结尾
│   └── 作用：确保整个字符串精确匹配模式
├── 六、字符集与字符类
│   ├── 字符集 `[...]`：匹配指定字符或范围 `[a-z]`, `[0-9]`
│   ├── 排除型字符集 `[^...]`：匹配非指定字符
│   └── 预定义字符类：`\d`, `\D`, `\s`, `\S`, `\w`, `\W` 及其含义
├── 七、标志位 (Flags)
│   ├── 作用：修改匹配行为
│   └── 示例：`re.IGNORECASE` (或 `re.I`) 实现不区分大小写匹配
├── 八、分组与捕获
│   ├── 分组 `(...)`：作为单元处理，应用量词，实现“或”逻辑 `(A|B)`
│   ├── 捕获组：默认 `()` 会捕获匹配内容
│   │   └── 访问：`match.group(n)`, `match.groups()`
│   └── 非捕获组 `(?:...)`：仅分组不捕获，不影响组号
├── 九、海象运算符 (Walrus Operator) `:=`
│   └── 用途：在表达式 (如 `if`) 中同时赋值和判断，简化代码
├── 十、正则表达式的实际应用
│   ├── 复杂验证：电子邮件地址 (提及真实世界复杂性，建议用库)
│   ├── 数据清理与格式化 (`format.py` 示例)
│   │   ├── 场景：姓名格式转换 ("姓, 名" -> "名 姓")
│   │   └── 实现：`re.search` 结合捕获组提取并重组
│   ├── 数据提取 (`twitter.py` 示例)
│   │   ├── 场景：从 URL 中提取 Twitter 用户名
│   │   ├── 演进：对比 `replace`/`removeprefix` -> `re.sub` -> `re.search`
│   │   └── 关键：使用捕获组精确提取，处理 URL 变体 (http/https, www)，使用非捕获组简化
│   └── 其他 `re` 库函数简介
│       └── `re.match`, `re.fullmatch`, `re.split`, `re.findall`
└── 十一、编写正则表达式的最佳实践与结论
    ├── 最佳实践：逐步构建、充分测试、注意可读性
    └── 总结：正则表达式是跨语言的强大文本处理工具
```

---

# CS50P 第 7 讲：正则表达式

## 一、 正则表达式简介

好的。这是 CS50 的 Python 编程入门。我是 David Malan，这是我们关于正则表达式的一周。

那么，正则表达式，也称为 regex，实际上就是一个模式。确实，在编程中，使用模式来匹配某种数据是很常见的，通常是用户输入。例如，如果用户在你的程序、网站或手机应用中输入了一个电子邮件地址，你理想情况下希望能够验证他们确实输入的是一个电子邮件地址，而不是完全不同的东西。所以，使用正则表达式，我们将拥有新的能力，在我们的代码中定义模式，将它们与我们从别人那里收到的数据进行比较，无论是仅仅为了验证它，还是甚至当我们想要清理大量本身可能很混乱的数据时，因为这些数据也来自于我们人类。

## 二、 不使用正则表达式进行验证的局限性 (`validate.py` 示例)

不过，在我们使用这些正则表达式之前，我建议我们先用一些更简单的语法来解决几个问题，看看我们会遇到什么样的限制。

我建议我在这里打开 VS Code，然后创建一个名为 `validate.py` 的文件，目标是验证用户的电子邮件地址。他们访问了你的应用，访问了你的网站，输入了他们的电子邮件地址，我们想说是或否，这个电子邮件地址看起来有效。

好的。我将输入 `code validate.py` 来在这里创建一个新标签页。然后在这个标签页内，我将开始编写一些代码，初步让事情保持简单。

首先，我将提示用户输入他们的电子邮件地址。我会将 `input` 的返回值存储在一个名为 `email` 的变量中，问他们“你的邮箱是什么？”问号。我将预先至少稍微清理一下用户的输入，至少在调用 `input` 结束时调用 `strip`，因为回想一下 `input` 返回一个字符串或 `str`。`str` 类型带有一些内置的方法或函数，其中之一是 `strip`，它的作用是去除左边的任何前导空格或右边的任何尾随空格。所以这至少可以避免用户意外输入了空格字符。我们会以防万一将其丢弃。

现在我将做一些简单的事情。对于用户的输入来说，要成为一个电子邮件地址，我想我们都可以同意，它里面至少得有一个 @ 符号。所以让我们从简单的开始。如果用户输入的内容中包含 @ 符号，让我们非常宽容地说，好的，有效，看起来像一个电子邮件地址。如果我们缺少那个 @ 符号，让我们说无效，因为它显然不是一个电子邮件地址。这还不是我代码的最佳版本，但我们会从简单的开始。

所以我会问这个问题，如果用户的电子邮件地址中有 @ 符号，那就打印出来，例如，引号内的 "valid"。否则，如果没有，那么我很确定这个电子邮件地址实际上是无效的。

```python
email = input("What's your email? ").strip()

if "@" in email:
    print("Valid")
else:
    print("Invalid")
```

这段代码在做什么？嗯，`if "@" in email` 是一种 Pythonic 的方式，用来询问这个字符串，即引号内的 "@"，是否存在于另一个字符串 `email` 中，无论它在开头、中间还是结尾。它会自动为你搜索整个字符串。我可以更冗长地做这件事。我可以使用 for 循环或 while 循环，检查用户电子邮件地址中的每个字符，看它是否是 @ 符号。但这是 Python 的优点之一。你可以用更少的代码做更多的事情。所以仅仅通过说 `if "@" in email`，我们就达到了同样的结果。如果在里面某处有，我们将得到 true，因此是有效的，或者如果没有，则为 false。

好吧，现在让我继续在我的终端窗口中用 `python validate.py` 运行这个程序。我将输入我的电子邮件地址——malan@harvard.edu，回车。确实，它是有效的。看起来有效，就是有效。

但当然，这个程序技术上是有问题的。它有 bug。如果有人愿意在这里提供一个答案，什么样的示例输入会被认为是有效的，但你和我知道它实际上并不是有效的？

**问：** （观众）是的，谢谢。嗯，例如，你可以只输入两个符号，就这样，它仍然是有效的——根据你的程序仍然有效，但缺少了某些东西。
**答：** （David Malan）完全正确。我们在这里设定的门槛非常低。事实上，如果我重新运行 `python validate.py`，然后我只输入一个 @ 符号，就这样——没有用户名，没有域名，这看起来真的不像一个电子邮件地址。但不幸的是，我的代码认为它实际上是，因为它显然只在寻找单独的 @ 符号。

我们该如何改进呢？嗯，至少一个电子邮件地址，我认为，往往包含一个 @ 符号和至少一个点，可能在域名中的某个地方——比如 malan@harvard.edu。虽然这实际上并非必须的要求。所以让我们也检查那个点。但同样，严格来说，甚至不必是这种情况。但至少目前，我以我自己的电子邮件地址作为我们的测试用例。

所以让我继续修改我的代码，现在说，不仅 `if "@" in email`，而且 `"." in email` 也必须成立。

```python
email = input("What's your email? ").strip()

if "@" in email and "." in email:
    print("Valid")
else:
    print("Invalid")
```

所以我现在问了两个问题。我有两个布尔表达式——`if "@" in email`，并且我用逻辑与（and）将它们连接起来——这是一个逻辑与，可以这么说。所以如果情况是 @ 在 email 中并且点也在 email 中，好的，现在我将继续说有效。

好的。这对于我的电子邮件地址似乎仍然有效。让我运行 `python validate.py`，输入 malan@harvard.edu，回车，当然，这如预期的那样是有效的。但在这里，我们也可以稍微刁难一下，输入一些无意义的东西，比如 "@."，不幸的是，这也会被误认为是有效的，即使仍然没有用户名、域名或类似的东西。

所以我认为我们需要更有条理一些。事实上，请注意，如果我这样做，@ 符号可以在任何地方，点也可以在任何地方。但如果我假设用户会有一个传统的域名，比如 harvard.edu 或 gmail.com，我真的只想在域名部分查找点，而不一定只是在用户名部分。

所以让我这样做。让我在这里引入更多的逻辑，改为这样做。让我用 `email.split('@')`。

`email` 同样是一个字符串或 `str`。`str` 带有方法，不仅有 `strip` 还有另一个叫做 `split` 的方法，顾名思义，如果你给它一个或多个字符来分割，它会将一个 `str` 分割成多个。所以这有望从一个传统的电子邮件地址返回给我两个部分，用户名和域名。事实证明，我可以通过这样做来解包（unpack）这个响应序列——`username, domain = email.split('@')`。我可以把它存储在一个列表或其他结构中，但如果我事先已经知道我期望得到什么样的值，一个用户名和一个（希望是）域名，我将改为这样做，在一行代码中同时定义两个变量。

现在我将更精确一点。如果 `username` 存在——如果 `username` 存在，那么我将打印 "valid"。否则，我将打印 "invalid"。

```python
email = input("What's your email? ").strip()

username, domain = email.split("@")

if username:
    print("Valid")
else:
    print("Invalid")
```

现在，这还不够好。但我至少现在检查了用户名的存在。你可能以前没见过这个，但如果你简单地问一个问题，比如 `if username`，并且 `username` 是一个字符串，那么 `if username` 会给我一个 true 的答案，如果 `username` 是除了 `None` 或引号内的 "nothing" 之外的任何东西。所以这里有一个真值（truthy value），即如果 `username` 至少有一个字符，那将被认为是 true。但如果 `username` 没有字符，它实际上将被认为是 false 值。

但这还不够好。我不想只检查用户名。我还想检查域名中是否也包含点。

```python
email = input("What's your email? ").strip()

username, domain = email.split("@")

if username and "." in domain:
    print("Valid")
else:
    print("Invalid")
```

所以注意这里，英语语言可能会有一些潜在的混淆。这里，我似乎在说 "if username and dot in domain"，好像我在问 "if the username and the dot are in the domain"，但这并不是这个意思。这是两个独立的布尔表达式——"if username"，以及分开的 "if dot in domain"。如果我加上括号，我们可以通过在这里加括号，在这里加括号，让它更清晰。所以要清楚的是，这真的是两个我们用 and 连接起来的布尔表达式，而不是一个更长的类似英语的句子。

现在，如果我运行这个，`python validate.py` 回车，我再试一次我自己的电子邮件地址，malan@harvard.edu，那是有效的。看起来我可以容忍像这样的东西。如果我输入 malan@，比如说，harvard，我想目前这将是无效的。现在，也许顶级域名 harvard 存在。但目前看来，我们在寻找更多的东西。我们也在寻找一个顶级域名，比如 .edu。目前，我们就认为这是无效的。

但我们想做的不仅仅是检查用户名的存在和点的存在。让我们更具体一些。让我们现在开始缩小这个程序的范围，不仅仅是关于一般的电子邮件，而是关于 .edu 地址，特别是针对在美国大学的人，他们的电子邮件地址通常以 .edu 结尾。

我可以更精确一点。你可能还记得这个函数。与其只说，域名中某处是否有 . 点，不如我说，并且 `domain.endswith(".edu")`。

```python
email = input("What's your email? ").strip()

username, domain = email.split("@")

if username and domain.endswith(".edu"):
    print("Valid")
else:
    print("Invalid")
```

现在我们更加精确了。我们希望至少有一个非空的用户名——它不仅仅是引号内的 "nothing"——并且我们希望域名实际上以 .edu 结尾。

让我运行 `python validate.py`。为了确保我没有让事情变得更糟，我至少测试一下我自己的电子邮件地址，它看起来确实是有效的。现在，看来我至少需要提供一个用户名，因为我们确实有那个检查。所以我将输入 malan。现在我将输入 @。看起来我可以在这里稍微捣乱一下，只说 malan@.edu，好像最低限度地满足了这个模式的要求。当然，这被认为是有效的，但我很确定没有人在 malan@.edu。我们需要在那里有一些域名。所以我们仍然不够慷慨。

现在，我们绝对可以继续迭代这个程序，我们可以添加更多的布尔表达式。我们也许可以使用其他 Python 方法来更精确地检查，点的左边是否有东西，点的右边是否有东西。我们可以多次使用 `split`。但老实说，这很快就会升级。就像，你最终需要写很多代码，只是为了表达精神上相对简单的事情——只需将其格式化为电子邮件地址。

## 三、 Python `re` 库入门

那么我们该如何改进呢？嗯，事实证明，在 Python 中有一个用于正则表达式的库。它被简洁地称为 RE。在 `re` 库中，你有很多功能来定义、检查甚至替换模式。

再说一次，正则表达式就是一个模式。而这个库，Python 中的 `re` 库，将让我们能够定义一些这样的模式，比如电子邮件地址的模式，然后使用一些内置函数来实际验证用户的输入是否符合该模式，甚至使用这些模式来更改用户的输入或从中提取部分信息。我们会看到所有这些以及更多的例子。

那么我能用这个库做什么，应该做什么呢？嗯，首先，它带有很多功能。例如，这里是官方文档的 URL。我建议我们专注于使用库中最通用的函数之一，即这个——`search`。`re.search` 是 `re` 模块中的函数名，它允许你传入几个参数。第一个将是你要搜索的模式，例如，在来自用户的字符串中。这里的 `string` 参数将是你要搜索该模式的实际字符串。然后还有一个可选的第三个参数，是一大堆标志（flags）。标志通常是你传递给函数以修改其行为的参数。但最初，我们甚至不会使用这个。我们将只传入几个参数。

所以让我继续使用这个 `re` 库，这个正则表达式库，并逐步改进这个设计。所以我们不会一次性解决所有问题，但我们会采取一些渐进的步骤。

我将回到 VS Code。我现在将删除大部分代码。但我会去文件的顶部，首先，导入这个 `re` 库。所以 `import re` 让我可以访问那个函数及更多功能。

现在，在我像以前一样获取用户输入，去除任何前导或尾随空格之后，我现在将非常简单地使用这个函数，即使这并不是一个很大的进步。我会说，`if re.search("@", email):`，然后打印 "valid"。否则，打印 "invalid"。

```python
import re

email = input("What's your email? ").strip()

if re.search("@", email):
    print("Valid")
else:
    print("Invalid")
```

目前，这真的不比我最初只问 Python `if "@" in email` 的版本好多少。但现在我至少开始使用这个库了，通过使用它自己的 `re.search` 函数，你现在可以假设，如果 @ 符号确实在 email 中，它实际上会返回一个真值。

为了确保这个版本确实如我所期望的那样工作，让我继续运行 `python validate.py` 并回车。我将输入我的实际电子邮件地址，我们又回到了正轨。但这当然不好，因为如果我类似地运行这个版本的程序，只输入一个 @ 符号，而不是一个电子邮件地址，我的代码当然会认为它是有效的。

那么我该如何做得更好呢？嗯，我们需要在正则表达式领域有更多的词汇，以便能够更精确地表达自己。我最终想要定义的模式将是这样的：我希望左边有东西，然后是一个 @ 符号，然后是右边有东西。而右边的东西应该以 .edu 结尾，但也应该在 .edu 之前有东西，比如 Harvard，或者 Yale，或者美国任何其他学校。

## 四、 正则表达式基本模式语法

那么我该如何做到这一点呢？嗯，事实证明，在正则表达式的世界里，无论是在 Python 还是许多其他语言中，都有一些你可以用来定义模式的符号。

目前，我只使用了字面上的原始文本。如果我回到我的代码，`"@"` 这在技术上算是一个正则表达式。我传入了一个带引号的字符串，里面是一个 @ 符号。现在，这不是一个非常有趣的模式。它只是一个 @ 符号。但事实证明，一旦你有了正则表达式或提供该功能的库，你可以更强大地表达自己，如下所示。

让我揭示一下，传递给 `re.search` 的模式可以包含一大堆特殊符号。这里只是其中的一些。在我们即将看到的例子中，在我们即将定义的模式中，这里是特殊符号：
你可以使用单个句点，一个点 `.`，来表示除换行符（空行）外的任何字符。也就是说，如果我不太关心用户用户名中的字母是什么，我只想用户的名字中有一个或多个字符，点 `.` 允许我表达 A 到 Z，大写和小写，以及许多其他字母。
一个星号 `*` 将表示零次或多次重复。所以如果我说某个东西 `*`，这意味着我愿意接受零次重复，也就是根本没有，或者更多次重复——1 次、2 次、3 次或 300 次。
如果你在我的模式中看到一个加号 `+`，那将表示一次或多次重复。也就是说，那里必须至少有一个字符，一个符号，然后可以选择性地在后面有更多。
然后你可以指定零次或一次重复。你可以在一个符号后使用单个问号 `?`，这将表示，我想要这个字符零次或一次，但我只期望这么多。
最后，还有一种方法可以指定特定数量的符号。如果你使用这些花括号和一个数字，这里象征性地表示为 `$m$`，你可以指定你想要 `$m$` 次重复，无论是 1 次、2 次、3 次还是 300 次。你可以自己指定重复的次数。如果你想要一个重复范围，比如你想要这么少或这么多的字符，你可以使用花括号和里面的两个数字，这里称为 `$m$` 和 `$n$`，这将是 `$m$` 到 `$n$` 次重复的范围。

那么所有这些意味着什么呢？好吧，让我回到 VS Code，我建议我们进一步迭代这个解决方案。仅仅检查 @ 符号是不够的。我们已经知道了。我们至少希望左边和右边都有东西。那我该如何表示呢？我不太关心用户的用户名是什么，或者里面有哪些字母，无论是 malan 还是其他人的。所以我将在 @ 符号的左边使用一个单个的句点——点 `.`，再次表示除换行符外的任何字符。但我不仅仅想要一个单一的字符。否则，这个人的用户名只能是 a@某某，或者 b@某某。我希望它是多个这样的字符。所以我最初将使用一个星号 `*`。所以 `.*` 意味着给我左边的东西，我将再做一个，`.*` 右边的东西。

```python
import re

email = input("What's your email? ").strip()

if re.search(".*@.*", email):
    print("Valid")
else:
    print("Invalid")
```

现在，这并不完美，但至少是向前迈出了一步。因为现在我将要做的是这个。我将重新运行 `python validate.py`。我将继续测试我自己的电子邮件地址，只是为了确保我没有让事情变得更糟。现在没问题。我现在将输入一些其他输入，比如只有 malan@，完全没有域名。你会认为这将是无效的。但是，但是，但是它仍然被认为是有效的。

但这是为什么呢？如果我回到这个图表，为什么 malan@ 没有域名现在被认为是有效的？我在这里使用 `.*@.*` 作为我的正则表达式或 regex 有什么错误？

**问：** （观众）因为你用的是 `*` 而不是加号 `+`。
**答：** （David Malan）完全正确。星号 `*` 再次意味着零次或多次重复。所以 `re.search` 完全乐意接受 @ 符号后面什么都没有，因为那将是零次重复。所以我认为我至少需要改进这个，回到我的代码。让我把 `.*` 改成 `.+`。让我把结尾的 `.*` 改成 `.+`。

```python
import re

email = input("What's your email? ").strip()

if re.search(".+@.+", email):
    print("Valid")
else:
    print("Invalid")
```

这样，现在当我运行我的代码时——让我运行 `python validate.py`。我将像往常一样测试我的电子邮件地址。仍然有效。现在让我输入之前那个被意外认为是有效的相同内容。现在我按回车，终于它是无效的了。所以现在我们在更精确地描述我们正在做的事情方面取得了一些进展。

现在，我要指出，就像编程中几乎所有事情一样，包括 Python，通常有多种方法可以解决同一个问题。有人看到在我的代码里，如果我忘记了加号 `+` 操作符的存在，并回到使用星号 `*`，我能做一个小调整吗？如果我只允许你使用点 `.` 和星号 `*`，你能重新创建加号 `+` 的概念吗？

**问：** （观众）是的。使用另一个点，点 点 星号 (`..*`)。
**答：** （David Malan）是的。因为如果一个点表示任何字符，我们就用一个点。然后当你想说“或更多”时，使用另一个点，然后是星号 `*`。所以等同于 `.+` 的将是 `..*`，因为第一个点表示任何字符，第二对字符 `.*` 表示零个或多个其他字符。需要明确的是，它不必是相同的字符。仅仅通过做 `.` 或 `.*` 并不意味着你的整个用户名需要是 a，或 aa，或 aaa，或 aaaa。它可以随每个符号而变化。它只是意味着零个或多个任何字符连续出现。所以我可以在左边和右边都这样做。

```python
# 等效于 .+@.+ 的另一种写法
# if re.search("..*@..*", email):
```

哪一个更好？嗯，这要看情况。我认为可以争论说 `..*` 可能更清晰，因为它现在很明显有一个点，表示任何字符，然后是 `.*`。但如果你经常这样做，像加号 `+` 这样的东西存在的原因之一就是将你的代码整合得更简洁一些。如果你现在熟悉了加号 `+`，也许这对你来说更易读。所以，就像 Python 更普遍的情况一样，你经常会看到表达相同模式的不同方式，理性的人可能会同意或不同意哪种方式比另一种更好。

好吧，让我向你建议，我们可以更形象地思考这两种模型。如果 `.*@.*` 对你来说看起来有点神秘，让我回溯到这个正则表达式的前一个版本，它只是单个的 `.*`。这个正则表达式，`.*@.*` 再次意味着什么？它意味着零个或多个字符，后面跟着一个字面的 @ 符号，后面跟着零个或多个其他字符。

现在，当你将这个模式作为参数传递给 `re.search` 时，它会从左到右读取它，然后用它来尝试匹配输入，在这个例子中是用户输入的 `email`。现在，计算机，`re.search` 是如何跟踪用户的电子邮件是否匹配这个模式的呢？嗯，事实证明，它将使用一种在软件中实现的机器，称为有限状态机（finite state machine），或者更正式地说，一个非确定性有限自动机（nondeterministic finite automaton）。如果我们图形化地描绘它，它的工作方式如下。

`re.search` 函数从这里的一个所谓的起始状态开始。这是它开始时的那种条件。然后它将从左到右读取用户的电子邮件地址。它将决定是留在这个第一个状态还是转换到下一个状态。

例如，在这个第一个状态，当函数读取我的电子邮件地址 malan@harvard.edu 时，它将沿着这条弯曲的边向上绕回自身，一个自反边。它被标记为点 `.`，因为点 `.` 再次只表示任何字符。所以当函数从左到右读取我的电子邮件地址 malan@harvard.edu 时，它将按照以下方式进行这些转换，M-A-L-A-N。然后它希望能跟随这个转换到第二个状态，因为在这台机器和我的电子邮件地址中都有一个字面的 @ 符号。然后它将尝试读取我地址的其余部分，H-A-R-V-A-R-D 点 E-D-U，就这样。然后计算机会检查。它是否最终进入了一个接受状态，一个最终状态，这里在图形上用双圆圈（一个在另一个里面）稍微不同地描绘？这只是意味着，如果计算机在读取完所有用户输入后发现自己处于那个第二个接受状态，那么它确实是一个有效的电子邮件地址。如果碰巧，机器不知何故最终卡在了那个第一个状态，它没有双圆圈，因此不是一个接受状态，计算机将得出结论，这是一个无效的电子邮件地址。

相比之下，如果我们回到我代码的另一个版本，我在左边和右边都用了点加号 `.+`，回想一下，`re.search` 将使用这些状态机之一来从左到右决定是否接受用户的输入，比如 malan@harvard.edu。我们能从起始状态，可以这么说，到达一个接受状态来决定，是的，这确实符合模式吗？好吧，让我们假设这个非确定性有限自动机看起来像这样。

我们将像以前一样从最左边的起始状态开始，我们将根据第一个边必须消耗一个字符，这个边标有一个点 `.`，表示我们可以消耗任何一个字符，比如 malan@harvard.edu 中的 m。然后我们可以花一些时间在 @ 符号之前消耗更多的字符，所以是 A-L-A-N。然后我们可以消耗 @ 符号。然后我们至少可以再消耗一个字符，因为回想一下这次的正则表达式是 `.+`。然后如果我们愿意，我们甚至可以消耗更多的字符。所以如果我们首先消耗 harvard.edu 中的 H，然后剩下 A-R-V-A-R-D，然后是点 E-D-U。现在，在这里，故事也结束了，但我们处于一个接受状态，因为末尾的那个圆圈总共有两个圆圈，这意味着如果计算机，如果这个函数，在读取完用户输入的全部内容后发现自己处于那个接受状态，那么它也确实是一个有效的电子邮件地址。相比之下，如果我们卡在了那些其他状态之一，无法跟随一个转换，即那些边之一，因此无法在用户的输入中从左到右取得进展，那么我们将不得不得出结论，该电子邮件地址实际上是无效的。

好吧，我们该如何进一步改进这段代码呢？我现在建议我们不仅检查用户名和用户名后面的东西，比如域名，还要最低限度地要求字符串以 .edu 结尾。

嗯，我认为我可以相当直接地做到这一点。我不仅希望 @ 符号后面有东西，比如像 Harvard 这样的域名，我还希望整个东西以 .edu 结尾。但这里有点危险。

```python
import re

email = input("What's your email? ").strip()

# 潜在的问题代码
# if re.search(".+@.+.edu", email):
#     print("Valid")
# else:
#     print("Invalid")
```

我现在以这种方式实现我的正则表达式，通过使用 `.+@.+.edu`，我做错了什么？这个版本可能会出什么问题？

**问：** （观众）点是——在这个上下文中，点意味着别的东西，它意味着一个字符的三次或更多次重复，这就是为什么它会解释它 [听不清]..
**答：** （David Malan）完全正确。尽管我的意思是它表示字面上的 `.edu`，一个句点，然后是 edu，不幸的是，在正则表达式的世界里，点 `.` 表示任何字符，这意味着这个字符串在技术上可以以 aedu、bedu 或 cedu 等结尾，但这实际上不是我想要的。

那么现在有什么直觉可以解决这个问题吗？让我更清楚地演示一下这个问题。让我运行这段代码。让我输入 malan@harvard.edu。像往常一样，这确实有效。但是请看这里会发生什么。让我输入 malan@harvard 然后——malan@harvard?edu，回车，那个也是有效的。所以我可以在那里放任何字符，它仍然会被接受。但我不想 `?edu`。我想要字面上的 `.edu`。

那么，有什么直觉可以解决这个问题吗？我怎样才能让这个新函数 `re.search` 和更一般的正则表达式，字面上表示一个点呢？你可能会怎么想？

**问：** （观众）你可以使用转义字符，反斜杠 `\`？
**答：** （David Malan）确实。所谓的转义字符，我们以前在正则表达式上下文之外讨论换行符时见过。`\n` 是一种告诉计算机我想要一个换行符的方式，而无需实际按 Enter 键并自己移动光标。而且你也不想在屏幕上显示一个字面的 n。所以 `\n` 是一种转义 n 并传达你想要一个换行符的方式。

事实证明，正则表达式使用类似的技术来解决这里的问题。事实上，让我进入我的正则表达式。在那个最后的点之前，让我放一个单个的反斜杠 `\`。在正则表达式的世界里，这是一个所谓的特殊序列。根据这个反斜杠和一个单个的点，它表明我字面上想要匹配一个点。并不是说我想要匹配任何字符然后是 edu。我想要匹配一个点，或者说句点，然后是 edu。

```python
# 修正后的模式（还需考虑原始字符串）
# ".+@.+\.edu"
```

但是我们不希望 Python 将这个反斜杠误解为开始一个转义序列，比如像 `\n` 这样特殊的东西，即使我们作为程序员可能输入两个字符反斜杠 n，它实际上被 Python 解释为单个换行符。我们不希望在这里出现任何类似的误解。所以事实证明，对于像这样使用了反斜杠的正则表达式，我们还应该做另一件事。我想向 Python 指定，我希望这个字符串，这个双引号内的正则表达式，被视为一个原始字符串（raw string），在字符串的开头字面上放一个 `r`，向 Python 表明你不应该尝试以通常的方式解释任何反斜杠。我希望字面上将反斜杠、点和 edu 传递给这个特定的函数，在这种情况下是 `search`。

```python
import re

email = input("What's your email? ").strip()

if re.search(r".+@.+\.edu", email):
    print("Valid")
else:
    print("Invalid")
```

所以这在精神上类似于在格式化字符串（format string）开头使用那个 `f`，当然，它告诉 Python 以某种方式格式化字符串，插入可能在花括号之间的变量。但在这种情况下，`r` 表示一个原始字符串，我希望它按原样传递进去。

现在，只有当你确实在使用反斜杠来表示你想要某个特殊序列，比如 `\.` 时，这才严格必要。但总的来说，养成对所有正则表达式都使用原始字符串的习惯可能是个好主意，这样如果你最终回去修改、添加内容，你就不会意外地引入一个反斜杠，然后忘记那可能有特殊的或被误解的含义。

好吧，让我试试这个新的正则表达式。我将清空我的终端窗口，运行 `python validate.py`。然后我将正确地输入我的电子邮件地址，malan@harvard.edu。幸运的是，这仍然有效。让我清空屏幕再运行一次，`python validate.py`。这次，让我们错误地输入为 malan@harvard?edu，其中显然没有点，但有某个其他单个字符，上次被误认为是有效的。但这次，既然我已经改进了我的正则表达式，它被发现确实是无效的。

现在对这种匹配 @ 符号左侧内容、右侧内容，并且现在明确以 .edu 结尾的技术有什么问题吗？

**问：** （观众）当用户插入多个 @ 符号时会发生什么？
**答：** （David Malan）好问题。你有点揭穿我了。嗯，有疑问时，我们就试试。让我运行 `python validate.py`，输入 malan@@@harvard.edu，这也是不正确的，不幸的是，我的代码认为它是有效的。所以这是另一个要解决的问题，但目前是一个缺点。

关于这些正则表达式，到目前为止还有其他问题吗？

**问：** （观众）你能用花括号 m 代替反斜杠吗？
**答：** （David Malan）你能用花括号代替反斜杠吗？在这种情况下不行。如果你想要一个字面上的点，`\.` 是字面上做这件事的方式。

关于正则表达式还有其他问题吗？

**问：** （观众）Google 表单（Google Forms）在对数据进行分类时使用的也是同样的东西吗，比如说，如果你有多个人发送关于某些反馈的请求？他们是否使用这种特定的正则表达式来对他们获得的数据进行分类？
**答：** （David Malan）确实。如果你曾经使用过 Google 表单，不仅仅是提交它，而是创建一个 Google 表单，其中一个菜单选项是用于响应验证（response validation），至少在英语中是这样。这允许你指定用户必须输入电子邮件地址、URL 或某种长度的字符串。但还有一个更强大的功能，你们中的一些人可能从未注意到。确实，如果你愿意打开 Google 表单，临时创建一个新表单，并四处看看，你实际上会看到，至少在英语中，提到了引号内的 "regular expression" 作为你可以用来验证用户输入到你的 Google 表单中的机制之一。所以事实上，今天之后你就可以开始避免像电子邮件地址、URL 之类的特定下拉菜单，你也可以精确地表达你自己的模式了。

正则表达式甚至可以在 VS Code 本身中使用。如果你在 VS Code 中查找或进行查找和替换，你当然可以只输入单词，就像你可以在 Microsoft Word 或 Google Docs 中做的那样。如果你勾选了正确的框，你也可以输入正则表达式，并开始搜索模式，而不是字面上的特定值。

## 五、 锚点与边界

好吧，让我建议我们现在通过引入一些其他符号来进一步增强这个实现，因为现在用我的代码，我一直说我希望我的电子邮件地址以 .edu 结尾并以用户名开头，但我有点太宽容了。

对于我自己的电子邮件地址 malan@harvard.edu，这确实按预期工作。但是如果我输入一个像这样的句子，“我的电子邮件地址是 malan@harvard.edu”，假设我把它输入到程序中或者输入到 Google 表单中？这会被认为是有效还是无效？

嗯，让我们考虑一下。它有 @ 符号，所以我们这方面没问题。它在 @ 符号左侧有一个或多个字符。它在 @ 符号右侧有一个或多个字符。它在 @ 符号右侧的某处有一个字面上的 `.edu`。诚然，右边还有更多的东西。字面上是我英语句子末尾的这个句点。但这没关系，因为目前，我的正则表达式并没有精确到说，模式必须以用户名开始并以 .edu 结束。技术上，它没有说明左边可以有什么更多内容，右边可以有什么更多内容。所以当我按回车键时，你会看到整个英语句子是有效的，这显然不是你想要的。

事实上，考虑一下使用 Google Forms 或 Office 365 从用户那里收集数据的情况。如果你不验证你的输入，你的用户很可能会输入一个完整的句子或其他带有排印错误的东西，而不是一个实际的电子邮件。所以如果你只是想复制所有输入到你表单中的结果，以便将它们粘贴到 Gmail 或某个电子邮件程序中，它会中断，因为你会意外地将像整个英语句子这样的东西粘贴到程序中，而不是仅仅一个电子邮件地址，那才是你的邮件程序所期望的。

那么我怎样才能更精确呢？好吧，让我建议我们再引入几个符号。事实证明，在正则表达式（这些模式之一）的上下文中，你可以使用脱字符号 `^`，那个小小的三角形标记，来表示你希望这个模式具体匹配字符串的开头——不是任何地方，而是用户字符串的开头。相比之下，你可以在你的正则表达式中使用美元符号 `$` 来表示你想要匹配字符串的结尾，或者技术上说是在字符串结尾的换行符之前。但就所有意图和目的而言，可以将 `^` 理解为表示“字符串的开头”，将 `$` 理解为表示“字符串的结尾”。一个是 `^` 一个是 `$`，这有点奇怪。这些并不是我认为像括号那样的反义词。但这就是世界多年前选择的符号。

所以现在让我回到 VS Code。让我把这个特性添加到我的代码中。让我指定，是的，我确实想要搜索这个模式，但我希望用户的输入以这个模式开始并以这个模式结束。所以即使它开始看起来更加神秘，我在这里的开头放一个脱字符号 `^`，在结尾放一个美元符号 `$`。

```python
import re

email = input("What's your email? ").strip()

if re.search(r"^.+@.+\.edu$", email):
    print("Valid")
else:
    print("Invalid")
```

这并不意味着我希望用户输入一个脱字符号或美元符号。这是特殊的符号系统，它向 `re.search` 表明，它现在只应该寻找与这个模式的精确匹配。

所以如果我现在回到我的终端窗口——我会把之前的结果留在屏幕上——让我输入完全相同的东西。“我的电子邮件地址是 malan@harvard.edu”，句号。现在我将按回车。现在这被认为是无效的了。但是让我清空屏幕。为了确保我没有弄坏东西，让我只输入我的电子邮件地址，那个也是有效的。

现在对这个版本的我的正则表达式有什么问题吗？注意，它更进一步地指定了更精确的要求，即我希望它在开头和结尾都匹配？对这个有什么问题吗？

**问：** （观众）好的。你有斜杠，然后是 .edu，然后是美元符号。但是点是正则表达式之一，对吧？
**答：** （David Malan）通常是。但是我故意放在这个句点之前的这个反斜杠 `\` 是一个转义字符。它是一种告诉 `re.search` 我不想要任何字符，我字面上想要一个句点的方式。这是区分两者的唯一方法。如果我去掉那个斜杠，这将意味着电子邮件地址只需要以任何字符结尾，然后是一个 E，然后是一个 D，然后是一个 U。我不想要那样。我想要字面上一个句点，然后是 E，然后是 D，然后是 U。

这实际上是编程和一般技术中常见的约定。如果你和我决定一个约定，即我们使用键盘上的某个字符来表示特殊含义，我们必然会为自己创造一个未来的问题，当我们想要字面上使用那个相同的字符时。因此，一般解决那个问题的方法是以某种方式转义该字符，以便计算机清楚地知道它不是那个特殊符号，而是它看到的字面符号。

**问：** （观众）所以我们甚至不需要——我们在美元符号前不需要另一个斜杠吗？
**答：** （David Malan）不需要。因为在这种情况下，美元符号 `$` 意味着特殊的东西。根据这张图表，美元符号 `$` 本身并不意味着美元或货币。它字面上意味着“匹配字符串的结尾”。然而，如果我希望用户字面上在他们输入的末尾输入美元符号 `$`，解决方案将是相同的。我会在美元符号 `$` 前面放一个反斜杠 `\`，这意味着我的电子邮件地址必须是像 malan@harvard.edu$ 这样，这显然也是不正确的。所以反斜杠 `\` 只是让你告诉计算机不要特殊对待那些符号，比如 `.` 意味着特殊的东西，而是字面上对待它们。

关于正则表达式，再提一个问题？

**问：** （观众）你说一个代表让它变成一加（one plus），然后你说一个是让它变成一个带没有（one with nothing）。
**答：** （David Malan）当然。
**问：** （观众）那你为什么还要加那个加号呢？
**答：** （David Malan）让我回溯一下时间。我想你指的是我们早期的一个版本，最初看起来像这样 `.*@.*`，只意味着零个或多个字符，然后一个 @ 符号，然后零个或多个其他字符。然后我们将其演变为这样 `.+@.+`，两边都是点加号，这意味着左边一个或多个字符，然后一个 @ 符号，然后右边一个或多个字符。如果我正确理解你的问题，我之前提出的观点之一是，如果你不使用加号 `+` 或者忘记了它的存在，你可以等效地用两个点和一个星号 `..*` 达到完全相同的结果，因为第一个点 `.` 意味着任何字符——它必须存在——第二个点星号 `.*` 意味着零个或多个其他字符，右边也一样。所以这只是表达相同想法的另一种方式。“一个或多个”可以用像 `..*` 这样表示，或者你可以只使用更方便的 `.+` 语法，它意味着相同的事情。

## 六、 字符集与字符类

好的。我敢说，当前形式的正则表达式仍然存在一些问题，因为即使现在我们开始在用户输入的字符串开头查找用户名，并且在用户输入的字符串末尾查找字面上的 `.edu`，那些点 `.` 现在有点过于包罗万象了。我被允许输入不止一个 @ 符号。为什么？因为 @ 是一个字符，而点 `.` 表示任何字符。所以老实说，目前我可以在这个东西里有任意多个 @ 符号。

例如，如果我运行 `python validate.py`，输入 malan@harvard.edu，仍然按预期工作。但如果我也运行 `python validate.py` 并错误地输入 malan@@@harvard.edu，这应该是无效的，但它却被认为是有效的。所以我认为我们需要在涉及到那个点 `.` 时更具限制性。我们不能只说，哦，任何旧字符在那里都可以。

我们需要更具体。嗯，事实证明，正则表达式也支持这种语法。你可以在你的模式内部使用方括号 `[]`，并在那些方括号内包含一个或多个你想要具体查找的字符。或者，你可以在那些方括号内放一个脱字符号 `^`，不幸的是，在这个上下文中，它的意思与“匹配字符串的开头”完全不同。但这将是方括号内的补集（complement）操作符，意思是“你不能匹配这些字符中的任何一个”。

所以事情现在看起来会更加神秘。但这就是为什么我们在这里单独关注正则表达式。如果我不想允许任何字符，也就是点 `.` 所代表的，让我继续，我可以只说，嗯，我只想支持 A、B、C、D、E、F、G。我可以在这里输入整个字母表加上一些数字，来实际包含所有我确实想允许的字母。

但老实说，有一个更简单的方法。我可以使用 `^` 符号然后一个 @ 符号，效果是说，这是包含除 @ 符号之外所有字符的字符集。我可以在这边做同样的事情。与其在 @ 符号右边用一个点 `.`，我可以做开方括号 `[`，`^` 符号，@ 符号，闭方括号 `]`。

```python
import re

email = input("What's your email? ").strip()

# 使用排除型字符集
if re.search(r"^[^@]+@[^@]+\.edu$", email):
    print("Valid")
else:
    print("Invalid")
```

我承认，事情开始迅速升级了，但让我们从左到右开始。这个在我字符串最开始的方括号外的 `^`，和以前一样，意味着“从字符串的开头匹配”。让我们跳到前面。正则表达式最末尾的美元符号 `$` 意味着“在字符串的结尾匹配”。所以如果我们可以在心理上把这些标记为直接了当的，让我们现在专注于中间的所有其他东西。

嗯，左边我们有新的语法——一个开方括号 `[`，另一个 `^` 符号，一个 @ 符号，和一个闭方括号 `]`，然后是一个 `+`。这个 `+` 和往常一样意味着相同的事情。它意味着“左边东西的一个或多个”。左边的东西是什么？嗯，这就是新的语法。在方括号 `[]` 里面，我有一个 `^` 符号然后一个 @ 符号。这只意味着除 @ 符号之外的任何字符。这是一个奇怪的语法，但这就是我们如何表达那个简单想法的方式——键盘上的任何字符，除了 @ 符号。甚至包括那些不在你物理键盘上但确实存在的其他字符。然后我们有一个字面的 @ 符号，然后我们有另一个同样的东西——方括号 `[`，`^@` 闭方括号 `]`，表示除 @ 符号之外的任何字符，然后是这些东西中的一个或多个，后面跟着字面上的句点 edu。

所以现在让我再做一次。让我重新运行 `python validate.py` 并测试我自己的电子邮件地址，以确保我没有让事情变得更糟。我们没问题。现在让我清空屏幕并再次运行 `python validate.py`，输入 malan@@@harvard.edu，这次祈祷一下。终于，这现在是无效的了。为什么？我允许自己在用户输入的中间有一个 @ 符号，但根据这个新语法，左边的所有内容都不能是 @ 符号。它可以是任何东西，但一个或多个。@ 符号右边的所有内容可以是任何东西，但不能是 @ 符号，一次或多次，最后跟着一个字面上的 `.edu`。

所以再说一次，新的语法非常简单——方括号 `[]` 允许你指定一组你在键盘上字面上输入的字符——A、B、C、D、E、F，或者是补集，相反的，`^` 符号，意思是“不是”，然后是你想要排除的一个或多个符号。

现在关于这里的语法有什么问题吗？

**问：** （观众）所以在 @ 符号之后，我们可以使用花括号 m 一次，这样我们只能有 @ 符号的一次重复吗？
**答：** （David Malan）当然可以。所以我们可以这样做。让我调出 VS Code。让我删除当前形式的正则表达式，回到我们开始的地方，那里只有 `.*@.*`。我绝对可以做类似这样的事情，并要求我在这里至少需要一个任何字符。然后我可以做更多的事情来拥有更多的字符。所以花括号语法，我们之前在幻灯片上看到但尚未使用，绝对可以用来指定特定数量的字符。但老实说，这比必要的更冗长。可以说最好的解决方案，或者至少最终最简单的，就是说 `.+`。但这又是另一个例子，说明你可以用多种方式解决同一个问题。

让我回到正则表达式刚才的位置，并接受其他问题。关于字符集或对该集取补集的问题？

**问：** （观众）那么你能用同样的语法来说，你不希望某个字符出现在整个字符串中吗？
**答：** （David Malan）你可以。这将是——你绝对可以使用相同的语法来从整个字符串中排除某个字符。但现在会有点困难，因为我们仍然要求结尾是 `.edu`。但是的，绝对可以。

其他问题？

**问：** （观众）如果用户在字符串开头输入 .edu 会发生什么？
**答：** （David Malan）好问题。如果用户在字符串开头输入 .edu 会发生什么？嗯，让我回到 VS Code。让我们尝试用两种不同的方式来解决这个问题。首先，让我们看看正则表达式，看看我们是否能推断出那是否会被容忍。嗯，根据当前神秘的正则表达式，我说你可以有除 @ 符号之外的任何字符。所以 .edu 的点 `.` 是可以的。但是接着我必须有一个 @ 符号。所以这并不能真正起作用，因为如果我只输入 .edu，我们将无法通过那个约束。

所以现在让我通过运行程序来试试。让我只输入字面上的 `.edu`。这不起作用。但是，但是，但是我可以这样做，`.edu@.edu`。那个也是无效的。但是让我这样做，`.edu@something.edu`。那个通过了。所以现在开始有点奇怪了。也许它是有效的，也许不是。但我认为我们最终也会更精确。

关于这个正则表达式和这些集合的补集，再提一个问题？

**问：** （观众）我们可以在字符串输入中使用另一个域名吗？
**答：** （David Malan）你能使用另一个域名吗？当然可以。我只是为了演示而使用我自己的。但你绝对可以使用任何域名或顶级域名。我用的是 .edu，这非常以美国为中心。但这对于任何顶级域名来说，绝对会完全一样地工作。

好的。现在让我建议我们进一步改进这个正则表达式，因为如果我再次在 VS Code 中调出它，你会看到我仍然有点太宽容了。事实证明，对于某人的用户名和电子邮件地址中的域名有一些要求。世界上有一个关于电子邮件地址可以是什么以及其中可以包含哪些字符的官方标准。而 `[^@]+` 对除 @ 符号之外的所有字符都过于包容了。所以让我们实际上缩小我们将在用户名中容忍的范围。

像 Gmail 这样的公司当然也可以这样做。假设我不仅仅想排除 @ 符号。假设我只想允许，比如说，通常出现在单词中的字符，比如字母表中的字母，A 到 Z，无论是大写还是小写，也许一些数字，甚至，也许下划线也可以被允许。

嗯，我们可以使用同样的方括号语法来指定一组字符，如下所示。我可以做 abcdefghij——哦，天哪。这将花费很长时间。我将不得不输入字母表中所有 26 个字母，小写和大写。所以让我停止这样做。已经有更好的方法了。如果你想在这些方括号内指定一个字母范围，你实际上可以只用一个连字符 `-`。如果你在这些方括号里字面上做 `a-z`，计算机会知道你的意思是 a 到 z。你不需要输入字母表中 26 个字母。如果你想也包括大写字母，你只需做同样的事情。没有空格，没有逗号，你字面上只是继续输入 `A-Z`。所以我这里有小写 a 连字符小写 z，大写 A 连字符大写 Z。没有空格，没有逗号，没有分隔符。你只是继续指定那些范围。如果我还想要数字，我可以做 01234——不。你不需要输入所有 10 个十进制数字。你也可以只用连字符说 0 到 9。现在如果你想也支持下划线，这在电子邮件地址的用户名中很常见，你可以字面上只在末尾输入一个下划线 `_`。

```python
import re

email = input("What's your email? ").strip()

# 使用具体的字符集
if re.search(r"^[a-zA-Z0-9_]+@[a-zA-Z0-9_]+\.edu$", email):
    print("Valid")
else:
    print("Invalid")
```

请注意，所有这些字符都在方括号 `[]` 内部，这再次只意味着，这是我想要允许的一组字符。我没有在整个事情的开头使用 `^` 符号，因为我不想对它取补集——用 E 的 complement，不是用 I 的 compliment——我不想通过让它变成相反的来补充它。我字面上只想接受这些字符。

我将在右边做同样的事情。如果我要求域名同样来自这组字符，这诚然有点太窄了，但目前我们熟悉它，所以我们保持简单，我将把完全相同的字符集粘贴到右边那里。

所以现在，它更具限制性了。现在我将运行 `python validate.py`。我将测试我自己的电子邮件地址，我们仍然没问题。我将清空屏幕再运行一次，这次尝试破坏它。让我做一些像这样的事情，比如，david_malan@harvard.edu，回车，那个也是有效的。但如果我再次做一些完全错误的事情，比如 malan@@@harvard.edu，那仍然将是无效的。为什么？因为我的正则表达式目前只允许中间有一个 @，因为左边的所有内容必须是字母数字（字母或数字）或下划线，右边也是同样的东西，后面跟着 `.edu`。

现在老实说，这是一个你可能在现实世界中习惯输入的正则表达式。尽管这看起来可能很神秘，但这就是正则表达式的世界。所以随着时间的推移，你会对这种语法更加熟悉。

但幸运的是，其中一些模式非常常见，以至于有内置的快捷方式来表示一些相同的信息。也就是说，你不必经常输入所有你想要包含的符号，因为很可能其他程序员也遇到过同样的问题。所以正则表达式本身内置了一些你可以使用的附加模式。

事实上，我可以去掉整个这个集合，a 到 z 小写，A 到 Z 大写，0 到 9 和一个下划线，然后只用一个单个的反斜杠 `w` (`\w`) 来替换它。在这种情况下，`\w` 代表一个“单词字符”（word character），通常被称为字母数字符号或下划线。

我将在这里做同样的事情。我将高亮显示整个方括号集，删除它，并用单个的反斜杠 `w` (`\w`) 替换它。

```python
import re

email = input("What's your email? ").strip()

# 使用 \w 字符类
if re.search(r"^\w+@\w+\.edu$", email):
    print("Valid")
else:
    print("Invalid")
```

现在我觉得我们正在取得进展，因为即使它很神秘，并且不久前看起来更神秘——现在它至少开始读起来更友好一些了。左边的 `^` 意味着“从字符串的开头开始匹配”。反斜杠 `w` (`\w`) 意味着“任何单词字符”。`+` 意味着“一个或多个”。字面上的 @ 符号。然后是另一个单词字符，一个或多个。然后是一个字面上的点，然后是字面上的 edu，然后在字符串的最末尾匹配，就这样。

所以还有更多这样的东西。我们不会在这里全部使用它们，但这里是你在正则表达式中可以使用的模式的部分列表：
一，你有 `\d` 用于任何十进制数字，“十进制数字”意味着 0 到 9。
同样，通常在这里做的是，如果你想做相反的事情，补集，可以这么说，你可以做反斜杠大写 D (`\D`)，这是任何不是十进制数字的东西。所以它可能是字母、标点符号和其他符号。
同时，反斜杠 `s` (`\s`) 表示空白字符，比如单个空格，或者键盘上的 Tab 键。那是空白。反斜杠大写 S (`\S`) 是它的相反或补集——任何不是空白字符的东西。
反斜杠 `w` (`\w`)，我们已经看到了，一个单词字符，以及数字和下划线。如果你想要它的补集或相反，你可以使用反斜杠大写 W (`\W`) 来得到除单词字符之外的所有东西。

再说一次，这些只是非常常见的模式，以至于许多人大概在过去都在使用，所以它现在被烘焙到正则表达式语法中，以便你可以更简洁地表达你相同的想法。

那么，对于这种方法，现在有什么问题吗？这里我们现在使用 `\w` 来代表我的单词字符？

**问：** （观众）所以我想问的是关于——实际上是之前的方法，就是方括号方法。我们可以在里面接受列表吗？
**答：** （David Malan）是的。我们稍后会看到这个。但假设你不仅想容忍 .edu，也许还想容忍 .edu 或 .com，你可以这样做。你可以引入括号 `()`，然后你可以将它们用“或”连接起来。我可以写 `(com|edu)`。也可以在美国加入像 gov 或 net，或其他任何东西，或 org 之类的。这里的每个竖线 `|` 都意味着特殊的东西。它意味着“或”。而括号 `()` 只是将事物组合在一起。

正式地，你有这个语法——A 或 B，A 竖线 B (`A|B`)，意味着“A 必须匹配或 B 必须匹配”，其中 A 和 B 可以是你想要的任何其他模式。在括号 `()` 中，你可以将那些东西组合在一起。所以就像数学一样，你可以将想法组合成一个短语，做这个或那个。还有其他我们很快会看到的语法。

关于这些正则表达式和这里的语法还有其他问题吗？

**问：** （观众）如果我们在表达式中加入空格会怎样？
**答：** （David Malan）当然。所以如果你想在里面加入空格，你不能单独使用 `\w`，因为那只是单词字符，也就是字母、数字或下划线。但你可以这样做。你可以回到使用方括号 `[]` 的方法。你可以说 a 到 z，或 A 到 Z，或 0 到 9，或下划线，或我按一下空格键，一个单个空格。你可以在方括号 `[]` 内放入一个字面上的空格，这将允许你检测到一个空格。

或者，我仍然可以使用 `\w`，但我可以像这样组合它。我可以写，给我一个 `\w` 或一个 `\s` (`(\w|\s)`)，因为回想一下 `\s` 是空白。所以它甚至不仅仅是单个空格。它可能是制表符。但是通过将那些东西放在括号 `()` 里，现在你可以匹配左边的东西或右边的东西，一次或多次。

关于这些正则表达式，再提一个问题？

**问：** （观众）太好了。所以我想问，`\w` 是否包含点？因为——不，好的。
**答：** （David Malan）不，它只包含字母、数字和下划线。就是这样。
**问：** （观众）我想知道，你一开始给了一个例子，里面有空格，比如“这是我的邮件，某某”。我认为我们当前的版本——甚至是很久以前的版本就停止接受它了。那是因为 `^` 还是因为别的什么？
**答：** （David Malan）不，当我输入我的电子邮件地址为 malan@harvard.edu 时，我处理空格和其他英语单词的原因是，我们最初使用的是 `.*` 或 `.+`，它们表示任何字符。甚至在那之后，我们说除了 @ 符号之外的任何东西，这也包括空格。只有当我开始使用方括号 `[]` 和 a 到 z、0 到 9 以及下划线时，我们才最终到了会拒绝空白的地步。

事实上，我可以在这里运行这个。让我进入 VS Code 中我代码的当前版本，它再次使用 `\w` 来表示单词字符，让我运行 `python validate.py` 并错误地输入像 "my email address is malan@harvard.edu." 这样的东西，句号，它在我的用户名左边有空格，现在那是无效的，因为空格不是单词字符。

你也会注意到，技术上我不允许点。你们中的一些人可能在想，等等。我的 Gmail 地址里有一个点。这是我们仍然需要修复的问题。`\w` 在这里并不是万能的。它只是让我们能够更简洁地表达我们之前的解决方案。

## 七、 标志位（Flags）

现在，我们仍然没有正确处理的一个问题是大小写。`\w` 技术上确实处理小写字母和大写字母，因为它与之前那个包含小 a 到小 z 和大 A 到大 Z 的集合完全相同。但是请看这个。

让我以当前形式运行 `python validate.py`，仅仅因为我的 Caps Lock 键被按下了，输入 MALAN@HARVARD.EDU，大声喊出我的电子邮件地址。就 MALAN 而言，没问题。就 HARVARD 而言，也没问题，因为那些都匹配 `\w`，它确实包含小写和大写。但我即将看到无效。为什么？

为什么 MALAN@HARVARD.EDU 在这里全大写时是无效的，即使我使用了 `\w`？

**问：** （观众）是的。所以你要求域名 .edu 是小写的，而你输入的是大写的。
**答：** （David Malan）完全正确。我输入的是全大写的电子邮件地址，但我查找的是字面上的 ".edu"。当我看到你戴着 AirPods 以及你们这么多人戴着耳机时，我为刚才对着麦克风大喊大叫来强调这一点表示歉意。但让我们看看我们是否能解决这个问题。

嗯，如果我在第 5 行的模式期望它是小写的，实际上有几种方法可以解决这个问题。一种是我们以前见过的。我可以强制用户的输入全部变为小写。我可以在我第一行的末尾加上 `.lower()`，实际上强制它全部变为小写。或者，我可以稍后再做。与其传入 `email`，我可以传入 `email` 的小写版本，因为电子邮件地址实际上应该是大小写不敏感的。所以那也行。

但这里还有另一种机制，值得一看。事实证明，之前那个名为 `re.search` 的函数支持，回想一下，第三个参数，即所谓的标志（flags）。标志是配置选项，通常用于函数，允许你以稍微不同的方式配置它。我该如何在我目前只传递两个参数的情况下，稍微不同地配置对 `re.search` 的这次调用呢？

嗯，事实证明，一些你可以传递给这个函数的标志是这些。事实证明，Python 中的正则表达式库，也就是 `re`，带有一些内置的变量，可以这么说，你可以认为是常量，它们对 `re.search` 有意义。它们的作用如下。

如果你作为标志传入 `re.IGNORECASE`，`re.search` 将做的是忽略用户输入的大小写。它可以是大写、小写，或两者的组合，大小写将被忽略。它将被视为大小写不敏感。

你也可以做其他事情，我们在这里不会做。但如果你想处理可能跨越多行的用户输入——也许他们不只是输入了一个电子邮件地址，而是一整段文本，你想匹配该文本的不同行，即多行。另一个标志是用于此的 `re.MULTILINE`，或者 `re.DOTALL`，通过它你可以配置点 `.` 来识别不仅是除换行符外的任何字符，而且是任何字符加上换行符。

但现在，让我继续只使用第一个。让我给 `re.search` 传入第三个参数，即 `re.IGNORECASE`。

```python
import re

email = input("What's your email? ").strip()

if re.search(r"^\w+@\w+\.edu$", email, re.IGNORECASE):
    print("Valid")
else:
    print("Invalid")
```

现在让我重新运行程序，不清空屏幕，`python validate.py`。让我再次用全大写输入，实际上是在喊，MALAN@HARVARD.EDU，回车，现在它被认为是有效的了，因为我明确告诉 `re.search` 忽略输入的大小写。这里那也没问题。

为什么我可能采用这种方法而不是在其他某个位置调用 `.lower()` 呢？嗯，如果我出于某种原因实际上不想更改用户的输入，我仍然可以在不实际更改该变量本身的值的情况下，将其视为大小写不敏感。

## 八、 分组与捕获

好的，关于验证电子邮件地址，最后还有什么问题吗？

**问：** （观众）所以模式是一个字符串，对吧？
**答：** （David Malan）嗯哼。
**问：** （观众）我们可以使用 f 字符串吗？
**答：** （David Malan）可以。是的，你可以使用 f 字符串，这样你就可以插入，例如，一个变量的值，并将其传递给函数。

关于这个还有其他问题吗？

**问：** （观众）反斜杠 w (`\w`) 字符，我们可以将其作为用户的输入吗？
**答：** （David Malan）技术上可以。这不是我们现在试图解决的问题。我们希望用户提供字面输入，比如他们的电子邮件地址，而不一定是正则表达式。但你可以想象构建软件，要求用户，特别是如果他们是更高级的用户，输入一个正则表达式，用于某种原因来验证其他东西。事实上，这就是 Google 在做的。如果你玩玩 Google 表单并创建一个带有响应验证的表单，并选择正则表达式，Google 允许你我输入我们自己的正则表达式，这将是那个场景的一个完美例子。

好的。好吧，让我建议我们尝试解决这里的另一个问题，即如果我进入和之前相同的版本，现在忽略了大小写，但我输入我的另一个电子邮件地址。让我运行 `python validate.py`。这次，让我输入不是 malan@harvard.edu（我主要使用的那个），而是我的另一个电子邮件地址，malan@cs50.harvard.edu，它转发到同一个地址。我现在按回车。嗯，无效，尽管我很确定我确实从那个地址发送和接收电子邮件。

好吧，让我们找出原因。为什么目前 malan@cs50.harvard.edu 被认为是无效的，即使我很确定我也从那个地址发送和接收邮件？那可能是为什么？

**问：** （观众）因为在 @ 符号之后出现了一个点。
**答：** （David Malan）完全正确。在我的 cs50 后面有一个点。而我不期望那里有任何点，我只期望，再说一次，单词字符 `\w`，也就是 A 到 Z，0 到 9，和下划线。所以我将不得不重新调整。

但我该如何做到这一点呢？嗯，事实证明，理论上，可能存在其他电子邮件地址，即使它们会变得有点过长，例如，malan@something.cs50.harvard.edu，这个技术上不存在，但它可能存在。当然，你可以在域名中包含多个点，就像我们在这里看到的那样。如果我们也能处理那个就好了，不是吗？

好吧，让我建议我们按如下方式修改我的正则表达式。事实证明，你可以将想法组合在一起。你不仅可以问这个模式是否匹配或那个模式是否匹配，使用像 A 竖线 B (`A|B`) 这样的语法，意思是“A 或 B”，你还可以将事物组合在一起，然后对它们应用一些其他操作符。

事实上，让我回到代码。我建议，如果我想容忍像 cs50 这样的子域名，它可能存在也可能不存在，让我按如下方式更改它。我可以天真地这样做。如果我想支持子域名，我可以说，嗯，让我们允许其他的单词字符 `\w+`，然后是一个字面上的点 `\.`。注意，我将用蓝色高亮显示我刚刚添加的内容。其他所有内容都相同，但我现在为另一个一个或多个单词字符的序列然后一个字面上的点添加了空间。

```python
# 尝试支持子域名（会导致新问题）
# if re.search(r"^\w+(\.\w+)+@\w+\.edu$", email, re.IGNORECASE):
# 注意：这里为了简化，先假设子域名部分必须有，稍后会修正为可选
# 更准确的初步尝试可能是 r"^\w+@\w+\.\w+\.edu$"
# 或者，更接近意图：r"^\w+@(\w+\.)+\w+\.edu$" (允许多级子域)
# 讲座中的意图是先添加一个子域部分：
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE): -- 这不完全对，因为它强制了一个子域和一个主域
# 讲座中实际添加的是在 @ 之后加 `\w+\.` :
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE): # 这还是不对
# 让我们遵循讲座的逻辑，假设添加的是这部分：
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE):
# 不，讲座是这样添加的:
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE):
# 原始是: r"^\w+@\w+\.edu$"
# 添加子域尝试: r"^\w+@\w+\.\w+\.edu$" 这强制了两层.
# 讲座实际添加的是 `\w+\.` 放在 `@` 和 `\w+` 之间：
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE): # 还是不对
# 让我们重新看视频 1:02:48 左右的修改：
# 他在 `@\w+` 之后，`\.edu` 之前，添加了 `\w+\.`
# 原始：r"^\w+@\w+\.edu$"
# 修改后：r"^\w+@\w+\.\w+\.edu$" # 这似乎还是要求两级域名
# 啊，我理解错了视频里的操作。他是在 `@` 和 `\w+\.edu` 之间插入了 `\w+\.`，所以模式变成了：
# r"^\w+@\w+\.\w+\.edu$"
# 让我们假设这是他的意图，即使这在逻辑上强制了 domain.subdomain.edu 结构，这可能不是他最初想做的，但这是导致后续问题的步骤。
# 不，再看一遍，他是在 `\w+\.edu` 的 `\w+` 之前加了 `\w+\.`
# 原始： `^\w+@\w+\.edu$`
# 修改后: `^\w+@(\w+\.)\w+\.edu$`  (我加了括号以明确添加的部分)
# 他实际写的是: `^\w+@\w+\.\w+\.edu$` 这个模式看起来确实强制了 subdomain.domain.edu
# 让我们按照这个错误的步骤走，因为它引出了可选性的需求
# 假设模式变成：
# if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE):

# 为了反映视频中的代码演变，我们先用这个（虽然逻辑上不完美，但它会导致需要 `?` 的问题）：
# 他添加的是 `\w+\.` 这部分，使得模式需要匹配类似 `name@sub.domain.edu`
if re.search(r"^\w+@\w+\.\w+\.edu$", email, re.IGNORECASE): # 模拟视频中的临时错误状态
    print("Valid")
else:
    print("Invalid")

```

所以这个现在，我认为，如果我重新运行 `python validate.py`，对于 malan@cs50.harvard.edu 将会有效，回车。不幸的是，有人看到这将走向何方吗？让我重新运行 `python validate.py` 并像我一直做的那样输入 malan@harvard.edu，这个直到现在，尽管我做了所有更改，都一直有效。但现在，啊，终于我弄坏了我自己的电子邮件地址。

所以逻辑上这里的解决方案是什么？嗯，有很多方法可以解决这个问题。我也许可以开始使用两个正则表达式，并支持格式为 `username@domain.tld` 的电子邮件地址，或者 `username@subdomain.domain.tld`，其中 TLD 只表示顶级域名，比如 edu。或者我也许可以只修改这一个，因为我不想有两个正则表达式或者一个两倍大的。为什么我不向 `re.search` 指定这个模式的一部分是可选的呢？

我们之前看到的允许你指定它前面的东西在技术上是可选的符号是什么？

**问：** （观众）是竖线吗？我们用竖线作为——可选，使参数可选。
**答：** （David Malan）所以我们可以。我们可以使用竖线 `|` 和一些括号 `()` 并说，“要么这里有东西，要么什么都没有”。我们可以在括号里这样做。但我认为实际上有更简单的方法。
**问：** （观众）实际上，是问号 `?`。
**答：** （David Malan）确实，问号 `?`。回想一下我们第一组符号的这个总结，其中我们不仅有点 `.` 和星号 `*` 和加号 `+`，还有一个问号 `?`，它字面上意味着“零次或一次重复”，这实际上意味着可选。它要么在那里，一次，要么不在，零次。

现在，我该如何将其转换到这里的代码中呢？好吧，让我继续用括号 `()` 包围我模式的这一部分 `(\w+\.)`，这并不意味着我希望用户输入中有字面上的括号，我只是想将这些字符组合在一起。事实上，这现在仍然会起作用。我只是在子域名的新部分周围添加了括号。让我运行 `python validate.py`。让我运行 malan@cs50.harvard.edu，回车。那仍然有效。但需要明确的是，如果我再次为 malan@harvard.edu 运行它，那仍然是无效的，但如果我进入这里，在括号 `()` 后面——现在它是一个逻辑单元，它是一大组想法组合在一起——我在那里添加一个单个的问号 `?`。

```python
import re

email = input("What's your email? ").strip()

if re.search(r"^\w+@(\w+\.)?\w+\.edu$", email, re.IGNORECASE):
    print("Valid")
else:
    print("Invalid")
```

这现在将告诉 `re.search`，括号 `()` 里的整个东西要么可以在那里一次，要么根本不在那里，零次。

那么当我运行它时，这会转换成什么呢？好吧，让我继续用 malan@cs50.harvard.edu 重新运行它，这样子域名就在那里了。那像以前一样工作。让我清空屏幕再运行一次，`python validate.py` 用 malan@harvard.edu，它以前有效然后坏了。我们现在回到正轨了吗？我们是。那现在又有效了。

现在对这种方法有什么问题吗？这里我们不仅使用了问号 `?`，还使用了括号 `()`？

**问：** （观众）是的。你说它适用于零次或一次重复。如果你有更多次怎么办？
**答：** （David Malan）如果你有更多次怎么办？没关系。那是你可以用星号 `*` 的地方。星号 `*` 是零次或更多次，它给了你世界上所有的灵活性。
**问：** （观众）是的。所以我只是在问那个——用问号，只允许一次重复。
**答：** （David Malan）它意味着零次或一次重复。所以它要么不在那里，要么在那里。这就是为什么这个模式现在，如果我回到我的代码，即使再次承认它看起来很神秘，让我高亮显示 @ 符号之后和美元符号 `$` 之前的所有内容。这现在代表一个域名，比如 harvard.edu，或者域名内的子域名。为什么？嗯，右边的这部分和以前一样。`\w+` 意味着像 Harvard 或 Yale 这样的东西。`\.edu` 意味着字面上的 ".edu"。所以新的部分是这个 `(\w+\.)?`。在括号 `()` 里，我现在有另一组 `\w+\.`。但它全在括号里。我现在紧随其后有一个问号 `?`，这意味着括号 `()` 里的整个东西要么可以在那里，要么不能在那里。两者都是可接受的。所以问号 `?` 实际上使某物成为可选的。

移除括号是不正确的，因为这会意味着什么？如果我移除括号，那将意味着只有这个点 `.` 是可选的，这并不是我们真正想要表达的。我想要子域名，比如 cs50 和额外的点，是存在或不存在的东西。

关于这里的正则表达式，再提一个问题？

**问：** （观众）我们可以将其用于用户名吗？
**答：** （David Malan）当然可以。我们仍然有其他问题。我们今天还没有解决所有问题。但绝对可以。现在，我们不允许你的用户名中有点。再说一次，你们中一些有 Gmail 帐户或其他帐户的人，你们可能不仅有下划线、数字和字母。你们可能也有句点。

嗯，我们可以解决这个问题，不一定在这里用问号 `?`。但既然我们现在有了这些括号 `()` 可用，我可以这样做。我可以使用括号 `()` 来包围 `\w` (`(\w)`)，表示“任何单词字符”，这再次与字母、数字或下划线相同。但我也可以用竖线 `|` 或入其他东西，比如一个字面上的点 `\.` (`(\w|\.)`)。现在，一个字面上的点需要被转义，否则它代表任何字符，这将是一个倒退，退一步。

但现在请注意我做了什么。在括号 `()` 里，我告诉 `re.search`，你电子邮件地址中的那些最初的几个字符，也就是你的用户名，必须是一个单词字符，比如 A 到 Z，大写或小写，或 0 到 9，或下划线，或者一个字面上的点。

我们也可以不同地做这件事。我可以去掉括号 `()` 和或 `|`，我可以只使用一个字符集 `[]`。我可以再次手动说 a 到 z，A 到 Z，0 到 9，下划线，然后我可以用反斜杠句点 `\.` 来做一个字面上的点 (`[a-zA-Z0-9_\.]`)。现在我技术上甚至不需要大写字母了，因为我已经告诉计算机忽略大小写。我可以只选择其中一个。

```python
# 允许用户名中包含点（使用字符集）
# if re.search(r"^[a-z0-9_\.]+@(\w+\.)?\w+\.edu$", email, re.IGNORECASE):
```

哪个更好真的取决于你。你认为哪个更易读通常就是更好的设计。

好的。让我建议我将时间倒回到我们结束的地方，也就是这里。让我提出，这个解决方案确实仍然存在局限性，不仅仅是在用户名方面，也不仅仅是在域名方面。我们仍然有点过于限制了。

那么你想看看至少现在浏览器在你向网页表单输入电子邮件地址时使用的官方正则表达式吗？然后网页表单，浏览器，会告诉你，是或否，你的电子邮件地址在语法上是有效的？准备好了吗？

**电子邮件地址验证 (复杂示例)**

准备好了吗？这就是——这甚至不是官方正确的正则表达式。这是一个简化的版本，浏览器现在使用它，因为它能捕捉到大多数错误，但不是全部。

来了。这就是有效电子邮件地址的正则表达式，至少是现在浏览器实现它的方式。

```regex
# (此处展示或引用那个非常复杂的HTML5 email regex)
# 例如（简化示意，非实际标准）:
# ^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$
```

现在乍一看它极其神秘。但请注意——它换行到了很多行，但它只是一个模式。但请注意现在熟悉的符号。最顶部有 `^` 符号。最末尾有 `$` 符号。这边有一个方括号 `[`，然后是一些这些范围加上其他字符。事实证明，你通常在电子邮件地址中看不到这些字符。看起来像你在某人的用户名里骂人。但它们是有效的字符。它们是官方有效的。这并不意味着 Gmail 会允许你在你的用户名中放入美元符号 `$` 和其他标点符号。但官方来说，一些服务器可能允许那样做。

所以如果你真的想验证用户的电子邮件地址，你实际上会想出或者复制粘贴像这样的东西。但老实说，这看起来太神秘了。如果你要手动输入它，你非常有可能出错。这里更好的解决方案是什么呢？

这就是，根据过去几周的内容，库是你的朋友。肯定互联网上的其他人，一个比你更有经验的程序员，甚至，已经想出了能正确验证电子邮件地址的代码，使用这个正则表达式或者甚至比那更复杂的东西。所以总的来说，如果手头的问题是验证非常常规的输入——电子邮件地址、URL，这些有独立于你自己的官方定义的东西——找到一个你用得舒服的流行库，并在你的代码中使用它来验证电子邮件地址。这不一定是你自己应该发明的轮子。不过，我们使用电子邮件地址来迭代地从简单、过于简单的东西开始，并在此基础上构建。所以你当然可以想象仍然使用正则表达式来验证不是电子邮件地址但对你来说很重要的数据。所以我们至少现在有了这些构建块。

## 十、 正则表达式的实际应用

现在，除了正则表达式本身，

**`match`, `fullmatch` 函数**

事实证明，Python 的 `re` 库中还有其他用于正则表达式的函数。其中包括这里的这个函数，`re.match`，它实际上与 `re.search` 非常相似，只是如果你想从字符串的开头匹配，你就不必在你的 regex 最开始指定 `^` 符号了。`re.match` 设计上会自动从字符串的开头开始为你匹配。精神上类似的是 `re.fullmatch`，它做同样的事情，但不仅在字符串的开头匹配，还在字符串的结尾匹配，这样你也不需要输入 `^` 符号或 `$` 符号了。

**数据清理与格式化 (`format.py` 示例)**

但让我们现在转换回一些实际的代码，在这里我们精神上解决一个不同的问题。与其只是验证用户的输入并确保它看起来是我们想要的样子，不如让我们假设用户不会完全按照我们想要的方式输入数据，所以我们将不得不清理他们的输入。

当你使用像 Google 表单、Office 365 表单或任何其他东西来收集用户输入时，这种情况经常发生。无论你的表单问题怎么说，你的用户不一定会遵循那些指示。他们可能会输入一些格式与你希望的略有不同的东西。

现在，你当然可以浏览结果并下载 CSV，或者打开 Google 电子表格，或者 Excel 中的等效文件，然后手动清理所有数据。但如果你的数据集里有很多提交——几十、几百、几千行——手动做事情可能不太有趣。使用代码，比如 Python，可能会更有效，它可以让你清理那些数据以及任何未来的数据。

所以让我建议我们在这里继续，关闭 `validate.py`。让我们创建一个全新的程序，叫做 `format.py`，它的目标是将用户的输入重新格式化为我们期望的格式。

我将运行 `code format.py`。假设我们要重新格式化的数据是用户的名字——所以这次不是电子邮件地址而是名字。我们希望他们正确地输入他们的名字，比如 David Malan。但有些用户可能出于某种原因习惯于反向输入他们的名字，用逗号分隔，比如 Malan, David。现在，这没关系，因为两者对人类来说显然都同样可读。但如果你想标准化这些名字在你的系统中的存储方式，也许是数据库、CSV 文件或其他东西，至少标准化或规范化你存储数据的格式会很好，这样如果你打印出用户的名字，它总是相同的格式，David Malan，没有逗号或反向。

所以让我们做一些熟悉的事情。让我们给自己一个名为 `name` 的变量，并将其设置为 `input` 的返回值，像我们做过很多次那样问用户，“你的名字是什么？”问号。我将主动地至少清理一些混乱，就像我们一直在这里做的那样，只去掉任何前导或尾随空格。以防用户意外地按了空格键，我们最终不希望那个出现在我们的数据集中。

现在让我继续像我们以前做的那样。让我快速地打印出来，只是为了确保我开局正确，“hello,” 然后在花括号里是 `name`，所以做一个 f 字符串来格式化 "hello, name"。

```python
name = input("What's your name? ").strip()
print(f"hello, {name}")
```

现在让我清空屏幕并运行 `python format.py`。我会表现得规矩些，像我通常那样输入我的名字，David，空格，Malan，回车。我认为输出看起来相当不错。它看起来符合语法预期。

现在让我再玩一次这个游戏。但这次，也许因为我没在思考，或者我只是习惯于姓氏逗号名字的格式，我输入 Malan, David，然后按回车。好吧。现在这很奇怪。即使程序只是把我输入的内容原样输出，可以说这至少在语法上离正确还差得远。它真的应该说 "hello, David Malan"。

现在，我也许可以有一些 `if` 条件，如果用户输入了逗号或者不知何故把名字搞反了，我可以拒绝用户的输入。但这会太迟了，如果用户已经在网上提交了表单，我已经有了数据，现在我需要进去清理它。在 Google Spreadsheets、Apple Numbers 或 Microsoft Excel 中手动遍历并修正很多人的名字，去掉逗号并将名字移到姓氏前面（在美国这是惯例），这并不有趣。

所以让我们这样做。它可能有点脆弱，但让我们开始在这里用编程的方式表达自己，并问这个问题。如果人名中有一个逗号 `if "," in name:`，这是 Pythonic 的——我只是在问，这个较短的字符串是否在这个较长的字符串中？——那么让我继续这样做。让我获取变量中的那个名字，用不仅仅是逗号，还有后面的空格来分割 `name.split(", ")`，假设用户在他们的名字后面输入了一个空格。让我把分割 Malan, David 的结果存储到两个变量中。让我们做 `last, first = name.split(", ")`，再次解包返回的值序列。

现在让我继续重新格式化名字。所以我会强制性地将用户的名字更改为我期望的样子。所以 `name` 实际上将是这个格式化字符串——`f"{first} {last}"`，名字然后姓氏，都在花括号里，但用单个空格格式化在一起，这样我就覆盖了用户的输入并相应地更新了我的 `name` 变量。

```python
import re # (后面会用到 re, 先放着)

name = input("What's your name? ").strip()

if "," in name:
    last, first = name.split(", ")
    name = f"{first} {last}"

print(f"hello, {name}")
```

目前，需要明确的是，这个程序是交互式的。比如用户，像我，正在将他们的名字输入到程序中。但想象一下数据已经在 CSV 文件中了。它来自某个过程，比如 Google 表单或其他在线的东西。你可以想象编写类似这样的代码，但也许它会先去读取那个文件到内存中。也许它是通过 CSV Reader 或 DictReader 的 CSV 文件，然后遍历每个名字。但我们会保持简单，一次只处理一个名字。

但现在有点有趣的是，如果我回到我的终端窗口，清空它，运行 `python format.py`，并按回车，我将像以前一样输入 David, space, Malan。我认为我们仍然没问题。但我也将这样做——`python format.py Malan, comma, David`，中间有一个空格，祈祷并按回车，瞧。那个现在被修正了。

当然，这只是一个简单的事情。但清理用户输入是如此普遍的必要。在这里我们至少看到了一种相当容易做到这一点的方法。

现在，公平地说，这里有一些问题。事实上，有人能想象一个场景，这段代码实际上并没有修正用户的输入吗？即使有了我代码中的这个修正，还可能出什么问题？有什么想法吗？

**问：** （观众）如果他们输入了他们的名字逗号然后 [听不清]..
**答：** （David Malan）哦，然后是别的东西。是的。所以让我试试这个，例如。让我运行程序。我是我所知道的唯一的 David Malan。但假设我是，比如说，Junior（小），像这样。而且至少在英语中，有时在那里放一个逗号是很常见的。你不一定需要逗号，但我是那种使用逗号的人。那现在就真的，真的坏了。所以我打破了那里的某个假设。所以那当然可能出错。还有什么？

嗯，让我再运行一次。如果我输入 Malan,David，没有空格，因为我有点草率，我没有注意，当你最终有很多用户时，这种情况会发生，嗯，这现在真的坏了。注意我得到了一个 `ValueError`，一个实际的异常。为什么？嗯，因为 `split` 应该通过寻找逗号和空格将字符串分割成两个字符串。但如果没有逗号和空格，它就不能把它分割成两个东西。而我左边有两个变量，但右边只得到一个东西，这意味着我不能像这样执行这段代码。所以它确实很脆弱。

但如果我们至少能改进它就好了，不是吗？例如，我们现在知道一些正则表达式语法。如果我至少想让这个空格可选怎么办？嗯，我可以使用我新发现的正则表达式语法并放一个问号 `?`。问号 `?` 意味着它前面的东西零次或一次。前面的东西是什么？它字面上是一个空格。如果那里只有一个东西，我甚至不需要括号。所以那将是一个模式的开始，它说，我必须有一个逗号，然后我可能有也可能没有一个空格，后面零个或一个空格。

不幸的是，内置于 `str` 变量（像本例中这样）的 `split` 版本不支持正则表达式。如果我们想要我们的正则表达式，我们需要去使用那个库。所以让我这样做。让我进入并保留这段代码，但现在去顶部导入 `re` 库，用于正则表达式。现在让我开始改变我的方法。

我将这样做。我将使用名为 `re.search` 的相同函数，我将搜索一个我认为会是 姓, 名 的模式。所以让我使用我新发现的正则表达式语法，并表示一个像 Malan, space, David 这样的模式。

我该怎么做呢？嗯，在我的 `re.search` 的引号内，我将有一些东西——所以 `.+`——抱歉。我将有一些东西，所以 `.+`。然后我将有一个逗号。然后我将有一个空格。然后我将有别的东西 `.+`。我现在将预先稍微改进一下这个。我希望整个这个模式从用户输入的开头开始匹配。所以我马上添加 `^`。我希望用户输入的结尾也被匹配，所以我字面上期望任何字符一次或多次，然后一个逗号然后一个空格，然后任何其他字符一次或多次。然后就没了。我将像以前一样传入 `name` 变量。

```python
import re

name = input("What's your name? ").strip()

matches = re.search(r"^(.+), (.+)$", name)
# (后续处理...)
```

现在，当我们过去使用 `re.search` 时，我们实际上只是用它来回答一个问题。用户的输入是否匹配以下模式，是或否，实际上是 true 或 false。但 `re.search` 实际上比那更强大。你实际上可以得到更多的信息。你可以这样做。你可以指定一个变量然后一个赋值运算符，并得到关于搜索到的内容的更精确的答案。

但你想要得到什么呢？嗯，事实证明，正则表达式还有另一个特性，它允许你使用括号 `()`，不仅仅是为了将事物组合在一起，而是为了捕获它们。事实证明，当你在正则表达式中指定括号 `()` 时，在我们直到现在都不知道的情况下，括号 `()` 里的所有内容都将作为返回值从 `re.search` 函数返回给你。它将允许你从用户自己的输入中提取特定量的信息。

你也可以反转这个过程，通过使用非捕获版本。你可以使用括号 `()`，然后字面上是一个问号 `?` 和一个冒号 `:`，然后是一些其他东西 (`(?:...)`)。那会说，不要捕获这个。我只是想组合事物。但现在，我们将只使用括号 `()` 本身。

那么我将如何做呢？嗯，如果我想得到用户的姓氏和名字，我认为我想捕获的是这里的 `.+` 和这里的 `.+`。

```python
import re

name = input("What's your name? ").strip()

matches = re.search(r"^(.+), (.+)$", name)
# (后续处理...)
```

所以我故意用括号 `()` 包围了逗号左右两边的 `.+`，不是因为我将它们组合在一起——我没有添加问号 `?`，我没有添加另一个 `+` 或 `*`——我现在使用括号 `()` 是为了捕获的目的。为什么？

嗯，我接下来要做这个。我仍然会问一个布尔问题，比如，“如果有匹配项，那么就这样做。”所以如果 `matches` 不是实际上为 false，比如 `None`，我确实期望我得到了一些匹配项。现在请看我可以做什么。我可以做 `last, first = matches.groups()`，并得到所有匹配组。然后像以前一样用一个格式化字符串更新 `name`，做 `f"{first} {last}"`，然后在最底部，像以前一样，打印出来，例如，“hello, name”。

```python
import re

name = input("What's your name? ").strip()

matches = re.search(r"^(.+), (.+)$", name)
if matches:
    # 方法一：使用 groups()
    # last, first = matches.groups()
    # name = f"{first} {last}"

    # 方法二：使用 group(n)
    last = matches.group(1)
    first = matches.group(2)
    name = f"{first} {last}"


print(f"hello, {name}")
```

所以新的代码现在是这里高亮显示的所有内容。我使用 `re.search` 来搜索用户是否以 姓, 名 的格式输入了他们的名字。但我更强大地使用 `re.search` 来捕获用户输入的一部分。什么会被捕获？任何我用括号 `()` 包围的东西都将作为返回值返回给我。你如何获取那些返回值？你向你赋值给它们的变量请求所有的组 `groups()`，所有被捕获的括号 `()` 组。

所以让我这样做。现在让我运行 `python format.py`，回车。我将像往常一样输入我的名字。在这种情况下，这个 `if` 条件什么也没发生。为什么？因为我没有输入逗号，所以这个搜索没有找到逗号，所以没有匹配项。所以我们立即只打印出 "hello, name"。那里没有什么有趣或新的东西。

但是如果我现在继续，清空我的屏幕，运行 `python format.py`，并输入 Malan, space, David，回车，我们已经重新格式化了我的名字。

嗯，这是怎么工作的？让我现在更明确一点。事实证明，我不必只说 `matches.groups()`。我可以得到我想要的特定组。所以让我再稍微改变一下我的代码。

让我现在只说这个。让我们更新 `name` 为——实际上，让我们这样做。让我们说姓氏将在 `matches` 中，但具体是组 1 (`matches.group(1)`)。名字将在 `matches` 中，但具体是组 2 (`matches.group(2)`)。为什么是 1 和 2？因为这是逗号左边的第一组括号。这是逗号右边的第二组括号。根据输入，在这种情况下，这将是用户的姓氏，Malan。在这种情况下，这将是用户的名字，David。这就是为什么我用组 1 表示姓氏，组 2 表示名字。

现在我将继续说 `name = f"{first} {last}"`，完成。让我再精炼这最后一步，在我们提问之前。如果我立即使用这些变量，我其实并不需要它们。让我们像我们过去为了设计而做的那样，进一步收紧这个。如果我想让名字是人名和姓氏的连接，让我们只这样做。`name = matches.group(2) + " " + matches.group(1)`。

```python
import re

name = input("What's your name? ").strip()

matches = re.search(r"^(.+), (.+)$", name)
if matches:
    # 方法三：直接组合 group(n)
    name = matches.group(2) + " " + matches.group(1)

print(f"hello, {name}")

```

所以这只取决于我，从左到右，这是组 1，这是组 2。所以组 1 是姓氏，组 2 是名字。所以如果我想把它们翻转过来并更新 `name` 的值，我可以明确地先获取组 2，使用 `+` 连接一个单个空格，然后连接上组 1。

好的。那很多内容。让我停下来看看是否有问题。这里的关键区别在于，我们仍然以完全相同的方式使用 `re.search`，但现在我使用它的返回值，不仅仅是为了回答一个 true 或 false 的问题，而是为了实际获取特定的匹配项，任何我用括号 `()` 所谓捕获的东西。

**问：** （观众）为什么这里我们用 1 和 2 而不是 0 和 1 来捕获第一个？
**答：** （David Malan）非常好的问题。一个很好的观察。在几乎所有其他上下文中，我们都从 0 和 1 开始计数，而不是 1 和 2。事实证明，当它从 `re.search` 返回时，位置 0 有其他东西，与字符串本身相关。所以根据这个函数本身的文档，1 是第一组括号，2 是第二组，依此类推。这里只是一个不同的约定。

其他问题？

**问：** （观众）如果我们什么都不写，比如 空格, 空格 呢？我们如何检查条件的真假？
**答：** （David Malan）在我直接回答之前，让我先运行这个，确保我没有进一步弄坏任何东西。让我运行 `python format.py`。让我以正确的方式输入 David, space, Malan。让我再运行一次。让我以我们正在修正的错误方式输入 Malan, comma, David。我们仍然没问题。但我认为它仍然会坏。让我第三次运行它，用 Malan,David，没有空格。现在它仍然坏了。为什么？因为我仍在寻找逗号空格。

现在，我该如何解决这个问题？一种方法是我可以在这里添加一个问号 `?` (`,\s?`)，再说一次，这是它前面东西的零次或一次。所以如果我有一个空格然后一个字面上的问号 `?`，不需要任何括号，那么我字面上可以容忍 Malan, space, David 或 Malan, comma, David。

```python
import re

name = input("What's your name? ").strip()

# 修正：使逗号后的空格可选
matches = re.search(r"^(.+),\s*(.+)$", name) # 使用 \s* 更健壮，允许零或多个空白
if matches:
    name = matches.group(2).strip() + " " + matches.group(1).strip() # 加上 strip 清理可能的多余空格

print(f"hello, {name}")
```
*Self-correction: The speaker suggested `?` after a literal space, but `\s?` or `\s*` is more robust for whitespace. Using `\s*` allows zero or more whitespace characters. Also added `.strip()` to the captured groups to clean up potential extra spaces.*

所以让我们再试一次。之前，这没有用。让我们输入 Malan,David 没有空格。现在它确实起作用了。所以我可以通过对我的公式更精确一点来容忍不同数量的空白。

让我再试一次。让我非常奇怪但可能地多按了几次空格键，所以现在它们真的分开了。这又不会完全正确，因为它会消耗掉所有那些空白。所以现在我可能想对结果左右去除任何前导空白。或者我可以在这里说这个。与其零或一，我可以在这里用一个星号 `*` (`,\s*`)。现在如果我再运行一次，用 Malan, comma, space, space, space, David，回车，现在我们进一步清理了东西。

所以你可以想象，取决于你正在清理的数据有多乱，你的正则表达式可能需要变得越来越复杂。这真的取决于我们想一次解决多少问题。

## 九、 海象运算符（Walrus Operator） `:=`

好吧，请允许我建议我们进一步推进，只是为了使用一个实际上对 Python 本身来说相对较新的特性来进一步清理这个。

在使用正则表达式时，做我在这里所做的事情是非常常见的——调用像 `re.search` 这样的函数，内部带有捕获括号 `()`，这样你就能得到一个返回值，我称之为 `matches`——你可以叫它别的名字，但我默认叫它 `matches`。然后注意在下一行，我说 `if matches`。如果我能进一步收紧事情并将这些都放在同一行上，岂不是很好？

嗯，有点可以。让我这样做。让我去掉这个 `if`。让我只尝试说类似这样的话。`if matches = re.search(...) then colon:`——所以将我的 `if` 条件合并到只有一行而不是那两行。

在 C、C++ 或 Java 中，你实际上会做类似这样的事情，用括号 `()` 包围整个东西，有时用双层括号来抑制任何警告，如果你想一次做两件事的话。如果你不仅想将 `re.search` 的返回值赋给名为 `matches` 的变量，而且你随后想问一个布尔问题，这实际上是 true 还是 false。这就是我刚才在做的。让我撤销这个。刚才，我获取返回值并将其赋给 `matches`，然后我问了问题。

嗯，事实证明，这种需要两行代码的需求大概在 Python 中困扰了人们太久。所以你现在可以将这两种行合并为一行。但你需要一个新的运算符。你不能只说 `if matches = re.search` 然后在末尾加一个冒号。你反而需要这样做。你需要做冒号等于 `:=`，当且仅当你想从右到左赋值，并且你想在同一行上问一个 `if` 或 `elif` 问题。

```python
import re

name = input("What's your name? ").strip()

# 使用海象运算符
if matches := re.search(r"^(.+),\s*(.+)$", name):
    name = matches.group(2).strip() + " " + matches.group(1).strip()

print(f"hello, {name}")
```

这被亲切地称为，正如你在这里看到的，海象运算符（walrus operator）。它在近年来的 Python 中是新的。它既允许你像我从右到左那样赋值，又允许你像我用 `if` 或等效的 `elif` 那样对它问一个布尔问题。

有人知道为什么这被称为海象运算符吗？如果你这样看它，也许，如果你熟悉海象的话，它有点像海象。所以一个小细节，但 Python 的一个相对较新的特性，老实说，你可能会在网上、源代码中、教科书等等中越来越多地看到它，既然它确实存在了。它完全不改变逻辑。如果我运行 `python format.py` 并输入 Malan, comma, space, David，它仍然修正了事情，但它使我的代码更紧凑了一点。

## 十、 正则表达式的实际应用 (续)

**数据提取 (`twitter.py` 示例)**

好的。让我们看最后一个要解决的问题，即现在提取信息。

所以到目前为止，我们现在已经通过检查用户的输入是否符合某个模式来验证了它。我们通过对照一个模式检查它是否匹配，如果匹配，我们某种程度上重新组织了用户的一些信息，以便我们可以清理他们的输入并标准化我们存储或打印它的格式，在本例中是这样。让我们做最后一个例子，我们非常具体地提取信息以回答某个问题。

所以让我建议这个。让我继续关闭 `format.py` 并创建一个名为 `twitter.py` 的新文件，其目标是提示用户输入他们的 Twitter 个人资料的 URL，并从中提取，从该 URL 推断出用户的用户名是什么。

现在，你为什么可能想这样做呢？嗯，一个原因是你可能希望用户能够非常容易地将他们自己 Twitter 个人资料的 URL 复制并粘贴到你的表单、你的应用中，以便你能弄清楚他们的用户名是什么。或者你可能有一个表单，要求用户输入他们的 Twitter 用户名，而因为人们不一定非常仔细地注意，有些人输入他们的用户名。有些人输入他们的整个 URL 或完全是其他东西。既然你现在是一名程序员，能够更容忍不同类型的输入，并承担起规范化、标准化数据的负担，但对用户保持灵活性，那就太好了。如果你让我复制粘贴或输入我想要的，你来清理它，这可以说是一种更好的用户体验。你是程序员，不是我。可能会带来更好的体验。

好吧，让我继续用 `twitter.py` 做这件事。让我首先提示用户输入一个变量 `url` 的值，就问他们输入他们 Twitter 个人资料的 URL。我将去掉任何前导或尾随空格，以防用户意外按下空格键。这确实是我能轻易做到的最起码的事情。

```python
url = input("URL: ").strip()
# (后续处理...)
```

但现在让我们这样做。假设用户的地址是以下这个。让我打印出他们输入了什么。让我清空屏幕并运行 `python twitter.py`。我将输入，例如，`https://twitter.com/davidjmalan`，这恰好是我自己的 Twitter 用户名。现在，我们只是将它打印回屏幕上，只是为了确保我还没有搞砸。好的。所以我打印回了完全相同的 URL。但手头的目标是只提取用户名。

现在，让我只问一个，也许，直接的问题。逻辑上，我需要做什么来获取用户的用户名？

**问：** （观众）嗯，我们只需忽略用户名之前的内容，然后只提取用户名？
**答：** （David Malan）完美。是的，我的意思是，就这么简单。如果你知道用户名在末尾，嗯，让我们就以某种方式忽略开头的所有内容。嗯，开头是什么？嗯，它是一个 URL。所以我们可能需要忽略一个 HTTPS、一个 `://`、一个 `twitter.com` 和一个 `/`。所以我们只想把所有那些都扔掉。为什么？因为如果它是一个 URL，我们通过 Twitter 的工作方式知道用户名在末尾。所以让我们使用那个非常简单的想法来获取我们想要的信息。

我将尝试几种不同的方法。让我回到我的程序中。与其只是打印出来，那只是为了看看发生了什么，让我这样做。让我创建一个名为 `username` 的新变量。让我调用 `url.replace()`。事实证明，如果 `url` 是 Python 中的字符串或 `str`，它再次带有多个方法，比如 `strip`、`split` 和其他方法，其中一个叫做 `replace`。`replace` 会做同样的事情。你给它传递两个参数，第一个是，你想替换什么？第二个参数是，你想用什么来替换它？

所以如果我想去掉，正如我提议的，实际上只是用户名之前的所有东西，也就是 Twitter URL 或其开头部分，让我们只说这个。继续替换 "https://twitter.com/"，引号结束，这是我想替换的。然后逗号，第二个参数，你想用什么替换它？什么都不用。所以我字面上将传入引号引号 `""` 来有效地进行查找和替换。这就是 `replace` 方法所做的，就像你可以在 Microsoft Word 或 Google Docs 中做的那样。这是程序员进行查找和替换的方式。

```python
url = input("URL: ").strip()

# 方法一：使用 replace (有局限性)
username = url.replace("https://twitter.com/", "")
print(f"Username: {username}")
```

现在让我继续只打印用户名。所以我将使用像这样的 f 字符串。我会说 `Username: {username}`，只是为了格式化得好看些。好的。

让我清空屏幕并运行 `python twitter.py`，回车，URL。来了。`https://twitter.com/davidjmalan`，回车。好的。现在我们取得了一些进展。今天的工作完成了，对吧？

嗯，这有什么不理想的地方？有人能批评或找出我程序的毛病吗？它现在正在工作，但它有点脆弱。我敢打赌我们可以设计一些场景，我认为它能工作但实际上不行。

**问：** （观众）嗯，我实际上有几个想法。嗯，首先，如果我们不指定 HTTPS，它会坏掉。其次，如果我们在末尾有一个斜杠，它也会坏掉。如果我们有一个问号或问号后面的东西，它也行不通。所以实际上有很多场景。
**答：** （David Malan）哦，天哪。我的意思是，就是这样。我假装以为我完成了。但天哪，就像，Alex 给了我们一长串问题。那么总结一下，如果不是 HTTPS，是 HTTP 呢？安全性稍差，但我应该仍然能够在程序上容忍它。如果协议不存在呢？如果用户只输入了 twitter.com/davidjmalan 呢？能够容忍那个而不是显示错误并让我输入协议会很好。为什么？这不是好的用户体验。如果在用户名的末尾有一个斜杠，或者一个问号呢？如果你想想你在网上看到的 URL，通常会有更多的信息，特别是如果它在社交媒体上被分享过。可能有所谓的 HTTP 参数，只是我们不想要的东西在那里。可能有一个 www.twitter.com，我也没预料到，但如果你去那个 URL 也能用。所以有太多可能出错的事情了。

甚至如果我回到我之前的那个做作的例子，如果我运行这个程序并说这个——“我的用户名是 https://twitter.com/davidjmalan”，回车。嗯，那个也没真正起作用——它去掉了——实际上——[笑] 好的，实际上那某种程度上起作用了。但这里的目标是实际获取用户的用户名，而不是描述用户用户名的英语句子。所以我认为，即使我刚刚意外地创造了完全正确的英语语法，我也没有正确地提取 Twitter 用户名。我不希望像“我的用户名是”这样的词语作为我输入的一部分。

那么我们该如何改进这个，也许逐一解决其中一些问题呢？嗯，让我清空我的屏幕。让我回到我的代码中。让我不只是替换它，而是做点别的事情。我将继续，与其使用 `replace`，我将使用另一个名为 `removeprefix` 的函数。前缀（prefix）是一个出现在另一个字符串开头的字符串或子字符串。所以如果我 `removeprefix`，我不需要这个函数的第二个参数。我只需要一个。你想移除哪个前缀？

```python
url = input("URL: ").strip()

# 方法二：使用 removeprefix (仍然有局限性)
username = url.removeprefix("https://twitter.com/")
print(f"Username: {username}")
```

所以这至少现在会解决我刚才描述的问题，即输入像整个句子那样，URL 在那里，但它不在开头，只在结尾。所以在这里，这仍然不正确。但我们不会产生那种奇怪的输出，只是移除了输入的 URL 部分——“我的用户名是 https://twitter.com/davidjmalan”。刚才，它确实移除了 URL 并只留下了 davidjmalan。这仍然不完美。但至少现在，它不会奇怪地移除 URL 然后留下英语。它只是保持原样。所以也许我可以更好地处理这个，但至少它从我可能预期的字符串部分移除了它。

嗯，我们还能在这里做什么呢？嗯，事实证明，正则表达式只是让我们能够更精确地表达模式。

**`re.sub` 函数**

我们可以花一整天使用一大堆不同的 Python 函数，比如 `removeprefix` 或 `remove` 和 `strip` 以及其他函数，然后某种程度上找到正确的解决方案。但正则表达式只是让你能够更简洁地，尽管承认更神秘地，表达这些类型的模式和目标。我们已经从括号 `()` 中看到，它们不仅可以用来将符号组合成集合，还可以用来捕获信息，我们现在工具箱里有了一个非常强大的工具。

所以让我这样做。让我在这里重新开始，并在我的程序顶部像以前一样导入 `re` 库。我仍然会通过同一行代码从用户那里获取 URL。但我现在将使用另一个函数。

事实证明，不仅仅有 `re.search`、`re.match` 或 `re.fullmatch`。正则表达式库中还有 `re.sub`，这里的 "sub" 表示 "substitute"（替换）。它接受更多的参数，但它们相当直接。`re.sub` 的第一个参数是模式，即你想要查找的正则表达式。然后你有一个替换字符串——你想用什么来替换那个模式？你想在哪里做所有这些呢？嗯，你传入你想要进行替换的字符串。然后还有一些其他参数，我现在暂时忽略。其中包括那些相同的标志以及一个计数，比如你想进行多少次查找和替换？你想全部替换，只想替换一个，等等，你也可以在那里有进一步的控制，就像你在 Google Docs 或 Microsoft Word 中那样。

好吧，让我回到我的代码，让我这样做。我将调用 `re` 不是 `search` 而是 `re.sub` 用于替换。我将传入以下正则表达式，`"https://twitter.com/"` 然后我将关闭我的引号。现在我想用什么替换那个呢？嗯，就像之前用简单的 `str` `replace` 函数一样，我想用空字符串 `""` 替换它，完全去掉它。但我想对哪个字符串进行此操作呢？用户的 `url`。现在让我继续将 `re.sub` 的返回值赋给一个名为 `username` 的变量。

```python
import re

url = input("URL: ").strip()

# 方法三：使用 re.sub
username = re.sub(r"https://twitter.com/", "", url)
print(f"Username: {username}")
```

`re.sub` 的目的，再说一次，是用某个值替换某个正则表达式若干次。它本质上是使用正则表达式进行查找和替换。一旦你完成了所有这些替换，它会返回给你结果字符串。所以现在我代码的最后一行可以和以前一样，`print(f"Username: {username}")`。所以我可以字面上只打印那个。

好的。让我们试试这个，看看会发生什么。我将清空我的终端窗口，运行 `python twitter.py`。来了，`https://twitter.com/davidjmalan`。祈祷并按回车。好的，现在我们搞定了。

但它仍然有点脆弱。所以让我问问大家，我现在应该进一步解决哪个问题？它们之前被提到过，但让我们明确一下。仍然存在的一个或多个问题是什么？

**问：** （观众）协议和域名前缀 [听不清]..
**答：** （David Malan）好的。协议，所以 HTTP 对比 HTTPS。也许子域名 www，它应该在那里还是不应该？而且这里还有一些其他的错误。让我实际上和大家一起。这个当前解决方案还有哪些其他缺点？
**问：** （观众）如果我们使用像你之前那样的短语，我们将遇到同样的问题，因为它没有考虑文本示例的第一部分。
**答：** （David Malan）好的。我可能仍然允许 URL 左侧有一些单词，一些英语，因为我没有使用我的 `^` 符号。所以我会修正那个。关于这里的缺点，还有最后的观察吗？
**问：** （观众）嗯，它可能是 HTTP，或者可能少于两个斜杠。
**答：** （David Malan）好的。所以它可能是 HTTP。我认为那也被提到了，就协议而言。可能少于两个斜杠。那个我不会担心。如果用户给我的不是两个，那真的是用户错误。我本可以容忍它，但你知道吗，到那时我没问题对他们喊出一个错误消息说，请修正你的输入。否则，我们可能整天都在这里试图处理所有可能的拼写错误。

现在，我认为为了可用性，或者用户体验，UX，让我们至少容忍所有可能的有效输入或合理的输入，如果你愿意的话。所以让我到这里，让我开始逐一解决这些问题。

我们可以解决哪些问题？嗯，让我建议我们首先解决从字符串开头匹配的问题。所以我在开头添加 `^`。我不会在结尾添加 `$` 符号，对吧？因为我不想一直匹配到结尾，因为我想容忍那里的用户名。所以我认为我们只需要那里的 `^` 符号。

有一个微妙的 bug，还没有人提到。让我只是强调一下，看看它现在是否会跳到你眼前。在我的屏幕上这里有点微妙。我用蓝色高亮显示了这里的最后一个 bug——也许屏幕上有些微笑，是吗？我们能请一位举手吗？为什么我高亮显示 twitter.com 中的点 `.`，即使它肯定应该在那里？

**问：** （观众）所以没有反斜杠的点表示除换行符外的任何字符。
**答：** （David Malan）是的，完全正确。它表示任何字符。所以我可以输入像 twitter?com 或 twitter 任何东西 com 这样的东西，那实际上会被容忍。这并不是那么糟糕，因为用户为什么要那样做呢？但如果我想正确，并且我想能够正确地测试我自己的代码，我真的应该把这个细节弄对。所以这也是一个容易的修正，但这是一个常见的错误。任何时候你写正则表达式，恰好涉及到特殊符号，比如 URL 或域名中的点，涉及货币的美元符号 `$`，记住你可能确实需要用反斜杠 `\` 来转义它，就像这里这样。

```python
import re

url = input("URL: ").strip()

# 修正 re.sub 模式 (部分改进)
username = re.sub(r"^https://twitter\.com/", "", url)
print(f"Username: {username}")
```

好的。让我问问大家关于协议的具体问题。所以 HTTPS 是世界上的一件好事。它意味着安全。正在使用加密。所以总的来说，你喜欢看到 HTTPS。但你仍然看到人们输入或复制粘贴 HTTP。这里最简单的修正是什么，来容忍，正如已经提出的，HTTP 和 HTTPS 两者？

我建议我可以这样做。我可以做 `(HTTP|HTTPS)`，再说一次，意思是 A 或 B。但我认为我可以更聪明一些。我可以让我的代码更简洁一些。这里有什么建议可以容忍 HTTP 或 HTTPS 吗？

**问：** （观众）我们可以尝试在 S 后面放一个问号。
**答：** （David Malan）完美。只用一个问号 `?` (`https?`)。两者都是可行的解决方案。如果你想在你的代码中非常明确，好的。使用括号 `()` 并说 HTTP 或 HTTPS，这样你，读者，你的老板，你的老师就知道你到底在做什么。但如果你一直采取更冗长的方法，它实际上可能会变得更难读，当然一旦你的正则表达式变得这么大而不是这么大时。所以让我们在可以的地方节省空间。我认为这相当合理，只要你习惯于阅读正则表达式并且知道问号 `?` 不意味着字面上的问号，而是意味着它前面东西的零次或一次。我认为我们在这里有效地使 S 成为可选的了。

```python
import re

url = input("URL: ").strip()

# re.sub 模式 (进一步改进)
username = re.sub(r"^https?://twitter\.com/", "", url)
print(f"Username: {username}")
```

现在，我还能做什么？嗯，假设我们想容忍 www 点 (`www.`)，它可能在那里也可能不在那里，但如果你去浏览器它会工作。我可以这样做——`www\.`——等等，我想要一个反斜杠 `\` 在那里，这样我就不会重复和以前一样的错误。但这也不好，因为我想容忍它在那里或不在那里。而我现在只是要求它必须在那里。但我认为我可以采取同样的方法。有什么建议吗？我如何使 `www.` 成为可选的，只是为了强调这一点？

**问：** （观众）我们可以分组——做一个方块和一个问号。
**答：** （David Malan）完美。所以问号 `?` 又是简短的答案。但这次我们必须更聪明一点。正如 Maria 指出的，我们现在需要括号 `()`。因为如果我只在点 `.` 后面放一个问号 `?`，那只意味着点 `.` 是可选的。那是错误的，因为我们不希望用户输入 W-W-W-T-W-I-T-T-E-R。我们希望点 `.` 要么在那里，要么就完全没有，也没有 www。所以我们需要将整个 `www\.` 组合在一起，在那里放一个括号，然后一个括号，不是在第三个 W 之后，而是在点 `.` 之后 (`(www\.)?`)，这样整个东西要么在那里，要么不在那里。

```python
import re

url = input("URL: ").strip()

# re.sub 模式 (再次改进)
username = re.sub(r"^https?://(www\.)?twitter\.com/", "", url)
print(f"Username: {username}")
```

我们还能在这里做什么？还有一件我们应该容忍的事情。它之前被提到过，我将挑选出这个。协议呢？比如，如果用户就是不输入或不复制粘贴 http:// 或 https:// 呢？老实说，你我现在一般甚至都不习惯输入协议了。你只是让浏览器为你弄清楚，并自动添加它。所以这个看起来会更拗口。但如果我想让这里蓝色的整个部分 (`https?://`) 成为可选的，实际上和 Maria 刚才提供的解决方案一样。我将在这里放一个括号，在两个斜杠 `//` 之后放一个括号，然后一个问号 `?` (`(https?://)?)`，以此使整个东西也成为可选的。

```python
import re

url = input("URL: ").strip()

# re.sub 模式 (最终改进版本)
username = re.sub(r"^(https?://)?(www\.)?twitter\.com/", "", url)
print(f"Username: {username}")
```

这没关系。让整个东西成为可选的，或者在它内部，这个小东西，只有 S (`s?`) 成为可选的，这完全没问题。只要我一次又一次地应用相同的原则，无论是在小规模还是更大规模上，将其中一个嵌套在另一个内部完全没问题。

现在对这些对 Twitter URL 解析、分析的改进有什么问题吗？

**问：** （观众）如果我们在 www 点旁边放一个竖线呢？
**答：** （David Malan）如果我们用竖线在那里？所以我们也可以做类似那样的事情。我们可以做类似这样。与其用问号 `?`，我可以做 `(www\.|)`，然后是空字符串，然后保留括号。那也没问题。我个人倾向于不喜欢那样，因为它对我来说有点不太明显——等等。这是故意的，还是我忘了通过在竖线后面放东西来完成我的想法？但如果你是那个意思，那在那里也是允许的。

关于我们在这里结束的地方，我们使协议也成为可选的，还有其他问题吗？

**问：** （观众）如果我们有括号，里面有另一个括号，再一个括号，会发生什么？它们会互相干扰吗？
**答：** （David Malan）如果你有括号套括号，那也完全没问题。确实，这应该是今天令人安心的教训之一。尽管承认每个正则表达式都变得很复杂，但我只是在一次又一次地应用完全相同的原则和完全相同的语法。所以如果括号 `()` 各自解决不同的问题，那么括号 `()` 套括号 `()` 完全没问题。

事实上，我今天要特别强调的教训是，如果你试图一次性写出一个完整复杂的正则表达式，你不会高兴的。就像，如果你像我一样，你会失败，你会很难找到错误。因为天哪，看看这些东西。即使对我这个多年后的人来说，它们也很神秘。我认为更好的方法，无论你是编程新手还是像我一样老手，就是采取这些小步骤，这些渐进的步骤，你做一些简单的事情，你确保它有效。你添加一个特性，确保它有效。再添加一个特性，确保它有效。希望到最后，因为你每次都一步一步地完成了这些步骤，整个事情对你来说就会有意义。但你也会在每个转折点都把每个步骤做对。所以请务必避免试图一次性想出长而复杂的正则表达式的倾向，因为如果你然后盯着它试图找到一个你本可以通过更渐进的方式捕捉到的错误，那不是对时间的好利用。

好的。可以说，这个解决方案仍然至少存在一个问题，那就是即使我调用 `re.sub` 来用空字符串 `""` 替换 URL，我然后在我的代码的最后一行，第 6 行，只是盲目地假设一切都奏效了，我将打印出用户名。但是如果用户——如果我清空我的屏幕并运行 `python twitter.py`——甚至不输入 Twitter URL 呢？如果他们做类似 `https://google.com/` 这样的事情，完全不相关，不管什么原因，回车，那不是他们的 Twitter 用户名。

所以我认为我们需要一些条件逻辑，以便就这个程序而言，我们只在确实匹配了正确的模式时才打印出来，或者，在后端系统中，我们只在那个时候才将用户名保存到我们的数据库或 CSV 文件中。

**`re.search` 用于提取**

所以与其使用 `re.sub`，它对于清理数据很有用，就像我们在这里做的那样去掉我们不想要的东西，为什么我们不回到我们今天开始的 `re.search`，并用它来解决同样的问题，但是以一种条件化的方式，这样我可以在我的程序结束时自信地说，是或否，这里是用户名，或者不是？

所以现在让我继续。我将在这里清空我的终端窗口。我将保留大部分——我将保留前两行相同，导入 `re` 并从用户那里获取 URL。但这次，让我们这样做。这次让我们搜索，使用 `re.search` 而不是 `re.sub`，以下内容。

我将从字符串的开头开始匹配 `^`，`https?://`，问号 `?` 使 s 可选，然后是 `(www\.)?` 使 www 可选，然后是 `twitter\.com/`，确保点被转义。然后嗯，这是 davidjmalan 应该去的地方。我该如何检测这个？嗯，我想我只会容忍 URL 末尾的任何东西 `.+`。好的，最末尾是美元符号 `$`，引号结束。

```python
import re

url = input("URL: ").strip()

# 方法四：使用 re.search 和捕获组
matches = re.search(r"^https?://(www\.)?twitter\.com/(.+)$", url, re.IGNORECASE)
# (后续处理...)
```

目前，我将规定我们不担心末尾的问号 `?` 或哈希 `#`，比如 URL 中的片段标识符。为了简单起见，我们现在假设 URL 只以用户名结尾。

现在我将做什么？嗯，我想搜索这个特定的 URL，我将忽略大小写，所以 `re.IGNORECASE`，应用之前学到的相同教训。`re.search`，回想一下，会返回你捕获的匹配项。嗯，我想捕获什么？嗯，我想捕获这里 twitter.com URL 右边的所有东西。所以让我用括号 `()` 包围应该是用户用户名的部分 `(.+)`，不是为了让它们可选，而是为了说，“捕获这组字符。”

现在 `re.search`，回想一下，返回一个答案。`matches` 将再次是我的变量名，但我可以叫它任何我想要的名字。然后我可以这样做。`if matches:`，现在我知道我可以这样做。让我们打印出格式化字符串，`Username: {matches.group(1)}` 用于我匹配到的用户名。

```python
import re

url = input("URL: ").strip()

matches = re.search(r"^https?://(www\.)?twitter\.com/(.+)$", url, re.IGNORECASE)
if matches:
    username = matches.group(1) # 假设用户名是第二个捕获组
    print(f"Username: {username}")
```
*Self-correction: The `www.` part is group 1 (if it exists), so the username is group 2.*

```python
import re

url = input("URL: ").strip()

matches = re.search(r"^https?://(www\.)?twitter\.com/(.+)$", url, re.IGNORECASE)
if matches:
    username = matches.group(2) # 用户名是第二个捕获组
    print(f"Username: {username}")

```

好的。那么我做了什么，只是回顾一下？第 1 行，我导入库。第 2 行，我从用户那里获取 URL。所以那里没什么新的。第 5 行，我搜索用户的 URL，如这里作为第二个参数所示，寻找这个正则表达式，这个模式。我用括号 `()` 包围了 `.+`，以便它们最终被捕获，所以我可以在这个最终场景中提取用户的用户名。如果我确实得到了一个匹配，并且 `matches` 不是 None，它实际上包含一些匹配，那么并且只有在那时，打印出用户名。

通过这种方式，让我现在试试这个。如果我运行 `python twitter.py` 并输入 `https://www.google.com/`，现在什么都不会打印。所以我至少解决了我们刚才看到的错误，那时我只是假设我的代码有效。现在我确保我已经搜索并找到了 Twitter URL 前缀。

好的。好吧，让我们现在真正运行这个。`python twitter.py https://twitter.com/davidjmalan`。但请注意，我可以使用 HTTP，我可以使用 www。我将在这里按回车。

嗯，None。出什么问题了？

这个有点更微妙。但为什么 `matches.group(1)` 什么都没有？等等。让我——也许我做错了。也许——也许我们需要 www？让我再运行一次。来了。`https://www.twitter.com/davidjmalan`。好的。回车。嚯，嚯，嚯。发生了什么？

**问：** （观众）你得说 group 2。
**答：** （David Malan）我得说 group 2？嗯，等等——哦，对，因为我们的子域名是可选的。为了让它可选，我需要在这里使用括号 `()` (`(www\.)?`)。所以我然后说了零或一。好的。所以这意味着实际上，我无意中但按设计捕获了 `www.`，或者如果它之前不存在则什么都没捕获，但我在这里有第二个匹配，因为我有第二组括号 (`(.+)`)。所以我想，是的，让我把 `matches.group(1)` 改成 `matches.group(2)`，然后运行这个。

```python
import re

url = input("URL: ").strip()

matches = re.search(r"^https?://(www\.)?twitter\.com/(.+)$", url, re.IGNORECASE)
if matches:
    username = matches.group(2) # 确认是第二个捕获组
    print(f"Username: {username}")
```

`python twitter.py https://www.twitter.com/davidjmalan`，回车，现在我们得到了用户名。

让我继续进一步收紧它。如果你喜欢我们的新朋友——很难不喜欢。如果我们喜欢我们的老朋友海象运算符 `:=`，让我们继续添加这个只是为了收紧事情。让我回到 VS Code，让我去掉那里不必要的条件，并将其合并到这里，`if matches := re.search(...)`。但让我们将单个赋值运算符更改为海象运算符。

```python
import re

url = input("URL: ").strip()

# 使用海象运算符和 re.search
if matches := re.search(r"^https?://(www\.)?twitter\.com/(.+)$", url, re.IGNORECASE):
    username = matches.group(2)
    print(f"Username: {username}")
```

现在我已经进一步收紧了事情。但我敢打赌，我敢打赌，我敢打赌这里可能有另一个解决方案。

**非捕获组 `(?:...)`**

确实，事实证明我们可以回到这最后一组语法。回想一下，当我们引入这些括号 `()` 时，我们这样做是为了我们可以做 A 或 B，例如，用竖线 `|`。然后你甚至可以组合不止一个竖线。我们使用组来组合像 `www.` 这样的想法。然后底部有这个承认有点奇怪的语法，直到现在还没用过。

如果你想在逻辑上使用括号 `()` 因为你需要这样做，但你不想费心捕获结果，那么有一个非捕获版本的括号 `()` (`(?:...)`)。这可以说在这里会是一个更好的解决方案，因为，是的，如果我回到 VS Code，我确实需要用括号 `()` 包围 `www.`，至少按照我写我的 regex 的方式，因为我想在它后面放问号 `?`。但我不需要 `www.` 返回。事实上，让我们只提取我们关心的数据，只是为了将来不会有混淆，对我，或我的同事，或我的老师。

那么我能做什么呢？嗯，根据这张幻灯片的语法是，在开括号 `(` 之后立即使用一个问号 `?` 和一个冒号 `:` (`(?:...)`)。承认它看起来很奇怪。你们中有过往编程经验的人可能会从三元运算符中认出这种语法，在一行中完成 if else。在那个括号开头的问号冒号 `?:` 意味着，是的，我使用括号 `()` 来将这些东西组合在一起，但是不，你不需要捕获它们。

所以我现在可以将我的代码改回 `matches.group(1)`。

```python
import re

url = input("URL: ").strip()

# 使用非捕获组
if matches := re.search(r"^(?:https?://)?(?:www\.)?twitter\.com/(.+)$", url, re.IGNORECASE):
    username = matches.group(1) # 现在用户名是第一个（也是唯一一个）捕获组
    print(f"Username: {username}")
```
*Self-correction: Need to make the protocol part non-capturing too.*

我将在这里清空我的屏幕，运行 `python twitter.py`。我将再次运行 `https://twitter.com/davidjmalan`，带或不带 www。现在，我确实得到了那个用户名。

那么，关于这些最后的技术，有什么问题吗？

**问：** （观众）所以首先，我们可以把 `^` 移到 Twitter 的最开始，然后就从那里开始读，然后去掉之前的所有其他东西，就是我们遇到的那种 www 问题吗？然后我的第二个问题是，我们将如何使用某种，我猜是列表或字典来排序 .com 那种东西，因为我们有 .co.uk 之类的。我们将如何把它带入 re 函数？
**答：** （David Malan）好问题，但不。如果我把 `^` 移到 twitter.com 前面，并扔掉协议和 www，那么用户将必须字面上输入 twitter.com/username。他们甚至不能输入那些其他东西。所以那将是一个倒退，退一步。

至于 .com、.org 和 .edu 等等，简短的答案是这里有很多不同的解决方案。如果我想严格要求 .com——假设 Twitter 可能拥有多个域名，即使他们倾向于只用这一个。假设他们也有像 .org 这样的。你可以在这里使用更多的括号 `()` 并做类似这样的事情——`(com|org)`。我可能想进去添加一个问号冒号 `?:` (`(?:com|org)`) 使其非捕获，因为我不在乎它是哪个，我只想容忍两者。

或者，我们可以捕获那个。我们可以做类似这样的事情，我们做 `\.(\w+)` 以便实际捕获那个顶级域名。然后我们可以做类似这样。`if matches.group(1) == "com":`，那么我们可以支持这个。所以你可以想象通过提取顶级域名（TLD）来分解逻辑，然后只使用 Python 代码，也许是一个列表，也许是一个字典，在 regex 之外的其他地方验证它是否确实是你期望的。

不过，目前我们保持简单。在这种情况下，我们只关注 .com。

让我们对这个程序做最后一个更改，以便我们对 Twitter 用户名的定义更具体一些。事实证明，我们在这里有点太宽容了，我们接受一个或多个任何字符 `.+`。我查了 Twitter 的文档。Twitter 只支持字母表中的字母，a 到 Z，数字 0 到 9，或下划线，所以不仅仅是点 `.`，那字面上是任何东西。

所以让我在这里更精确一些。在我字符串的末尾，让我继续说，方括号 `[]` 中的这组符号。我将继续说 a 到 z，0 到 9，和一个下划线 (`[a-z0-9_]+`)。因为，再说一次，那些是唯一有效的符号。我不需要费心用大写 A 或小写 z，因为我们在这里使用了 `re.IGNORECASE`。

```python
import re

url = input("URL: ").strip()

# 最终版本：精确匹配用户名字符 + 非捕获组
if matches := re.search(r"^(?:https?://)?(?:www\.)?twitter\.com/([a-zA-Z0-9_]+)$", url, re.IGNORECASE):
    username = matches.group(1)
    print(f"Username: {username}")
```
*Self-correction: The speaker initially used `[a-z0-9_]` assuming `IGNORECASE` covers `A-Z`, which is correct. However, the example needs `+` to match one or more characters. The speaker later mentions tolerating `/` or `?` or `#` at the end, which complicates the simple `$` anchor used here. For simplicity matching the code shown *before* that final thought, let's stick to `$` for now, matching only the valid username characters at the end.*

*Revisiting the speaker's final thought (2:03:16): He wants to tolerate `/`, `?`, `#` *after* the username. This means the regex needs to change significantly. The capture group should end after the valid characters, and the rest shouldn't necessarily be matched by `$`. A simple way might be:*
```python
# 更健壮的版本，尝试容忍 URL 末尾的额外字符 (未在最终代码中显示，但符合讲座描述)
# Pattern might look something like:
# r"^(?:https?://)?(?:www\.)?twitter\.com/([a-zA-Z0-9_]+)"
# This extracts the username but doesn't validate the *end* of the URL strictly.
# Let's stick to the code version shown for consistency with the example run.
```

我现在将接受 URL 末尾可能有斜杠 `/`、问号 `?` 或哈希 `#`，所有这些在 URL 中都是有效的符号，但我从 Twitter 的文档中知道，它们不是用户名的一部分。好的。

现在我将最后一次运行 `python twitter.py`，输入 `https://twitter.com/davidjmalan`，也许带，也许不带结尾的斜杠。但希望，我最大的祈祷是，我现在将按回车，谢天谢地，我的用户名确实是 davidjmalan。

**其他 `re` 库函数**

那么正则表达式的世界和这个库本身还有什么更多内容呢？不仅仅是 `re.search` 和 `re.sub`，还有其他函数。有 `re.split`，通过它你可以分割一个字符串，不是使用一个特定的字符或字符，比如逗号和空格，而是多个字符。甚至还有像 `re.findall` 这样的函数，它可以让你在一个字符串的不同位置搜索相同模式的多个副本，这样你也许可以操作不止一个。

## 十一、 编写正则表达式的最佳实践

（已融入前面关于逐步构建和测试的建议）

## 结论

所以现在一天结束时，你真的学了完全另一种语言，就像正则表达式那样，我们在 Python 中使用了它们。但这些正则表达式实际上也存在于许多语言中，其中包括 JavaScript、Java、Ruby 等等。所以有了这门新语言，即使承认在你第一次使用它时很神秘，你有了这种新发现的能力来表达这些模式，再说一次，你可以用它们来验证数据、清理数据，甚至提取数据，从你可能想到的任何数据集中。

这就是本周的内容。我们下次再见。

---

# 要点回顾

**CS50P 第 7 讲：正则表达式 - 框架与要点**

**一、 正则表达式简介**
- 正则表达式（Regex）是一种用于定义搜索模式的特殊文本字符串。
- 主要用途：验证用户输入（如邮箱格式）、在数据中查找模式、清理或提取数据。

**二、 不使用正则表达式进行验证的局限性 (`validate.py` 示例)**
- 尝试用基本的字符串方法（如 `in`、`split`、`endswith`）验证电子邮件地址。
- 简单检查（如仅检查 `@` 符号）过于宽松，容易出错。
- 增加更多检查（如检查 `.`、分割用户名和域名、检查 `.edu` 后缀）会使代码迅速变得复杂且脆弱。
- 结论：对于复杂的模式匹配，传统字符串方法不够健壮且难以维护。

**三、 Python `re` 库入门**
- Python 通过内置的 `re` 库提供正则表达式支持。
- 核心函数：`re.search(pattern, string, flags=0)`
    - 在 `string` 中搜索第一个匹配 `pattern` 的位置。
    - 返回一个匹配对象（如果找到），否则返回 `None`。
    - `flags` 是可选参数，用于修改匹配行为（如忽略大小写）。

**四、 正则表达式基本模式语法**
- **元字符（Metacharacters）**：具有特殊含义的字符。
    - `.`: 匹配除换行符外的任何单个字符。
    - `*`: 匹配前一个字符零次或多次。
    - `+`: 匹配前一个字符一次或多次。
    - `?`: 匹配前一个字符零次或一次（使其可选）。
    - `{m}`: 精确匹配前一个字符 `m` 次。
    - `{m,n}`: 匹配前一个字符至少 `m` 次，至多 `n` 次。
- **字面量（Literals）**：非特殊字符按其字面意义匹配（如 `a`, `@`）。
- **转义（Escaping）**:
    - 使用反斜杠 `\` 来匹配元字符本身（例如 `\.` 匹配真正的点号，而不是“任何字符”）。
    - 建议在 Python 中使用原始字符串（raw strings）`r"..."` 来定义正则表达式模式，以避免 Python 本身对反斜杠的转义处理。

**五、 锚点与边界**
- `^`: 匹配字符串的开头。
- `$`: 匹配字符串的结尾（或结尾处的换行符之前）。
- 结合使用 `^` 和 `$` 可以确保整个字符串完全匹配模式。

**六、 字符集与字符类**
- **字符集 `[...]`**:
    - 匹配方括号内指定的任意一个字符。
    - 支持范围表示：`[a-z]` (小写字母), `[A-Z]` (大写字母), `[0-9]` (数字)。
    - 可以组合：`[a-zA-Z0-9_]` 匹配任何字母、数字或下划线。
- **排除型字符集 `[^...]`**:
    - 匹配任意不在方括号内的字符（当 `^` 是括号内的第一个字符时）。
    - 例如 `[^@]` 匹配除 `@` 之外的任何字符。
- **预定义字符类（常用简写）**:
    - `\d`: 匹配任何数字（等价于 `[0-9]`）。
    - `\D`: 匹配任何非数字字符（等价于 `[^0-9]`）。
    - `\s`: 匹配任何空白字符（空格、制表符、换行符等）。
    - `\S`: 匹配任何非空白字符。
    - `\w`: 匹配任何“单词”字符（字母、数字、下划线，等价于 `[a-zA-Z0-9_]`）。
    - `\W`: 匹配任何非“单词”字符。

**七、 标志位（Flags）**
- 在 `re` 函数（如 `re.search`, `re.sub`）中作为可选参数传递，以改变匹配行为。
- `re.IGNORECASE` 或 `re.I`: 进行不区分大小写的匹配。
- 其他：`re.MULTILINE`, `re.DOTALL` 等。

**八、 分组与捕获**
- **分组 `(...)`**:
    - 将模式的一部分括起来作为一个单元。
    - 可以对整个组应用量词（如 `?`, `+`, `*`）。例如 `(www\.)?` 使 "www." 成为可选部分。
    - 用于“或”逻辑：`(cat|dog)` 匹配 "cat" 或 "dog"。
- **捕获组**:
    - 默认情况下，括号 `()` 不仅分组，还会“捕获”其匹配到的文本。
    - `re.search` 返回的匹配对象 `m` 提供了访问捕获内容的方法：
        - `m.group(n)`: 获取第 `n` 个捕获组匹配的文本（注意：`n` 从 1 开始计数）。
        - `m.group(0)` 或 `m.group()`: 获取整个正则表达式匹配的文本。
        - `m.groups()`: 返回一个包含所有捕获组（从 1 开始）匹配文本的元组。
- **非捕获组 `(?:...)`**:
    - 使用 `(?:` 开头的括号进行分组，但不会捕获匹配的文本，也不计入组号。
    - 当只需要分组逻辑（如应用量词或 `|`）而不需要提取该部分内容时很有用，可以避免干扰后续捕获组的编号。

**九、 海象运算符（Walrus Operator） `:=`**
- 允许在表达式（如 `if` 语句）中同时进行赋值和条件判断。
- 简化常见模式：`if (matches := re.search(...)):` 先执行 `re.search` 并将结果赋给 `matches`，然后检查 `matches` 是否为真（即是否找到匹配）。

**十、 正则表达式的实际应用**
- **数据验证**: 如验证复杂的电子邮件格式（真实世界的邮箱正则非常复杂，通常建议使用库）。
- **数据清理与格式化 (`format.py` 示例)**:
    - 场景：将 "姓, 名" 格式统一为 "名 姓"。
    - 使用 `re.search` 结合捕获组提取姓和名，然后重新组合。
- **数据提取 (`twitter.py` 示例)**:
    - 场景：从 Twitter 个人资料 URL 中提取用户名。
    - 方法1 (局限性大): 使用字符串的 `replace` 或 `removeprefix`。
    - 方法2: 使用 `re.sub(pattern, replacement, string)` 进行基于模式的替换，将 URL 前缀替换为空字符串。
    - 方法3 (更佳): 使用 `re.search` 匹配整个 URL 结构，并用捕获组 `()` 精确提取用户名部分，确保只在 URL 格式正确时提取。
- **其他 `re` 库函数**:
    - `re.match()`: 从字符串开头开始匹配（隐式带 `^`）。
    - `re.fullmatch()`: 匹配整个字符串（隐式带 `^` 和 `$`）。
    - `re.split()`: 使用正则表达式作为分隔符来分割字符串。
    - `re.findall()`: 查找字符串中所有不重叠的匹配项，并以列表形式返回。

**十一、 编写正则表达式的最佳实践**
- **逐步构建**: 不要试图一次性写出复杂的正则表达式。从简单的模式开始，逐步添加功能并测试每一步。
- **测试**: 充分测试各种有效和无效的输入情况。
- **可读性**: 虽然 regex 可能很简洁，但有时过于复杂会降低可读性；考虑适当添加注释或使用非捕获组等技巧。
- **了解局限性**: 对于非常复杂的结构化数据（如 HTML/XML），正则表达式可能不是最佳工具，应考虑使用专门的解析库。
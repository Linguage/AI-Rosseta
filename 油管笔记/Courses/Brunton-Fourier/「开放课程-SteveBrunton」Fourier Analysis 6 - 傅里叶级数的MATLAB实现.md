
# 傅里叶级数的MATLAB实现

> - 视频链接：[Fourier Series [Matlab]](https://youtu.be/PP5ox7evg7o?si=svz7mLai2_fnkrz-)
> - 作者：[Steve Brunton](https://www.youtube.com/@Eigensteve)
> - 本内容整理自视频脚本，仅供参考。请观看原视频及相关资料。此外，作者还提供了Python版本的实现，点击[Python版视频链接](https://youtu.be/dZrShAGqT44?si=XauiCtbB3xjID0bA)
> - 程序可从网站：[https://databookuw.com/](https://databookuw.com/) 下载，

## 导言

本篇内容整理自一段关于使用 MATLAB 计算傅里叶级数的视频讲座。讲座旨在通过一个具体的实例，清晰地展示如何将傅里叶级数的理论应用于实际的数值计算中。讲者选取了一个定义在 $[-\pi, \pi]$ 区间上的周期性三角帽函数作为目标，逐步演示了利用 MATLAB 实现其傅里叶级数近似的全过程。

内容首先从环境设置开始，包括定义计算区间、离散化坐标点以及精确构建目标函数。随后，简要回顾了傅里叶级数的核心概念，特别是系数 $a_k$ 和 $b_k$ 的计算原理（内积），并点明了在离散数据下如何运用点积进行有效近似。讲座的核心部分详细介绍了 MATLAB 代码的实现逻辑：如何计算零阶系数 $a_0$，如何通过循环迭代计算更高阶的系数 $a_k$ 和 $b_k$，以及如何将这些项逐步累加，构建出不同截断阶数的傅里叶级数近似函数。

为了直观展示效果，讲座中包含了动态可视化的环节，让观众能够清晰地看到随着叠加项数的增加，近似函数如何逐渐逼近原始的三角帽形状。最后，讲座还进一步探讨了结果分析，包括绘制傅里叶系数的幅值谱和重构误差随阶数变化的曲线，并对观察到的现象（如误差的单调递减和系数的特定模式）进行了解释。

---

# 视频脚本：傅里叶级数-Fourier Series in Matlab

## 一、 引言与目标

大家好，欢迎回来。我们正在讨论傅里叶级数，以及如何通过叠加越来越高频率的正弦和余弦函数来近似任意的周期函数。

在这个例子中，我们将要做的是在 MATLAB 中编写代码，使用傅里叶级数来近似这个三角帽函数。我已经预先加载了代码。大家可以在 databook UW.com 下载所有这些代码，MATLAB 和 Python 版本也都在 GitHub 上。

```matlab
clear all, close all, clc


% Define domain

dx = 0.001;

L = pi;

x = (-1+dx:dx:1)*L;

n = length(x); nquart = floor(n/4);

  

% Define hat function

f = 0*x;

f(nquart:2*nquart) = 4*(1:nquart+1)/n;

f(2*nquart+1:3*nquart) = 1-4*(0:nquart-1)/n;

plot(x,f,'-k','LineWidth',1.5), hold on

  
% Compute Fourier series

CC = jet(20);

A0 = sum(f.*ones(size(x)))*dx;

fFS = A0/2;

for k=1:20

A(k) = sum(f.*cos(pi*k*x/L))*dx; % Inner product

B(k) = sum(f.*sin(pi*k*x/L))*dx;

fFS = fFS + A(k)*cos(k*pi*x/L) + B(k)*sin(k*pi*x/L);

plot(x,fFS,'-','Color',CC(k,:),'LineWidth',1.2)

end

  
  

%% Plot amplitudes

figure

clear ERR

clear A

fFS = A0/2;

A(1) = A0/2;

ERR(1) = norm(f-fFS);

kmax = 100;

for k=1:kmax

A(k+1) = sum(f.*cos(pi*k*x/L))*dx;

B(k+1) = sum(f.*sin(pi*k*x/L))*dx;

% plot(x,B(k)*sin(2*k*pi*x/L),'k-','LineWidth',1.2);

fFS = fFS + A(k+1)*cos(k*pi*x/L) + B(k+1)*sin(k*pi*x/L);

ERR(k+1) = norm(f-fFS)/norm(f);

end

thresh = median(ERR)*sqrt(kmax)*4/sqrt(3);

r = max(find(ERR>thresh));

r = 7;

subplot(2,1,1)

semilogy(0:1:kmax,A,'k','LineWidth',1.5)

hold on

semilogy(r,A(r+1),'bo','LineWidth',1.5)

xlim([0 kmax])

ylim([10^(-7) 1])

subplot(2,1,2)

semilogy(0:1:kmax,ERR,'k','LineWidth',1.5)

hold on

semilogy(r,ERR(r+1),'bo','LineWidth',1.5)
```

## 二、 MATLAB 环境设置与目标函数定义

我们来看代码。首先要做的是定义我们的域。在这个例子中，我将定义一个从 $-\pi$ 到 $\pi$ 的域，所以可以说 $L$ 就是 $\pi$。我将用 1024 个点定义我的 x 域，从 $-L$ 到 $L$，也就是 $-\pi$ 到 $\pi$。

然后，我将定义我的帽函数。我定义这个帽函数的方式是，将这个域分成四部分。第一部分和最后一部分的函数值设为零。然后中间的两部分，即第二和第三部分，将分别具有正斜率和负斜率，以形成这个帽子形状。这就是你在这里看到的。

我这就给大家绘制出来。这就是我们在域 $[-\pi, \pi]$ 上的三角帽函数。

## 三、 傅里叶级数计算原理回顾

现在，所有有趣的部分都发生在这段代码里。这是我们实际计算傅里叶级数的方法。我在这里把它写出来了，想提醒大家数学上它是怎样的。傅里叶级数是这些傅里叶系数 $a_k$ 和 $b_k$ 乘以它们对应的、频率不断增加的余弦和正弦函数的和。

$f(x) \approx \frac{a_0}{2} + \sum_{k=1}^{\infty} (a_k \cos(kx) + b_k \sin(kx))$
（注意：在 L=$\pi$ 的情况下 $\cos(\frac{k\pi x}{L}) = \cos(kx)$ 且 $\sin(\frac{k\pi x}{L}) = \sin(kx)$）

所以当 $k$ 增大时，这些余弦和正弦的频率也随之升高，频率越来越高。我们通过将你的函数 $f(x)$ 投影到那个基上，或者说投影到那个特定的第 $k$ 个余弦模式 $\cos(kx)$ 和第 $k$ 个正弦模式 $\sin(kx)$ 上，来获得这些系数 $a_k$ 和 $b_k$。这些系数的计算公式通常涉及积分形式的内积：

$a_k = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \cos(kx) dx$
$b_k = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \sin(kx) dx$

这里的这个内积，如果这些是数据向量，如果这些是在离散值 $x$ 处求值的数据序列，那么它实际上就是一个点积 (dot product)。这正是我们在 MATLAB 中实际计算它的方式。

## 四、 MATLAB 代码实现傅里叶级数计算

我们在这里所做的，首先是计算第 0 阶模式，也就是 $a_0$ 系数对应的项（通常傅里叶级数写作 $a_0/2 + ...$）。我这里计算的就是函数 $f$ 与常数函数 $\cos(0x)$（也就是 1）的内积，它代表了函数的平均值。

然后，对于 $k=1$ 到 20，我们实际要做的是近似这个级数。我们将用一个到 20 的求和来近似它，而不是求和到无穷大。

$f(x) \approx \frac{a_0}{2} + \sum_{k=1}^{20} (a_k \cos(kx) + b_k \sin(kx))$

这不会是函数的精确表示，但你会看到，当你把阶数从 $k=1$ 增加到 2、3，依此类推，直到 20 时，你会得到对这个函数越来越好的近似。

所以，我们将累加 $k=1$ 到 20 的模式。我要做的第一件事是通过计算这些内积（在离散情况下是点积）来计算我的 $a_k$ 和 $b_k$ 系数。这正是我在这里做的。所以，我实际上是在计算我的函数 $f$ 的离散数据向量与第 $k$ 个余弦模式 $\cos(kx)$ 和第 $k$ 个正弦模式 $\sin(kx)$ 的离散数据向量的点积。

并且我需要进行归一化。我必须用我的离散步长 $\Delta x$ (代码中是 $dx$) 和外面的 $1/\pi$ 因子来近似这个积分并归一化这个内积。（具体实现是用点积乘以 $dx/\pi$）。

然后，我只是将这些第 $k$ 项 $a_k \cos(kx) + b_k \sin(kx)$ 加入到这个累加的和中（这个和从 $a_0/2$ 开始）。最后我要做的是把它绘制出来给你们看，并且这里有一个小的暂停 `pause`，这样每次我把阶数从 $k=1$ 增加到 2、3 直到 20 时，你都会在屏幕上看到一个新的近似函数出现。

好，我们来运行一下。

## 五、 结果展示与分析

你可以看到，随着你增加阶数，近似函数的颜色从黄色（低阶）到红色，再到深蓝色，最后到浅蓝色（高阶）。当你不断增加这个傅里叶级数近似的阶数时，你会得到对这个尖锐的三角帽函数越来越好的近似。

对于 $k=1$，你得到的是这种单一的波形，这不是一个很好的近似。但很快，随着你增加阶数，你开始相当好地近似这个函数了。

所以，这是一个很好的例子，展示了你如何能够近似——至少在这种情况下——一个连续函数。这个函数虽然有尖点（导数不连续），但函数本身是连续的，它在任何位置都没有跳跃。因此，傅里叶级数在近似这种连续周期函数方面会做得非常好。

## 六、 傅里叶系数与误差分析

好。现在，我想展示的最后一件事是绘制幅值。我们有所有那些 $a_k, b_k$ 傅里叶系数，也就是我累加的那些余弦和正弦的幅值，我想为你们绘制一些相关的东西。

在这里，我实际上将计算前一百个傅里叶系数。所以，我将令 $k_{max}=100$，计算从 $k=1$ 到 100 的系数。我不会绘制所有这些累加的近似函数，但我将绘制的是系数相对于模式数的变化。所以，从 $k=0$ 到 100，我将绘制的是模式幅值——也就是那些傅里叶系数的大小，比如 $\sqrt{a_k^2 + b_k^2}$ —— 以及我的重构误差是多少。

[此处指示发现并修正代码笔误] 我想我刚刚在我的代码里发现了一个小笔误，稍等一下。好的，除以 $\pi$。我稍微修改了我的代码，让它更美观一些，但我必须（在计算系数时）除以 $\pi$。好的，让我们确保这个... 如果你注意到，实际上这段代码比书中的代码要简洁一些。

现在，让我们绘制我们的幅值和误差。我真心希望这次能成功。完美。

好的。所以现在我们得到的是误差表现相对于模式数的关系图。这就是你想要的：你希望这是一个单调递减的函数。你希望你的重构误差——也就是这个有限项求和 $f_{approx}$ 对我的原始函数 $f$ 的近似程度，例如用 $\|f - f_{approx}\|$ 度量——随着你添加越来越多的傅里叶模式（即增加截断阶数 $N$）而单调减少。对于周期性的连续函数，你确实能得到误差的这种单调递减特性。

这意味着如果我有更多的计算能力，我可以添加更多的模式（比如计算到 $k=21, 22, ...$），就能得到稍微好一点的近似，稍微低一点的误差。这里的红点显示了一个特定的截断位置，我想大概是在 $k \approx 7$ 个模式左右截断的，你可以看到相应的误差值。

同时我们还绘制了模式幅值。它呈现出这种有趣的振荡模式，但总的趋势是随着 $k$ 增加而衰减。而模式误差（重构误差）确实在不断下降。而且请注意，误差图的纵轴是在对数尺度 (log scale) 上，所以即使只有几个模式，误差实际上已经非常非常低了。

现在，我觉得这个模式幅值图很有趣：它具有这种振荡模式，似乎每隔四个傅里叶系数（比如 $k=4, 8, 12, ...$），幅值就会变得非常非常小。如果你仔细观察 $k=1, 2, 3, 4, 5, 6, 7, 8$ 等等，你就能看到这一点，每到第四个系数时，近似函数的变化非常小。我能解释这一现象的唯一方式是，这必定与我选择的这个特定三角帽函数的某种对称性有关。某种对称性以某些傅里叶系数（在这里是每隔四个）非常小的形式体现了出来。

但这里的重点是，你可以用截断的傅里叶级数非常好地近似周期性的、连续的函数。我们甚至不需要加到无穷多个模式，我们在模式 20 处截断，就得到了对我们函数非常好的近似。

## 七、 结论

好的。所以现在你知道了如何在 MATLAB 中计算傅里叶级数：通过进行这些内积（在实践中是用离散数据的点积来近似）来获得傅里叶系数 $a_k$ 和 $b_k$。然后你可以把所有这些系数乘以对应的余弦和正弦项再加起来，即使只加有限项，也能得到非常好的函数近似。

好的，谢谢大家。

---

# 内容回顾

**一、 引言与目标**
- 介绍傅里叶级数 (Fourier Series) 的基本概念：用不同频率的正弦和余弦函数叠加来近似任意周期函数。
- 视频核心目标：演示如何在 MATLAB 中编写代码，计算一个周期性三角帽函数 (triangular hat function) 的傅里叶级数近似。
- 提及代码的可获取性 (databook UW / GitHub)。

**二、 MATLAB 环境设置与目标函数定义**
- 定义计算域：设置函数的周期范围，例如从 $-L$ 到 $L$，视频中选择 $L=\pi$，即区间 $[-\pi, \pi]$。
- 离散化域：在定义的区间内生成一系列离散的 x 坐标点 (例如 1024 个点)。
- 定义目标函数 $f(x)$：根据区间分段定义三角帽函数的具体形状，使其在中心区域上升和下降，两端为零。
- 可视化：绘制出在 MATLAB 中定义的原始三角帽函数图像。

**三、 傅里叶级数计算原理回顾**
- 傅里叶级数公式：一个函数 $f(x)$ 可以近似表示为：
  $f(x) \approx \frac{a_0}{2} + \sum_{k=1}^{N} (a_k \cos(kx) + b_k \sin(kx))$
  （注意：视频中 $L=\pi$，$\cos(\frac{k\pi x}{L})$ 简化为 $\cos(kx)$，$\sin(\frac{k\pi x}{L})$ 简化为 $\sin(kx)$）。
- 傅里叶系数 $a_k$ 和 $b_k$：这些系数是通过函数 $f(x)$ 与对应的正弦/余弦基函数进行内积（投影）计算得到的。
- 离散近似：在数值计算（如 MATLAB）中，连续函数的积分内积可以通过离散数据点的点积 (dot product) 来近似。

**四、 MATLAB 代码实现傅里叶级数计算**
- 计算 $a_0$ (零阶系数/平均值)：通过函数 $f(x)$ 与常数 1 (即 $\cos(0x)$) 进行内积计算，并进行适当归一化。这代表了函数的平均值分量。
- 迭代计算 $a_k$ 和 $b_k$ ($k \ge 1$)：
    - 使用 `for` 循环，从 $k=1$ 迭代到指定的截断阶数 $N$ (视频中示例为 $N=20$)。
    - 在循环内部：
        - 计算 $a_k$：通过 $f(x)$ 的离散数据向量与 $\cos(kx)$ 的离散数据向量进行点积 (`dot` 函数)，然后乘以归一化因子 (涉及步长 $dx$ 和 $1/\pi$)。
        - 计算 $b_k$：通过 $f(x)$ 的离散数据向量与 $\sin(kx)$ 的离散数据向量进行点积 (`dot` 函数)，然后乘以相同的归一化因子。
- 累加构建近似函数：
    - 初始化一个近似函数向量（通常从 $a_0/2$ 开始）。
    - 在循环中，将当前计算得到的 $k$ 阶项 $a_k \cos(kx) + b_k \sin(kx)$ 加到累积的近似函数上。
- 动态可视化近似过程：
    - 在每次循环（或每隔几次循环）后绘制当前的傅里叶级数近似函数。
    - 使用 `pause` 函数暂停，以便观察随着 $k$ 的增加，近似函数如何逐步逼近目标函数。

**五、 结果展示与分析**
- 近似效果：展示随着叠加的傅里叶模式（项数 $k$）从少到多（如 $k=1$ 到 $k=20$），近似函数如何从简单的波形逐渐变得越来越像原始的三角帽函数。
- 收敛性讨论：对于连续（即使有尖点）的周期函数，傅里叶级数通常能提供良好的近似，并且增加项数会改善近似效果。

**六、 傅里叶系数与误差分析**
- 计算更多系数：为了分析，计算更多阶的傅里叶系数（例如 $k$ 到 100）。
- 绘制系数幅值谱：绘制傅里叶系数的某种度量（如幅值 $\sqrt{a_k^2 + b_k^2}$）随模式数 $k$ 的变化图。
- 绘制重构误差：绘制傅里叶级数截断近似的误差（例如 $L_2$ 范数 $\|f - f_{approx}\|$) 随截断阶数 $N$ 的变化图（通常在对数坐标下）。
- 结果解读：
    - 误差趋势：重构误差通常随着包含模式 $k$ 的增加而单调递减，表明近似质量在系统性地提高。
    - 系数特性：观察到系数幅值可能存在特定模式（视频中发现每隔4个系数会显著减小），这通常与原函数的对称性等内在属性有关。

**七、 结论**
- 总结核心方法：可以通过计算函数与正余弦基函数的内积（在 MATLAB 中用点积实现）来得到傅里叶系数。
- 傅里叶级数的有效性：将这些系数与对应的正余弦项相乘并求和，即使只取有限项（截断傅里叶级数），也能对周期连续函数实现非常好的近似。
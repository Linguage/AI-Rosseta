# 「开放课程」MIT 计算思维（Julia）- 4：变换2：可组合性与线性

- 视频链接：[Transformations 2: Composability and Linearity | MIT Computational Thinking Spring 2021 | Lecture 4](https://www.youtube.com/watch?v=VDPf3RjoCpY&list=PLP8iPy9hna6T56GkMHEdSrjCCheNuEwI0&index=4)
- 官方频道：[链接](https://www.youtube.com/@TheJuliaLanguage)


### 讲座介绍

本篇内容整理自 MIT 计算思维课程（2021年春季）的第四次讲座，主题为“变换2：可组合性与线性”。

讲座深入探讨了数学和计算思维中的变换概念，重点关注线性和可组合性这两个核心特性。主讲人利用 Julia 编程语言及 Pluto 交互式笔记本环境，将图像处理作为一种直观且富有吸引力的实践载体，引导听众理解抽象概念。通过对柯基犬图像应用各种变换（如缩放、旋转、剪切、扭曲及自定义函数），并观察网格线的相应变化，讲座生动地展示了不同变换如何改变几何空间。内容不仅涵盖了线性与非线性变换的实例演示和直观理解，还澄清了关于线性变换的一些常见误区（例如，透视变换虽保持直线却非严格线性）。

此外，讲座还讨论了 Julia 中定义向量值函数的编程风格、函数组合在数学和软件工程中的重要性，并给出了线性变换的严格数学定义。最后，通过提出矩阵乘法定义背后的原因，为后续课程埋下伏笔。

### 内容纲要

```
Transformations 2: Composability and Linearity
├── 引言与准备
│   ├── 欢迎与课程主题介绍 (变换, 可组合性, 线性)
│   └── 介绍工具 (Julia, Pluto Notebook) 与 演示目的
├── 交互式探索图像变换 (使用 Pluto Notebook)
│   ├── 工具介绍 (图像, 网格线, 缩放/平移控件, 参数滑块)
│   ├── 变换演示与观察
│   │   ├── 线性变换示例
│   │   │   ├── 缩放 (Scaling)
│   │   │   ├── 翻转 (Flipping)
│   │   │   ├── 旋转 (Rotating)
│   │   │   ├── 剪切 (Shearing)
│   │   │   └── 任意矩阵变换 (强调矩阵即变换)
│   │   ├── 非线性变换示例
│   │   │   ├── 平移 (Translation, 严格非线性)
│   │   │   ├── 非线性剪切 (Nonlinear Shear)
│   │   │   ├── 扭曲 (Warping)
│   │   │   ├── 极坐标变换 (Polar <-> XY)
│   │   │   └── 自定义函数 (含参数 alpha, sin/cos 示例)
│   │   └── 关键观察点
│   │       ├── 像素与离散性
│   │       ├── 变换对网格的影响 (平行四边形, 扭曲)
│   │       ├── 局部线性性 (非线性变换在小范围近似线性)
│   │       ├── 逆变换 (组合抵消)
│   │       └── 奇异点 (图像折叠/重影)
│   └── 鼓励用户自定义与探索
├── 教学法讨论: 为何用图像处理学习 Julia
│   ├── 图像处理是载体/动机, 非核心目标
│   └── 类比: 学外语通过实际场景而非纯语法
├── 深入讨论线性变换与澄清误区
│   ├── 回顾“直线映射到直线”的讨论
│   └── 透视变换 (Perspective Map)
│       ├── Khan Academy 演示 (消失点)
│       ├── 证明其映射直线到直线
│       ├── 强调其*不是* R²→R² 线性变换 (网格变形非平行四边形)
│       └── 提及齐次坐标与高维线性表示
│   └── 其他非线性例子 (如指数函数变换, 验证非线性)
├── Julia 编程风格: 定义向量值函数
│   ├── 对比: 索引访问 `v[1]` vs 解构赋值 `(x,y),`
│   ├── 强调可读性优势
│   └── 匿名函数与参数化变换 (使用 `alpha -> ...`)
├── 变换函数集合展示
│   ├── 线性变换列表 (命名函数, 矩阵形式)
│   └── 非线性变换列表 (命名函数)
├── 函数组合 (Composition)
│   ├── 数学中的组合
│   │   ├── 示例: `sin(cos(x))` vs `sin ∘ cos`
│   │   └── 核心区别: 函数对象 vs 函数值
│   │   └── (附带讨论: Julia 中输入特殊符号 `∘`, `≈`)
│   └── 计算机科学中的组合 (Composability)
│       ├── 概念: 软件模块协同工作能力
│       ├── 重要性: 现代计算科学需求 (优化器/ML + 模拟)
│       └── Julia 的目标: 实现更广泛的自动组合
├── 线性变换的严格定义
│   ├── 必要条件: T(0) = 0
│   └── 等价定义方式
│       ├── 几何直观: 矩形网格 -> 全等平行四边形格点
│       ├── 代数操作: 存在矩阵 M 使 T(v) = Mv
│       ├── 保持运算: 分别阐述保持标量乘法与向量加法
│       └── 标准数学定义: T(c₁v₁ + c₂v₂) = c₁T(v₁) + c₂T(v₂)
│   └── 从变换到矩阵: 如何通过基向量计算矩阵列
└── 下次讲座预告
    └── 提出问题: 为何矩阵乘法是如此定义的?
```



---

# Transformations 2: Composability and Linearity | MIT Computational Thinking Spring 2021 | Lecture 4

## 引言与核心概念

大家好，网络世界的朋友们以及麻省理工学院的同学们，欢迎来到本周的 Julia 计算思维课程。

我们周末整理这个笔记花了很多心思，也觉得很有趣。所以今天的讲座不仅仅是关于变换（transformations），也许我应该先快速检查一下声音。能听到吗？（是的，响亮清晰。）好的，非常感谢。

除了讨论变换和各种数学主题之外，我们还将讨论可组合性（composability）。数学中的可组合性与计算机科学中的可组合性，尤其是软件的可组合性，是一个很大的话题。不过，让我先从玩转这个笔记本里的内容开始吧。上周三我们已经做了一点，但我认为直接动手玩起来很有趣。

## 交互式探索图像变换

你可以直接跳到“有趣的部分”（fun stuff），或者点击目录，选择任何你喜欢的变换来玩。我们就从这里开始。我用 $T$ 标记变换，用 $T^{-1}$ 标记它的逆变换。稍后我会解释为什么这样做，听起来可能有点反直觉，但我们把它称为 $T^{-1}$ 而不是 $T$ 是有原因的。

我把所有你需要的东西都尽量安排在一个窗口里能看到。你可能需要调整一下窗口大小，当然这取决于你如何调整，但我先把它缩小一点，让你看到全局，然后再放大细节。

你看，这里有网格线，它们被叠加在原始图像和处理后的图像上。我把右边的这个东西关掉，腾出点空间。我们有一个可拖拽的缩放工具，你可以用它来放大缩小。我们还有一个不错的平移工具。

**问：** 你能在你的笔记本上放大吗？

**答：** 我正打算这么做。可以的。太好了。（稍等一下。）问题解决了。是的。我还想能在这里展示出来。

好，快速演示一下怎么用这个平移。最终我们可能希望直接用鼠标操作，但现在这样也不错。这在 Pluto 里是可行的，你可以通过拖拽在 x 方向和 y 方向缩放。这是可以拖动的。

你还有这些参数。现在我们正在应用“扭曲”（warp）变换，你可以把可怜的柯基犬挤成一团，或者让它保持原样。当然，你也可以放任何你喜欢的图片。只需要把这里引号里的内容替换成你喜欢的任何网络图片地址，或者如果是你电脑上的文件，只需加载文件名即可。所以你可以尽情玩耍。

最棒的是，整个笔记本是完全自包含的。无论这个东西如何工作，所有的代码都在这一个笔记本里。这有一种魔力——也许前几学期的学生特别喜欢这点——当你从头到尾构建一个东西时，你会感觉完全掌控。在其他一些课程中，也许你们有人经历过，老师会给你大约 80% 的代码，让你去填补缺失的部分。我理解人们为什么这样做，但你总会感觉有点失控，不知道那些已有的部分是什么，哪些你没理解。所以，这里的全部内容都在这里。

在我们深入之前，让我们再玩一些函数。我准备了一些函数，你可以点击这些“线性变换”来看几个例子。我们有像缩放、翻转、旋转和剪切这样的变换。这些是线性变换。我们还有一堆非线性变换。“平移”严格来说是非线性的，虽然感觉上像线性的，因为线性的定义要求 $0$ 映射到 $0$。所以通常平移不满足这点。我们有这个将要玩的非线性剪切。扭曲（warping）显然是非线性的，还有一些其他的非线性函数。这里还有几个我们编造出来玩过的。

我非常鼓励大家自己编造一个函数，看看它会产生什么效果。同样，在多年的数学课程中，人们可能会画个小图，也许只看看一个正方形会变成什么样。也许会画条曲线。我猜用绘图工具，你可以更清楚地看到等高线会去哪里。但我喜欢图像，我喜欢真实的、实实在在的图像。我认为没有什么比它们更能帮助我们建立关于变换如何真正运作的直觉了。

所以，要强调的是，我们是把每个像素看作代表平面上的那个特定点。我们观察每个像素是如何移动的。如果可以的话，我真想放大到一个像素。看看能不能……我能做到吗？如果我说我现在能看到像素，那我是在骗自己。不知道。让我们再靠近一点试试。我再放大一些。这差不多是我能放大的极限了。我几乎觉得我看到了。是的，我看到像素了。它们像小小的矩形。不知道你们在我的缩放画面上能不能看到。（是的，我能看到。）你也看到了？太好了。

所以，我实际上是在处理像素。这增加了一点小小的复杂性。概念上不难，但比只处理连续曲线（就像数学课上那样）多了一点复杂性，因为像素是离散的。你必须处理这个问题。但我认为这是值得的，因为你能得到这些漂亮的图片。

如果可以的话，我再继续玩玩这些，就像我在用 Photoshop 一样。但这比 Photoshop 更好，因为我有控制权。我确切地知道这些函数是如何定义的，因为它们就在笔记本的某个地方。

我会在这里放大一点，然后——我希望你们能跟着我一起做，我不想只是自己玩得开心。当然，我可以这样玩一整天。但是，你知道，旋转柯基犬。就这样。这是在旋转柯基犬。它只是取这个参数 $\alpha$ 然后旋转。而且速度相当快，我觉得。

这就是旋转。但我也可以玩剪切（shear）。再次强调，你可以随时编造自己的函数。这是剪切函数。剪切的作用是，如果你愿意这么说的话，它会弯曲平行四边形。它们几乎变得认不出来了，对吧？我们可以反方向剪切。这就是剪切。

**问（评论）：** 水平线在剪切时保持在同一水平线上。

**答：** 是的，这是对的。剪切时确实如此。

我们现在可以——我们实际上可以用任何矩阵来定义变换。为此，这里这个矩阵就派上用场了。也许我稍微往下滚动一点。我感觉这里浪费了很多空间。（我知道 Dave 会想让我放大，但我想能够……）

**问（建议）：** 如果你把矩阵单元格移到像素旁边呢？

**答：** 我可以……没错。除了我总是搞砸这个。让我们试试。把像素移下来。这里。这其实是个好主意。好的。然后我就可以放大了。我总是忘记这东西是无限灵活的，对吧，这其实是需要记住的好事。

所以，这里我们正在应用这个矩阵。我倾向于认为，并且你会在笔记本后面看到更多关于这点的内容，在某种程度上，这个变换*就是*这个矩阵。所以我不喜欢把矩阵仅仅看作是数字的数组。我喜欢把它们看作是线性变换。如果你想对各种可用的变换类型获得一些直觉，你只需要玩弄矩阵的不同元素。你会看到——你会看到它对图像的作用，直到你得到那些又大又尖的平行四边形——我不知道该用什么词——你甚至认不出图片了。但是，同样，你可以稍微玩一下，看看它在做什么。

但关于矩阵有一点是肯定的，那就是一个矩形网格会变成一个由平行四边形组成的格点，对吧？大小相等的矩形网格会变成大小相等的平行四边形格点。在我看来，这才是矩阵真正的作用，不是一堆元素，而是字面上的，这种对柯基犬或你正在玩的任何其他图像的变换。我真心希望大家能这样看待矩阵，而不仅仅是数字表格。

好的，我们稍后会详细说明。但现在让我们再玩一会儿。

这里的符号 `∘` ——我稍后在笔记本里会提到，但现在先预告一下——这个符号表示“复合”（compose）。它的意思是，你先用 $-\alpha$ 进行剪切，然后再用 $\alpha$ 进行剪切。我现在可以把这个移开了。好，把它放回原处。这个表达式的意思是从右到左执行：先用 `shear(-alpha)`，然后用 `shear(alpha)`。你会注意到，它什么也没做。所以无论我把 $\alpha$ 改成什么，这个操作和这个操作都相互抵消了。我们说这些操作互为逆操作（inverses）。好的，这也会在这次讲座中出现。

让我们来玩玩非线性剪切吧，就这个。既然我们目前做的都是线性的，看看非线性操作可能是什么样子。这是一个非线性剪切。这里有些抛物线状的东西。我们实际上可以看看它的定义。但这些现在实际上是抛物线。但我希望你注意到的是，如果你只看一小部分，它仍然是一堆矩形，对吧？它略有弯曲，并且被扭曲了。但如果你在越来越小的区域内观察——在一个小区域内，一切几乎都是线性的。应用数学的很多内容都基于这样一个事实：如果你只在一个非常小的区域内观察，如果你把我原来的矩形画得更小，或者如果我画更多的网格线，你会看到很多——我猜我可以假装画一下。我的意思是，我猜我真的可以画出来。但让我假装画一下，因为这更容易。我的意思是，我认为很容易想象会是什么样子。如果这里有一条网格线——我只是徒手画，所以别太当真——我猜我画不好。但你可以想象，这些平行四边形，越小的那些，就越像平行四边形，越来越像一个线性操作。

好的？就像我说的，这正是应用数学中如此重要的部分，如果你只在局部看，如果你只看一个小区域，每个映射看起来都是线性的。事实上，在计算机出现之前，这差不多是唯一的办法，真的，就是假装一切都是线性的，然后祈祷最好的结果。这在计算机发明之前是大多数分析技术的核心。所以这是当时的主要方法。现在仍然有点是。

我还有一些其他的非线性变换。上次我给你们展示过，但我可以再玩一遍。我有“极坐标到xy坐标”（polar to xy），这有点疯狂。柯基犬被撕碎了，放在不同的地方。另一个是“xy坐标到r theta坐标”（r theta 1）。这是反过来的。你可以看到这种扇形散开的效果。我希望你们也在跟着我玩。但是如果你把两者结合起来——实际上，让我们先反过来做。如果你先把极坐标转换到xy坐标，然后再转换回来，完成一个来回，你会看到我们回到了原始图像。所以，转换到极坐标再转换回xy坐标——它们互为逆操作。

这里有一个我纯粹为了好玩编造的。你可以用任何你想要的函数。它依赖于参数 $\alpha$。所以我们可以稍微玩一下。（哦，我做了什么？我滚动了。）好的。让我看看。我把级别调低一级，希望可以，David？好的。但让我们玩玩 $\alpha$ 参数。当 $\alpha$ 为 0 时，什么也没发生。但随着 $\alpha$ 开始变大，可怜的小柯基犬被挤压和拉伸。我不知道它发生了什么。事实上，它出现了重影，对吧？所以这有点——所以并非所有映射都是一对一的。你看，当我这样做时，看，柯基犬有两个头。看起来几乎有点吓人。

平行四边形发生了什么——你会开始注意到。我现在可以放大。你会开始注意到这些平行四边形开始变得非常混乱，比如在这里，平行四边形被压扁到0。然后在这里，你可以看到它们看起来非常奇怪，对吧？函数可能会发生这种情况。这些被称为奇点（singularities）。它们对应于线性近似变得非常奇怪的情况。

所以这里有一些可以玩的东西。我不知道。我继续讲，有人有什么想看的函数吗？我实际上可以做任何你想要的函数。这些函数是从 $[-1, 1] \times [-1, 1]$ 映射到 $[-1, 1] \times [-1, 1]$ 的 x 和 y 坐标。所以如果有人有函数，或者看看聊天里有没有什么。好的，暂时没有。但如果有人想尝试一个函数，我不知道会发生什么。Dave，你有什么喜欢的函数想试试吗？

**问：** 来点带周期性的，比如正弦函数？

**答：** 哦。我完全不知道。试试看。所以——我想大概是像 $sin(5x)$ 这样的？

**问：** $sin(\alpha x)$？我们可以玩——哦，是的。好主意。我们来玩参数。$sin(\alpha x)$, $y$？还是 $(\alpha x, y)$ 开始？

**答：** 然后我们可以看看——看看会发生什么？我以前从没试过。好的。让我们看看。从 $\alpha$ 开始。让我看看。如果这是——也许我把 $\alpha$ 调低点。（现在你教我了，我可以这样做了。）让我们这样做。再次，我希望你们也在做同样的事情。但是这里，让我——我猜，我会让它非常有周期性。所以我想要一个大的 $\alpha$ 还是小的 $\alpha$ 来让它非常——就是这个。是的。就这样。不过挺好看的。天哪。太奇怪了。

**评论（来自观众）：** 有人建议希尔伯特曲线。

**答：** 我觉得那可能有点棘手——你得给我函数。是的。你得写下函数。你得——如果你写下来，我会复制粘贴进去。哦。这太诡异了。对我来说太诡异了。

**问：** 好的。让它更诡异些。在 y 上用余弦。

**答：** 哦，不。$cos(\alpha y)$ 和 [听不清] 一起？

**答：** 当然。让我们试试。我不知道这是不是——那根本不行。但你需要——是的。你可以把那个 $\alpha$ 调回 1，我猜，可能。虽然——我甚至不确定 $\alpha = 1$ 是否——是的。我不知道——我不知道那里发生了什么。是的。这可能是——哦，等等。我这里得到了一些东西。

好的。很明显，你可以做任意奇怪的事情。空白并不意味着它坏了。它只是意味着它超出了我们绘制的窗口范围。实际上是——

**评论：** 这是因为我们的原始图像嵌入在一个白色方块中。

**答：** 正确。这其实挺酷的。是的。你甚至可以用这种方式制作一种瓷砖图案或马赛克。就这样。Alan，你可以混合一下。所以你可以——你想要某种 $10 \alpha$ 乘以，比如，乘以 $y$ 什么的。我会后悔的。这会很糟糕吗？

**答：** 我想是的。嗯，不糟糕。是的。那还挺不错的。

好的。最后一次机会，有人想提一个你想玩的函数吗？但这——也许我只再提出一个教学观点——我这些年看到，也许有些学生也见过，教授们会做这些演示。过去是些 Java 小程序。你只能看到教授想让你看到的那些东西。他们可能选了几个函数。但我们认为你应该能够拥有任何你能想到的函数，只要把它放进去，就能拥有软件语言的全部能力和灵活性。这通常是你——我的意思是，有时这些小程序也提供编写自己函数的能力。但基本上，你是在写一个字符串。然后那个字符串不知何故需要被解析，转换成实际的代码片段。但在这里，我们直接就在写代码，因为我们基本上有这种交互性。是的。所以它完全是实时的。

好的。所以你明白了吧。我们有这些——让我们回到恒等变换（identity），把一切恢复正常。

## 为何通过图像处理学习 Julia？

我们有这些图像。也许现在，如果可以的话，再谈一点教学法。你们上这门课到现在已经是第三周了，一直跟着我们。也许你在想，我们为什么要做图像处理？这是一门图像处理课吗？我的意思是，确实有图像处理的课程。但你可能已经从我这里了解到，这不是一门图像处理课。图像处理仅仅是驱动力。我们认为玩图像非常有趣。我们真正想教的是计算机科学、数学和 Julia 编程的这种结合，我认为只有用我们现在的方式才能做到。

你会看到，接下来出现的其他模块也会有同样的动机。我试图做的类比——在我们组织这门课时——是回想我学习一门外语的时候。我在麻省理工学院读研究生时，在麻省理工上了一门法语课。我记得那本教科书。整本书的目标是学习法语。但你不仅仅是学法语。每一章，都有一个法语结构，但也有如何在巴黎的咖啡馆点咖啡，或者如何去邮局，或者如何洗衣服。我的意思是，所有这些非常实用的东西，你知道，如果你在法国的话。你还会学到像法国文化这样的东西，对吧，人们如何思考事物，哪些东西是不同的。

所以在某种程度上，这个类比一直伴随着我——我们想教 Julia。但我们想通过一个应用来教，就像洗衣服或点咖啡一样。所以图像处理就成了那种文化背景，如果你愿意这么说的话，这样我们就能在一个真实生活的语境中呈现学习 Julia 的过程。好的？否则，最终就会变成那种在我看来非常枯燥的东西，比如这里是一个 For 循环，这里是一个 If 语句。我的意思是，我无法想象，对我来说，有什么比 For 循环和 If 语句更无聊的了。

## 对线性变换的深入讨论 (及澄清)

好的。上次讲座还有一些遗留问题。其中一位朋友——我想是在 Discord 上——问到，什么是线性变换？当时有一个有趣的错误答案。我喜欢有趣的错误答案。有趣的错误答案比正确答案好得多。我希望大家总是给我有趣的错误答案。

有人提出了类似这样的观点：如果一个变换将直线映射到直线，并且可能保持原点不变，那么这或许就是一个线性变换。我隐约记得，当有人这么说的时候，我并没有完全准备好同意。我不知道，也许我该回去看看录像，看看我当时到底是怎么说的。但我记得当时我不太确定，这是否足以使其成为传统意义上的线性变换。目前，让我们先把线性变换理解为那种能将矩形网格变成漂亮的平行四边形格点的变换。

我们找到了这个透视映射（perspective map）。我很想用 Julia 来实现它。但我们从可汗学院（Khan Academy）借用了这个例子。它展示了如果你在地板上有一个漂亮的矩形网格，然后你从某个角度（透视地）看它——你们中有些人可能知道这个最初源于艺术的概念，消失点（vanishing point），对吧？平行线，当你画它们时，都会汇聚到一个点，称为消失点。

这里有一个来自可汗学院的很好的演示。我把它打开了。再次强调，我很想在 Julia 里实现它。可能不会太难。但我当时想就直接给你们看吧。我把走廊去掉，甚至可能把第二个消失点也去掉。在这里你可以看到——我就是喜欢能移动这个。这些，在现实世界中——在现实世界的平面上，这些绿线都是平行的。从不同的角度，你会看到不同的透视效果。

好的？这里的第二个消失点是这样的。你可以这样移动。你可以玩各种各样的东西。现在让我们引入第二个消失点。第二个消失点包含了所有的对角线，对吧？所以如果这最初是一个正方形或矩形，蓝线就是矩形的对角线。从这个角度看，红线保持平行。它们是水平的。

但我的关键点是，所有的直线，不仅仅是你看到的这些，而是这里所有的直线，实际上都会变成直线。所以这个透视变换，你总可以调整使得原点映射到原点。这不是问题。这正好说明了，“点映射到点，直线映射到直线”并不足以保证线性。你不会得到那些漂亮的平行四边形，对吧？很明显，这些是某种梯形的，对吧？它们不完全是平行四边形。它们肯定不是全等的（congruent）。

顺便说一句，为了快速论证为什么直线会变成直线，也许值得做一下：如果你有——如果你有，比如说——这是你的眼球。我就是这么画眼球的。不知道。这是你的眼球，你有一个平面，你正在投影到另一个平面上，它们不必平行，那么如果你这边有一条线，你从这个点进行投影，你会创建一个相交的平面。然后这边就会有一条线，对吧？这就是图像。所以无论你在现实世界中有什么样的直线，这条线和你的眼睛构成的平面会在像平面上产生一个交线。而两个平面的交线永远是一条直线。这就是你的快速数学证明。

好的？但是感谢外面提出这个精彩错误答案的朋友。这样我们才能实际去探索它。

好的。我们上次讲座还遗留了什么？让我看看。好的。我们上次定义了这些函数。

我想再展示一个我们想出来但并不奏效的例子。所以这里，纯粹为了好玩。这也许是计算思维的另一个方面，你可以用你的大脑思考，但你也可以用计算机来做。而且，你知道，我认为智慧在于知道——我知道，数学系的人会说，你应该总是用你的大脑。而我猜其他人会说，你应该总是用你的计算机。我认为智慧在于知道什么时候用什么。

你需要 xy 平面。对。我看到了。我看到了。

[此处原视频有一段关于如何输入特殊符号的讨论，已整合到“函数组合”部分]

让我看看，我这个写对了吗？哦，是的。好的。这个能行。也许我应该——把东西上下颠倒了，但无所谓。让我们——我不知道。也许——（听不清）是逆变换？是的。我知道。让我们看看能不能——我不知道。这有点反复试验。但我想让你们看到的主要一点是，这个映射 $T(x, y) = (e^{kx}, e^{ky})$ 保持了水平线和垂直线。所以你可能会想，好吧，这也许是个例子。但是如果你——它不保持其他直线。我们可以快速验证的一种方法是，我可以将它与一个旋转变换复合，对吧？所以让我们把它旋转，比如说，我不知道，随便多少，1 吧。

我做了什么？我做了什么？

**答：** 你需要把整个非线性变换放在括号里。

**答：** 括号是我——哦，不。等等。不。

**答：** 你先写的那部分。是的。这部分？

**答：** 整个。整个是一个函数。你想复合两个函数。不。不是那里。

**答：** 在红色那个东西之前。

**答：** 哦，是的。我现在明白了。谢谢。

**答：** 哦。它看起来——它看起来还是直的。

**答：** 因为顺序反了。你需要旋转中间那个。你需要旋转。这大概是用电脑做事的另一个麻烦之处。你还是得确保做对了。

**答：** 好了。谢谢。是的。

事实上，我可以——让我们把 $\alpha$ 放在这里。也许我甚至不需要这里的 $\alpha$。让我们把它去掉吧。你可以看到——让我们设为 -10。好的。所以你可以看到这些线在旋转之后，绝对不是水平和垂直的了，对吧？所以很容易构造出那种水平和垂直线保持不变，但其他直线显然被完全搞乱了的映射。

**问：** 我喜欢这些线变粗的方式。

**答：** 你喜欢吗？是的。我们放大。因为它在发散，对吧？我的意思是，这里有某种奇点，它正在趋近。我不知道我能不能把它平移一点。不。我想要更多，我能看到更多吗？我不知道。所以如果我放大，我能看到更多吗？是的。它变得渐近了。是的。看起来确实是这样。

所以这是发现各种你从未知道函数能做到的现象的一个好方法。

好的。我们还有什么？风格，然后是带参数的函数。

## Julia 编程风格：定义向量值函数

好的。这里我们上次定义了这些函数。我只是想稍微谈谈风格。这是那种如果你只关心代码正确或者得到正确答案，你可能不会在意的事情。但如果你想更优雅，让代码更具可读性，那么这——那么这对你就有用了。

Alan，也许再放大一点，拜托了。（这在我眼里已经很大了，但好吧。）好的。（这很好。）实际上现在，这就像个 PowerPoint 幻灯片了，这可能正是重点。所以，是的。让我看看。我几乎可以放这么大。好了。好主意，Dave。谢谢。

（Philip 对此有一些评论。来吧，Phil。请随意。）（我可能得关上我的门。等等。抱歉大家。）（他声音还是很大。好的。）

我想请你们每个人看看这一行和这一行，告诉我哪一个更容易阅读。我认为这不会有太大争议。

**评论（来自观众）：** Charles 有一个关于透视的好问题。

**答：** 我稍后会回到那个问题。我喜欢你的问题，Charles。是的。好的。

我相信你们都会同意，看到 `x` 和 `y`，这种 `x` 和 `y` 的方式——一位学生也同意了——这样读起来容易得多。再次强调，从数学角度看，这无所谓。你可以用 `v[1]`, `v[2]` 来索引。你可以写索引。数学上行得通，计算上也行得通。但如果你想作为一个人类来阅读这些代码，毫无疑问第二种方式比第一种更容易阅读。

所以我选择实际这样写代码，写函数，更像这样而不是那样。还有其他一些选择。但有人可能会问，为什么我实际上会——这看起来可能比这个稍微容易读一点，虽然这个也不难读。这个，我提醒大家，是上节课讲的匿名函数，顺便说一句，我们给它命名了。我总觉得说这是一个匿名函数有点别扭，但我现在给它命名了。所以感觉它不再是匿名的了。但这是一个匿名函数，现在被命名为 `f`。

这样做的原因是，这些匿名函数允许你放入那些参数。所以能够通过 $\alpha$ 来旋转，或者通过 $\alpha$ 来剪切，或者通过 $\alpha$ 来扭曲，就变得非常有趣。所以如果你去看这些函数的定义——我用这个目录把它们带回来。这是我的线性变换集合。你会看到，当我有参数时，我使用了匿名函数格式。好的？所以这个函数 `scale_x(alpha)` 会缩放 x 坐标。当没有参数时，我就用了短函数格式。所以这些是短函数格式，每当我有参数时。这让你能放入参数。好的？这就是为什么我们会使用匿名形式。它使这成为可能。

**回到 Charles 的问题**

让我回到，如果可以的话，Charles 的有趣问题。关于这个透视。

**问（Charles，转述）：** 我以为透视是线性变换。

**答：** 这可能是有原因的。如果你在别处见过这些东西，你实际上可以用矩阵来做这个。但有趣的是，如果你想做 $2 \times 2$ 的变换，如果你在某处见过，如果你想做像我们在这个笔记本里做的 $R^2$到$R^2$的透视映射，你需要 $3 \times 3$ 的矩阵。事实上，如果你想做三维变换，你需要 $4 \times 4$ 的矩阵。而你所做的最终是除以某个东西。所以如果你去看，你会发现它们——它们内部有线性性，但它们本身不是线性的。

**问：** 不对，等等。我以为——我以为你知道，你做的方式是给向量增加一个常数项，对吧？总是 $(x, y, 1)$ 被一个——

**答：** 对，那些是齐次坐标。没错。这就是它如何变成三维的。对。
**问：** 但它怎么——但如果——那它不就是线性变换了吗，如果——
**答：** 它在 $(x, y, 1)$ 上是线性的。

**答：** 对。好的。然后你必须做些什么把它放回平面上，对吧？

**答：** 所以通常，除以什么，是三个数的和吗？我想那里有一个除法。

**答：** 所以这个组合严格来说——它内部有线性的部分。但整体上严格来说不再是线性的了。
**评论（Dave）：** 我好像不知道这个。看吧？每天都能学到新东西。

好的。我和 Dave 试图找一个好的例子，能把直线映射到直线，这很有趣。我想出了各种奇怪的例子——我们还有其他例子——

## 函数与参数

这里只是一个带参数的函数的例子。

## 线性变换集合

好的。在这次讲座中继续前进，我们编造了一堆线性变换。其中每一个都可以只用一个矩阵来写。但从某种意义上说，并不是说你应该把每一个都用矩阵来写，因为有时矩阵是小题大做（overkill）。认识我的人都知道我喜欢线性代数的东西，从没听我说过“有时矩阵是小题大做”。人们听到我这么说会很惊讶。但有时矩阵确实是小题大做。比如，如果你只是交换 x 和 y，或者如果你只是翻转 y，可能——你不需要一整个矩阵来做这个。事实上，这些似乎都不真的需要矩阵。

然而，如果你确实想要一般的矩阵，并且你看到了这种情况，这里是你如何写一般矩阵的方法。你可以输入四个元素 $a, b, c, d$，然后得到——这是矩阵乘以向量。所以你用这个矩阵乘以向量 $(x, y)$。你得到 $ax + by$ 和 $cx + dy$。或者你实际上可以直接进行矩阵向量乘法。所以这是另一个花哨的 Julia 写法。我不知道我是否应该解释它。但如果你注意到，我在这里做的是定义了一个矩阵的线性变换。好的？我把它定义为矩阵乘以——所以它会接收一个向量并解构成元组。好的？总之，那是花哨的 Julia。让我只说这只是——这只是让我——

**问：** 你可以直接写成 `v -> M * v`？（意指直接用向量输入，不解构）

**答：** 是的。但我刚才不是刚强调了不要那样做吗？但我本可以，对吧？

**答：** 对。我的意思是，关键是我们一直在使用——

**答：** 我们一直在使用解构形式。所以我们要保持这种格式。好的。

## 非线性变换集合

这是我的非线性变换，比如非线性剪切——这是扭曲（warp）。扭曲实际上只不过是一个依赖于你位置的旋转。所以能这样写出来其实挺好的。你离原点越远，你旋转得越多。这就是为什么当你远离原点时，你会得到那些大的扭曲。好的。这是 xy 到 r theta 的转换。这里还有几个我玩过的函数。

## 函数组合 (Composition)

但这里，让我们谈谈组合（Composition）。组合是一个重要的——简单但重要的概念。好的。为了讨论组合，让我们先从基本函数，单变量函数的组合开始。

这是一个 $sin(cos(x))$。这是复合了 $sin$ 和 $cos$ 的函数，并在 $x$ 处求值。让 `xp` 是某个随机数。在 Julia 中，我们可以用这个约等于 `≈`（`\approx`），以防万一有一点数值误差——我的意思是，我们可以用 ` == `  Ω，这实际上——它可能是 false，也可能不是。哦。实际上，在这种情况下，没有数值舍入误差。所以我不需要——我不需要 `approx`。但只要有浮点数，我就会用 `approx`。这样我就不用太担心了。

**评论：** 这是因为 `sin ∘ cos` 就是被定义为——

**答：** 它就是被定义为这个。对。所以它们做的是完全相同的事情。句号。这很清楚。

我想强调一下，因为这种事情即使在数学课上也会有点混淆，就是 $sin$ 和 $sin(x)$ 的区别。问题在于，在数学中，这变得非常非常混乱。所以我想在 Julia 中，或者在数学中，讨论一下这个对象，以及，也许，这个对象，对吧？

$sin(x)$ 是一个数，对吧？如果我输入某个数 $x$，就会输出 $sin(x)$。当然，如果我说 $f(x) = sin(x)$，这在数学中会有点混淆。你可能指的是数学中的 $sin$ 函数，而不是 $sin$ 在某个特定数值处的求值。我们人类非常擅长不去担心这个问题，除非我们是在计算机上做事情。

但在计算机上，函数本身可以是一个对象，比如 `sin`，对吧？这个对象存在，无论你是否对它求值。希望大家都明白我的意思。所以这有点计算机科学的味道。它也是数学。这个东西 `sin` 是一个函数。好的？它不会去求值。它只是一个东西，对吧？它可以——它可以与 `cos` 复合。现在这个东西 `sin ∘ cos` 是一个函数。如果我愿意，我可以去对它求值，就像我在这里做的那样。

而另一方面，这里是——你看到区别了吗？在这里，我取数 $x$，得到一个数 $cos(x)$。然后我再去得到另一个数 $sin(cos(x))$，对吧？在右边，这个函数 `sin ∘ cos` 从未存在过。它只在左边存在。所以我不知道这是否让大家费解。

**问：** 我有一个有点傻的问题。当你使用特殊符号时，我看到你输入它们，有没有办法如果我看到特殊符号就知道（怎么输入）？你能只是鼠标悬停在上面或者怎么样吗？让它告诉我——

**答：** 嗯，你可以复制粘贴它。

**问：** 不好意思。很棒的问题。但是答案——因为我真的不想在我试图通过例子编程时，如果可以避免的话，还得去查其他页面。

**答：** 在大多数情况下，它是 LaTeX 的命令。所以你可能，如果你懂 LaTeX 的话，可能已经知道了。是的。Dave，有没有办法真的知道？在我看来，似乎你应该，当你在 Pluto 或其他地方鼠标悬停在它上面时，它就应该告诉你。

**答：** 那会很好。这是——它真的会鼠标悬停吗？让我们——也许它会。你能点击那里打开 Live Docs 吗？

**答：** 我正打算这么做。是 `isapprox` (`≈`)。哦。但这没有完全回答 Charles 的问题。

**答：** 如果你去 REPL（命令行交互界面），你可以做到。你能试试打开 REPL 然后对那个符号用问号吗？

**答：** 那样我就得切换我的屏幕了。REPL 就是指终端，当你从终端运行 Julia 时。

**答：** Dave, Dave, Dave, Dave，那会改变我的屏幕共享。我只共享了这个浏览器。那会分开——

**问（建议）：** 当你鼠标悬停时，它就告诉你那个——是的。那不是个疯狂的想法。我们应该告诉 Fons（Pluto 的开发者）。他们可能会实现它。

**答：** 我们鼠标悬停时得到的是函数名。所以如果——
**问（Dave）：** 你想让我共享我的屏幕吗？

**答：** 当然。确定吗？为什么不呢？那会很有趣。我们来试试。稍等。

（Dave 演示在 Julia REPL 中使用 `?` 查询符号的输入方法）

**Dave：** 你能在我的终端看到吗？

**答（Alan）：** 我们确实看到你的终端了。

**Dave：** 好。我刚刚启动了 Julia，无论你是怎么启动 Julia 的，我这里是从命令行。或者你知道，我可以通过搜索 Julia 可执行文件来启动。现在我在命令行运行 Julia，而不是在 Pluto 里。我要输入问号，然后输入这个我不知道怎么打的符号 `∘`。当我输入问号时，它实际上——这是普通的 Julia 提示符。我可以在这里写 Julia 代码，`x = 3` 然后问 `x` 是什么。但如果我只输入问号，它会立刻把提示符变成这个帮助提示符。所以我们现在在帮助模式。如果我输入这个 Unicode 符号的名字（此处应指直接粘贴符号），它实际上告诉我——它首先告诉我的是我如何在 Julia 中输入它。

**答（Alan）：** 等等。那我能不能——让我把屏幕拿回来，如果可以的话。（这能回答你的问题吗，Charles？这肯定在 REPL 里回答了 Charles 的问题。Charles，[听不清]。）但我能不能——我能不能做些——我不知道怎么在 Pluto 里直接做同样的事情。我能在——它不帮助——

**答（Dave）：** 是的，是的。是的。哦。这是——这现在是个 Pluto 的问题。我相信有办法。但我现在想不起来是什么。

**答（Alan）：** 好的。我们会找出答案，然后也许甚至加上鼠标悬停提示。我的意思是，有件事——我猜你能做的另一件事是如果你去——

**问（Charles）：** 如果当鼠标悬停时能提示就好了。因为每当我读到什么时，我都想能够写出来，对吧？如果转换只单向进行，而反向转换需要费力气——

**答（Alan）：** 这是对的。那就成了——就像我刚才展示的，这个信息在 Julia 中是可用的。我只需要知道如何在 Pluto 中获取它，而不是从命令行。

还有一件事你可以做，这不能回答 Charles 的问题。但这是一个相关的问题，那就是我可以输入 `\` 加 `:` 加 Tab 键，看到各种各样的 Unicode 符号列表。你可以选一个你喜欢的。例如，你可以选一头牛 `🐄`。然后按 Tab，对吧，然后你就得到了表情符号。是的。然后你可以 `cow = 2`。然后你可以求你的牛的平方根，以及各种各样的事情。所以，是的。这里有一堆有趣的符号。这实际上很有用。例如，我看到数学系的一位讲师，Chris [听不清]，他展示微分方程。有很多微分方程的例子，里面有狼和兔子之类的，狼和兔子。大家总是用 W 和 R，对吧？但是你知道，Chris 用的是狼 `🐺` 和兔子 `🐇` 的图片。用这个比字母好多了。它实际上在代码中也有效。比字母好太多了。

**评论（来自观众）：** 显然，如果你点击 Live Docs 并将鼠标悬停在符号上，它在 Pluto 中已经可以工作了。

**答（Alan）：** 你在开玩笑吧。你能鼠标悬停在同一个符号上吗？好的。是的。是的，是的。它确实。说——它确实说这个符号可以在 Julia REPL 和反斜杠点击中输入。哦。好吧，也许你得到了你想要的。让我们看看。是的。

**评论：** 我认为它不适用于所有符号。

**答（Alan）：** 是的。这是我的方法。这真的取决于帮助文档是如何写的。是的。当我鼠标悬停时，这并没有发生。我没有得到右边弹出的那个东西。你是怎么——

**答（观众）：** 我是从这里的 Live Docs 得到的。

**答（Alan）：** 哦。我明白了。你点击了下面的 Live Docs。我明白了。好的。非常好。我确实打开了它。太棒了。是的。我们绝对应该把符号（提示）弄好。

**评论（来自观众）：** 有人说你可以运行 `?` 然后跟一个符号。

**答（Alan）：** 是的。但我有点担心 Pluto。但是，是的，那实际上并不告诉你所有这些符号的信息。所以这需要修复。是的。那会很好。

好的。好了。在数学中组合函数，在计算机科学中组合函数。我差不多已经说了，你是否能在该语言中实际命名组合，对吧？所以这实际上是在我们能命名 `sin ∘ cos` 函数之前。而这是你可以玩的一等对象（first-class object）。

哦。但是这里，Charles，你——

**问（Charles）：** 对于 `≈` (`approx`)，我没看到它告诉我怎么输入。

**答（Alan）：** 它没有。这就是他们刚才说的。它没有。好的。所以我的意思是，我只能说对于 `approx`，你可以输入 `\` `approx`——

**答（Dave）：** 对。加 Tab。

**答（Alan）：** 是的。对。但是，是的。它不是——这是我们需要修复的东西。那会很好。

这里有一个更大的观点，是现在很多人都在谈论的事情，一个更宏大的计算机科学观点，那就是在更高层次上软件的组合。关于这点我可以说很多。你可以阅读我写的内容。但在一个人人匆忙，人人都在写代码完成老板、导师、论文导师交给他们的任务的世界里，被告知“把这个东西弄好，让它做这个、那个以及其他事情”，如果别人去写了另一个函数，相当罕见的是，我认为可以公平地说，即使这两个函数在概念上可以协同工作，它们也未必能实际协同工作。

例如，你可能有一个简单的函数用来连接字符串，好的，但也许它不能连接数字，对吧？所以，让软件能够组合是一件非常大的事情。如今每个人都想要的计算科学应用是，你有一个非常非常大的代码，可能是多年积累下来的。现在你想要做的是在它外面包一个优化器。你只想调整一个参数。它内部可能在求解一个复杂的微分方程。它可能在做各种各样的事情。但你只想改变 $\alpha$。你并不真的想关心内部是什么。很多代码会崩溃。如果它没有崩溃，我们就处于一个幸运的位置，可以说它是可组合的，优化器与内部的代码是可组合的。有时人们想做机器学习神经网络，外面有一个微分方程，你看。所有这些类型的事情都是人们现在想做的。

我们真正寻求的，这也是 Julia 社区正在努力的方向，是为了——我的意思是，在某个完美的世界里，一切都与一切可组合。我的意思是，那是梦想。Julia 在某种程度上正在接近这个目标，让在蒙古写这段代码的人和在南卡罗来纳写另一段代码的人，它们的代码就能一起工作，即使这些人没有为此计划。他们没有握手。他们没有写规范让它们一起工作。它就是能工作。当这种情况发生时，对于组合来说，这是一个非常令人高兴的局面。

所以组合这个想法，无论我们谈论的是组合一个单变量函数、多变量函数，还是一般的软件，它的思想就是你可以做一件事，然后做另一件事，它就能一路畅通无阻。

## 线性变换的严格定义

好的。所以让我——我可以——跳过这个。让我们谈谈——这是我说过一会儿要谈的。我快没时间了。但至少让我给出线性变换的定义。

你们已经听我说过，当你看到一个矩阵时，我希望你如果可以的话，不要再把它想成一个数字表格了。这里有几个关于线性变换官方含义的定义。

你总是必须满足 $0$ 映射到 $0$。除此之外：
- **几何角度（操作性定义）**：矩形网格线变成由全等平行四边形组成的格点。这会是一个非常好的操作性定义。
- **代数角度（操作性定义，但有点反直觉）**：如果一个变换可以被定义为一个矩阵乘以一个向量，那么它是线性的。这与我希望人们思考的方式相反，但这是定义。
- **保持运算的定义（分开）**：
    - **保持标量乘法**：如果你先将一个向量缩放然后变换它，这与你先变换向量然后缩放得到的结果相同。即 $T(c \cdot v) = c \cdot T(v)$。
    - **保持向量加法**：如果你变换向量的和，这与你先分别变换向量然后求和的结果相同。即 $T(v_1 + v_2) = T(v_1) + T(v_2)$。
- **数学家的标准定义（合并上述两点）**：这两个可以合并成一件事。这是通常的数学定义。我们称 $c_1 v_1 + c_2 v_2$ 为线性组合（linear combination），正如我们在之前的讲座中看到的。我们说，一个线性组合的变换等于变换后的线性组合。如果对于所有的数 $c_1, c_2$ 和所有的向量 $v_1, v_2$ 这个等式 $T(c_1 v_1 + c_2 v_2) = c_1 T(v_1) + c_2 T(v_2)$ 都成立，我们就说这个变换是线性的。

所以回到，某种程度上，Charles 的问题，这个性质对于透视变换来说并不完全成立。所以这个会失败。好的？

数学家喜欢从这个定义开始，然后再导出矩阵。好的？我会说，不，不是那个“Matrix”（指电影《黑客帝国》）。但那是个好电影。但是，如果你先有了变换，但没有矩阵，你总是可以通过观察 $T$ 作用在 $[1, 0]$ 向量上——那是 x 方向的水平向量——然后 $T$ 作用在 y 方向的垂直向量 $[0, 1]$ 上来得到矩阵。因为 $T([1, 0])$ 将是你矩阵的第一列，而 $T([0, 1])$ 将是你矩阵的第二列。一旦你知道了这两列，你就可以通过线性组合得到 $T$ 在任何地方的作用。

## 下次讲座预告

好的。我就在这里停下，因为我不想超过两点。我可能已经用完了我的微小时间。

所以下次我将从这个问题开始——至少让我问你们这个问题。你们都学过如何乘矩阵。如果你上过 18.02（MIT 的多元微积分课程），你在那里见过，也许在别处也见过。你有没有停下来想过，为什么矩阵乘法有那个奇怪的定义？比如，你知道，矩阵加法，你只是把所有对应的元素相加。为什么矩阵乘法不能是对应元素相乘呢？是谁规定矩阵乘法那么复杂的？你问过吗？或者也许你们都是好学生。当你的老师告诉你，这就是你如何乘矩阵时，你就只是听了。好的？

好吧，如果你从未想过，或者即使你想过，下次讲座我将开始讨论为什么矩阵乘法真的是它现在的样子。好的？它是如何——它是如何变成这个重要的东西的？好的？

好的。我要闭嘴了。我要跟网络世界的朋友们说再见了。麻省理工学院的学生如果愿意可以留下来。我们可以和他们聊一会儿。或者我能这样做吗？或者说，是的。我要停止直播了。好的。再见，网络世界。



---

# 要点回顾

**1. 引言与核心概念**
- 介绍本讲座的主题：变换（Transformations），重点关注可组合性（Composability）和线性（Linearity）。
- 使用 Julia 语言和交互式 Pluto 笔记本来进行探索。
- 强调可组合性在数学和计算机科学（尤其是软件工程）中的重要性。

**2. 交互式探索图像变换**
- **演示工具**：使用一个包含可交互元素的 Pluto 笔记本（如图像显示、缩放、平移、参数滑块）来可视化变换对图像（以柯基犬为例）的影响。
- **变换的表示**：使用 $T$ 表示变换，$T^{-1}$ 表示其逆变换（原因稍后解释）。
- **变换效果**：
    - 网格线叠加在原图和处理后的图像上，直观展示变换如何扭曲空间。
    - 像素是离散的，变换作用于每个像素点。
    - 局部观察：即使是非线性变换，在足够小的局部区域内也近似于线性变换（小块区域看起来像平行四边形）。
- **演示的变换类型**：
    - **线性变换**：缩放（Scaling）、翻转（Flipping）、旋转（Rotating）、剪切（Shearing）、任意矩阵变换。
        - 强调矩阵即线性变换：矩阵不仅仅是数字阵列，其本质是空间变换，将矩形网格变为平行四边形格点。
    - **非线性变换**：平移（Translation，严格来说非线性，因 $T(0) \neq 0$）、非线性剪切（产生抛物线形状）、扭曲（Warping）、极坐标转换（Polar to xy, xy to r theta）、自定义函数（如包含 $sin$, $cos$ 的周期函数）。
    - **逆变换**：展示了某些变换对（如 `shear(-alpha)` 和 `shear(alpha)`，或极坐标与直角坐标互转）组合后相互抵消，恢复原状。
    - **奇异点 (Singularities)**：某些变换（如自定义的 `alpha` 参数变换）可能导致图像折叠、出现多重影像或网格被极度压缩，这些是变换的奇异点。
- **鼓励探索**：鼓励听众尝试自定义变换函数，通过实践建立直觉。

**3. 为何通过图像处理学习 Julia？**
- 图像处理是学习 Julia、计算思维、数学和计算机科学结合的有趣*载体*和*动机*，而非课程本身的目标。
- 类比：学习外语（如法语）时，通过实际场景（点咖啡、洗衣）和文化背景来学习语言本身，而不是枯燥地学习语法规则（如 For 循环、If 语句）。

**4. 对线性变换的深入讨论 (及澄清)**
- **回顾误区**：讨论了“将直线映射到直线”是否足以定义线性变换。
- **透视变换 (Perspective Maps) 示例**：
    - 透视变换（如艺术中的消失点效果）确实将直线映射到直线。
    - 可以通过几何（视点、直线、成像平面构成相交平面）来证明这一点。
    - 然而，标准的二维透视变换*不是*线性变换（它不保持原点，且矩形网格会变成梯形或大小不一的四边形，而非全等的平行四边形）。
    - 提及透视变换可以用*齐次坐标*（如使用 $3 \times 3$ 矩阵处理二维点 $(x, y, 1)$）表示为更高维度的线性变换，但在原始的 $R^2 \to R^2$ 空间中，经过必要的“除法”步骤后，它不是线性的。
- **其他非线性例子**：构建了 $T(x, y) = (e^{kx}, e^{ky})$ 这样的变换，它保持水平和垂直线，但旋转后的直线会被扭曲，证明保持轴向直线也不足以保证线性。

**5. Julia 编程风格：定义向量值函数**
- **可读性对比**：比较了两种定义接收向量 `v` 并返回新向量的函数的方式：
    - `v -> [v[1]*..., v[2]*...]` （使用索引）
    - `((x,y),) -> [x*..., y*...]` （使用解构赋值）
- **推荐风格**：后者通过将输入向量/元组直接解构为变量 `x` 和 `y`，代码更易读、更符合数学直觉。
- **语法解释**：`((x,y),)` 中的逗号是为了定义一个接受*单个*参数（向量或元组）并将其解构的函数，而不是接受两个独立参数 `x` 和 `y` 的函数。
- **匿名函数与参数**：使用匿名函数（如 `alpha -> ((x,y),) -> ...`）可以方便地创建带有参数（如旋转角度 `alpha`）的变换函数，适用于交互式滑块。

**6. 函数组合 (Composition)**
- **数学中的组合**：
    - 以基本函数为例：$sin(cos(x))$ 是先计算 $cos(x)$ 的值，再计算 $sin$ 的值。
    - 强调 $sin(x)$ 是一个*数值*，而 $sin$ 是一个*函数对象*。
    - 函数组合 `sin ∘ cos` (在 Julia 中用 `\circ` 输入) 产生一个新的*函数对象*，它可以之后再被调用，如 `(sin ∘ cos)(x)`。
- **软件中的组合 (Composability)**：
    - 指的是独立开发的软件模块（函数、库、系统）能够无缝协同工作的能力。
    - 这是现代计算科学（如将优化器、机器学习模型与复杂的模拟代码结合）追求的重要特性。
    - Julia 语言及社区致力于提高代码的可组合性，目标是让不同开发者编写的代码“自然地”协同工作。

**7. 线性变换的严格定义**
- **核心要求**：线性变换 $T$ 必须满足 $T(0) = 0$。
- **等价定义**：
    - **几何角度**：将矩形网格映射为全等平行四边形组成的格点。
    - **代数角度（操作性）**：存在一个矩阵 $M$ 使得 $T(v) = M \cdot v$。
    - **保持标量乘法**：$T(c \cdot v) = c \cdot T(v)$。
    - **保持向量加法**：$T(v_1 + v_2) = T(v_1) + T(v_2)$。
    - **数学标准定义（综合）**：对于任意标量 $c_1, c_2$ 和向量 $v_1, v_2$，满足 $T(c_1 v_1 + c_2 v_2) = c_1 T(v_1) + c_2 T(v_2)$。
- **从变换到矩阵**：如果已知 $T$ 是线性的，可以通过计算 $T$ 作用在基向量上的结果来找到对应的矩阵 $M$：矩阵的第一列是 $T([1, 0])$，第二列是 $T([0, 1])$。

**8. 下次讲座预告**
- 提出问题：为什么矩阵乘法是那样定义的（行乘列求和），而不是简单的对应元素相乘？
- 答案将在下次讲座揭晓，它与线性变换的组合密切相关。

# 「哈佛CS50P-Python编程导论」第4讲-库

- 视频链接：[CS50P - Lecture 4 - Libraries](https://www.youtube.com/watch?v=MztLZWibctI&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=6)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。

###  内容介绍

本次讲座（CS50P 第 4 讲）将深入探讨 Python 编程中一个至关重要的概念：库（Libraries）。理解和运用库是提升编程效率、避免重复劳动以及利用现有强大功能解决复杂问题的关键。无论您是编程新手还是有一定经验的学习者，掌握库的使用都将是您 Python 技能树上的重要一环。

讲座首先阐释了库与模块的基本概念及其在代码复用中的核心价值。随后，详细介绍了如何使用 `import` 和 `from` 关键字来引入 Python 内置的标准库，并以 `random` 和 `statistics` 模块为例，展示了随机数生成、列表打乱、统计计算等实用功能。接着，讲座内容扩展到程序与外部环境的交互，讲解了如何通过 `sys` 模块处理命令行参数，以及相应的错误检查与处理机制，包括使用 `sys.exit` 提前终止程序。

此外，讲座还介绍了 Python 强大的生态系统，如何使用包管理器 `pip` 从 PyPI（Python Package Index）安装第三方库（如 `requests` 和趣味性的 `cowsay`），并利用这些库实现更复杂的功能，例如通过 API 与网络服务（如 iTunes）通信并处理返回的 JSON 数据。最后，讲座回归到代码组织本身，指导如何创建自己的可复用模块，并阐释了 `if __name__ == '__main__':` 结构在模块设计中的标准用法和重要性。

### 内容纲要

```
CS50P 第 4 讲 - 库 (Libraries)
├── 一、库与模块 (Libraries and Modules)
│   ├── 库 (Library) 的定义与目的
│   ├── 模块 (Module) 作为 Python 的实现
│   ├── 代码复用
│   └── Python 标准库示例 (random) 与文档获取
├── 二、导入和使用模块 (Importing and Using Modules)
│   ├── `import` 关键字
│   │   ├── 语法与基本用法 (`import module_name`)
│   │   ├── 调用方式 (`module_name.function_name`)
│   │   └── 示例：`random` 模块
│   │       ├── `random.choice(["heads", "tails"])`
│   │       ├── `random.randint(1, 10)`
│   │       └── `random.shuffle(cards)` (原地修改)
│   ├── `from` 关键字
│   │   ├── 语法与用法 (`from module_name import function_name`)
│   │   ├── 直接调用 (`function_name()`)
│   │   ├── 示例：`from random import choice`
│   │   └── 优缺点讨论 (简洁性 vs 命名冲突/可读性)
│   └── 示例：`statistics` 模块
│       └── `statistics.mean([100, 90])`
├── 三、命令行参数 (Command-Line Arguments)
│   ├── 概念：程序执行时提供输入
│   ├── `sys` 模块
│   │   ├── `sys.argv` 列表
│   │   │   ├── `sys.argv[0]` (脚本名)
│   │   │   └── `sys.argv[1]` onwards (参数)
│   │   ├── 错误处理
│   │   │   ├── `IndexError` 问题
│   │   │   ├── `try...except IndexError` 方法
│   │   │   └── `len(sys.argv)` 检查方法 (推荐)
│   │   └── `sys.exit(message)` 函数 (提前退出程序)
│   └── 处理多个参数 (含全名加引号)
├── 四、列表切片 (List Slices)
│   ├── 概念：获取列表子集
│   ├── 语法：`list_name[start:end]`
│   └── 示例：`sys.argv[1:]` (排除脚本名) 及负数索引
├── 五、第三方库与包管理器 (Packages, PyPI, pip)
│   ├── 包 (Package) 的概念 (第三方库)
│   ├── PyPI (Python Package Index) 介绍
│   └── `pip` 包管理器
│       ├── 作用与 `pip install` 命令
│       └── 示例：`pip install cowsay`
├── 六、API、Requests 与 JSON
│   ├── API (Application Programming Interface) 概念
│   ├── `requests` 第三方库
│   │   ├── 作用：发送 HTTP 请求
│   │   ├── 安装：`pip install requests`
│   │   └── 用法：`requests.get(url)`
│   ├── JSON (JavaScript Object Notation)
│   │   ├── 定义与作用 (数据交换格式)
│   │   └── 结构 (键值对/字典, 列表)
│   ├── 处理 API 响应
│   │   ├── `response.json()` (解析为 Python 对象)
│   │   └── 示例：访问 iTunes API
│   │       ├── 构建 URL (`entity`, `limit`, `term` 参数)
│   │       └── 解析并提取数据 (`results`, `trackName`)
│   └── `json` 内置模块
│       └── `json.dumps(obj, indent=2)` (格式化输出/调试)
└── 七、创建自定义库 (Custom Libraries)
    ├── 动机：封装复用代码
    ├── 实现：创建 `.py` 文件并定义函数
    ├── 使用：`import` 或 `from` 自定义模块
    └── `if __name__ == "__main__":`
        ├── 问题：直接调用 `main()` 导致导入时执行
        ├── `__name__` 变量特性 (直接运行 vs 被导入)
        └── 解决方案与标准实践
```



---

# CS50P 第 4 讲 - 库 (Libraries)

## 一、 库与模块 (Libraries and Modules)

好了，这里是 CS50，Python 编程入门。我是 David Malan，这是我们关于库的一周。

库通常是指其他人编写的代码文件，你可以在自己的程序中使用它们；或者库是你自己编写的代码，你不仅可以在当前这个程序中使用，也可以在其他程序中复用。Python 正好支持这个理念：与他人共享代码，以及在你自己的多个项目间共享代码。

它通过所谓的模块（Module）来实现这一点。在 Python 中，模块就是一个库，通常内置一个或多个函数或其他功能。具体来说，库或模块的主要目的是鼓励代码的复用。如果你发现自己反复使用同类型的函数、相同的功能，如果你发现自己从旧项目复制粘贴代码到新项目，那么很可能存在一个机会，可以将你不断复制粘贴、不断重用的代码提取出来，放入一个库中，然后在你未来的程序中加载这个库，而不是到处复制粘贴，弄得到处都是副本。

那么，Python 自带了哪些模块或库呢？嗯，Python 自带了一个名为 `random` 的库，毫不夸张地说。也就是说，当你在 Mac、PC 或云端安装 Python 解释器时，你不仅得到了 Python 本身，还得到了一大堆模块。这些模块提供了你默认情况下无法直接使用的函数，不像 `print` 和 `input` 那样。`print`、`input` 以及其他一些函数在 Python 中可以直接使用。但有时，函数被隐藏在这些模块中，所以你必须更明确地将它们加载到计算机内存中。

当你安装了 Python 后，在计算机硬盘的某个地方，很可能存在一个名为 `random.py` 的文件，这是别人（可能很久以前）编写的，但你可以访问它。在那个 `random.py` 文件中，可能有一个或多个函数，你可以用来做一些随机的事情。也就是说，你如何在 Python 程序中模拟抛硬币？你如何在 Python 中选择一个 1 到 10 之间的随机数？嗯，你需要一点随机性。虽然你可以自己从数学上找出如何编写这样的函数，但站在那些已经为你解决这个问题的人的肩膀上要容易得多，这样你就可以专注于解决你自己想要解决的问题了。

对于几乎任何 Python 模块的文档，你都可以去 Python 的官方文档网站查找。你会访问类似这样的 URL，那里有特定模块的文档。在文档中，你会看到该模块提供的函数或其他功能的列表。

## 二、 导入和使用模块 (Importing and Using Modules)

但是，你如何将一个模块加载到你自己的程序中，以便使用该模块中的函数呢？嗯，我们需要 Python 中的一个新关键字，那就是 `import`。Python 中的 `import` 关键字允许你导入某个 Python 模块中的函数内容。

那么，在实践中我该如何使用它呢？嗯，我假设在那个 `random` 模块中存在这个函数（以及其他函数）。我从文档中复制粘贴了名为 `choice` 的函数的摘要。这个函数存在于 `random` 模块中，不是随便哪个模块，而是名为 `random` 的模块。通常文档会这样完整地描述它：`random.choice` 是你技术上调用这个函数的方式，不过我们稍后会看到其他方式。括号里有一个名为 `seq`（sequence，序列）的参数。序列通常指列表或类似列表的东西，如果你有一个数字、字符串或其他任何东西的列表。文档会进一步说明。

我该如何使用这个函数来解决一个可能很熟悉的问题呢？嗯，让我打开 VS Code。我们来实现一个模拟抛硬币的程序。在美国，硬币有正面（heads）和反面（tails），其目的是以 50/50 的概率做出决定。50% 的概率是正面，50% 的概率是反面。或者你可以使用其他类似的机制。

好，我用代码创建一个名为 `generate.py` 的程序，因为我想开始生成一堆随机信息。首先就是抛硬币。我该如何使用那个函数呢？嗯，我首先必须导入 `random` 库。所以，文件的第一行或最开始的几行之一应该是 `import random`。这让我们可以访问该特定模块中的所有函数。

现在，假设我想抛硬币。根据刚才的文档，我可以使用 `random.choice`。它接受一个序列。什么是序列？是一个列表或类似列表的东西。我们了解列表。我们用列表迭代数字，我们用列表迭代霍格沃茨的学生。现在让我们来迭代一个只包含硬币两面的列表，比如 `"heads"`（引号引起来的）或 `"tails"`。我可以给它们起任何名字，这些是我的字符串。我只想模拟抛硬币。所以我将用全小写字母表示 `heads` 和 `tail`。但请注意语法。我用双引号括起了 `"heads"` 和 `"tails"`。这是因为它们是字符串。我也可以用单引号，只要保持一致就行。它们之间有一个逗号，表示这个列表有两个元素。左右两边有方括号，这表明它确实是一个列表。回想一下，这是在 Python 中定义列表的语法。最后，还有更熟悉的东西：方括号外面的圆括号。但那些只是属于 `choice` 函数的圆括号，用来指定它的参数传入的位置。但再次强调，与过去的函数不同，我至少目前必须指定这个函数在哪个模块中。所以我用 `random.choice` 来调用这个特定的函数。

好的，在这些选项中以 50% 的概率选择一个是抛硬币的一方面。这就是 `random.choice` 所做的。它接受一个列表，并以相等的概率随机返回其中的一个值。因为我传入了两个项，所以我有 50/50 的机会。如果我传入三项，那么每个项的概率就是 33% 左右，依此类推。Python 会为你计算。但我想把这个值存储在一个变量中。所以我们定义一个名为 `coin` 的变量，让它等于返回值。这确实就像抛硬币。我将把结果值（`heads` 或 `tails`）存储在一个名为 `coin` 的变量中。现在，为了能看到发生了什么，让我们打印出这个字符串变量 `coin` 的值。

```python
# generate.py (version 1)
import random

coin = random.choice(["heads", "tails"])
print(coin)
```

好了，现在让我在终端窗口中运行这个程序。`python generate.py`，回车。看起来第一次抛硬币是 `heads`。我们再运行一次。看起来又是 `heads`。也许你想在聊天里说点什么。如果我第三次运行它，这次会是什么？如果你想在聊天里输入你的想法，你可能会认为这里有个 bug。但这就是概率在起作用。如果我第三次按下回车，它实际上是 `tails`。再来一次，`tails`。再来一次，`tails`。再来一次，`tails`。再来一次，`tails`。再来一次，`heads`。现在，如果我们无限次地这样做，结果确实会趋近于 50/50。如果我们只做几次，可能结果不会那么完美。但概率就是这样运作的。

好了，我现在让它工作了。我可以用不同的方式实现它吗？嗯，让我向你展示一种替代单独使用 `import` 关键字的方法，让我介绍 Python 中的 `from` 关键字。`from` 是 Python 中的一个关键字，你可以在从模块导入函数时使用它，但它允许你比单独使用 `import` 更具体一些。

如果我回到我的代码，值得注意的是，我在这里通过 `import random` 技术上做的是导入了该模块中的所有内容。所以不仅仅是名为 `random.choice` 的函数，还有其他一些函数。这样做的一个缺点是，我必须输入 `random.choice`、`random.this`、`random.that`，因为我调用的所有函数都必须与该模块的作用域相关联。

假设我只想用函数名 `choice` 来调用它。我也可以这样做。让我把文件顶部的这行代码 `import random` 替换为 `from random import choice`。这实际上是将函数名 `choice` 加载到我当前的命名空间中，加载到我正在工作的文件的作用域中。这意味着我现在不再需要指定我指的是哪个 `choice` 函数。我可以直接说 `choice`。所以它将函数加载到本地命名空间，也就是加载到我本地的“词汇表”中（可以这么理解），所以我现在可以直接说 `choice`。

```python
# generate.py (version 2)
from random import choice

coin = choice(["heads", "tails"])
print(coin)
```

你觉得在什么情况下，这样做可能更有优势？你什么时候会想显式地导入函数名，而不是在代码中到处写 `random.choice`、`random.choice` 来调用函数？对于这种使用 `from` 的替代导入方式，有什么直觉吗？

**问：** 你好，我是来自埃及的 Mohammed Omar。也许如果我们有一个变量，它的名字基本上就像 `choice`。如果我有一个名为 `choice` 的变量，那么我需要区分我选择的是哪个 `choice`。所以我将选择 `random.choice`。

**答：** 是的，非常好的直觉。通过使用第一种方法，仅仅 `import random`，你可以确保它的所有内容都与 `random` 模块相关联或限定在其作用域内，这样你就可以有自己的 `choice` 函数、自己的 `choice` 变量。你可以使用与那个文件内部存储的所有函数或变量相同的名称，而不会发生所谓的冲突。这是一件好事。在一些较旧的语言中，情况是如果你导入了别人的库，你最好希望你没有使用与他们相同的函数或变量名，因为你实际上可能会遇到某种冲突。Python 和某些其他语言允许你将这些函数和变量的名称限定在它们来自的文件或模块的作用域内。所以这是件好事。

但老实说，这个程序很短。或者，等价地，也许我在很多地方都使用了 `choice` 函数，调用 `random.choice`, `random.choice`, `random.choice`。这只是让我的代码越来越长。虽然增加不多，但是嘿，就是变得有点难看和烦人。我可以简单地导入 `choice`，然后让我的代码稍微紧凑一点。因此，与过去的许多决策一样，没有绝对正确的方法。这要看情况。但我认为，出于这些原因，有时最好还是采用我们第一次做的方式，也就是只导入模块，以保留其中的作用域。

嗯，让我建议我们转向 Python 的 `random` 模块附带的另一个函数。这是文档中的 `randint`。有点难发音，但它意味着获取一个随机整数（random int）。如果你阅读文档，它是一个介于 A 和 B 之间（包含 A 和 B）的随机整数。所以如果你传入 1 作为 A，10 作为 B，你会得到一个 1 到 10 之间（包含 1 和 10）的数字。每个数字的概率是 10%。

那么我该如何使用这样的程序呢？让我回到我的 `generate.py` 文件。我们来尝试生成一个 1 到 10 之间的随机数吧。在现实世界中，你可能经常这样做。当你只想让某人选一个随机数时，你会告诉他们。让计算机也在这里做同样的事情。让我删除底部的两行代码，但保留 `import random`。这次我们定义一个名为 `number` 的变量，将其设置为 `random.randint` 的返回值，并传入 A 的值为 1，B 的值为 10。现在，让我们打印这个数字。

```python
# generate.py (version 3)
import random

number = random.randint(1, 10)
print(number)
```

我将在我的终端窗口中运行 `python generate.py` 并回车。4。再运行 `python generate.py` 并回车。8。再来一次，9。再来一次，7。再来一次，10。再来一次，2。我们可以这样玩一整天。如果我们把所有这些结果加起来，它们最终应该各自有 10% 的概率出现。

现在，你可能会如何使用这些信息？嗯，也许我们在玩猜谜游戏。或者也许我们试图让游戏中某个角色的行为随机化。你可以想象使用像这样非常简单的构建块，仅仅通过让程序做一些不那么可预测的事情来为你的程序增添趣味，因为你在看似随机地选择这些值。你依赖 Python 使用它自己的算法和数学来实际生成这些数字。

我们还能在这里做什么呢？让我建议我们介绍这个 `random` 库附带的另一个函数。又一个你不需要自己实现的函数：`shuffle`。如果你阅读同一个 `random` 模块中 `shuffle` 的文档，你会看到它接受一个例如包含值的列表，然后只是将它们打乱。它像洗牌一样将它们随机化。在这里，你可能会洗牌以使它们处于看似随机的顺序。根据这个函数的名字，我该如何使用它呢？

嗯，让我建议我们回到 VS Code。这次让我这样做。因为我需要洗牌像一副牌那样的东西，让我不仅导入 `random`。而且让我给自己一个名为 `cards` 的变量，它的类型是列表。为了有东西可洗，我不需要一副典型牌中的所有 52 张牌。我只洗三张牌：一张 Jack（J），一张 Queen（Q），一张 King（K）。我可以给这些字符串起任何名字，但我只是想要一个包含一些值的列表，以便将它们打乱，也就是随机化其中的顺序。

```python
# generate.py (version 4)
import random

cards = ["Jack", "Queen", "King"]
# random.shuffle(cards) # This line will be added next
```

那么，现在这如何工作呢？如果你阅读 `random.shuffle` 的文档，你会看到它“就地”打乱参数。也就是说，与我们见过的许多函数不同，它不会返回一个包含已洗牌的牌（在这个例子中）的值给你。它实际上打乱了它接收到的列表本身。这对我的代码意味着什么呢？我需要做这样的事情：`random.shuffle` 并传入包含那些牌的变量。

```python
# generate.py (version 4 - continued)
import random

cards = ["Jack", "Queen", "King"]
random.shuffle(cards)

# Now print the cards one by one
for card in cards:
    print(card)
```

然后在最后一行，我该如何打印这些牌呢？嗯，我可以这样做，`print(cards)`。但如果我这样做，我实际上会看到 Python 列表的语法表示，它会以自己的方式使用逗号等来格式化。我想把这些牌一张一张地打印出来，只是因为我觉得这样看起来会更好一些。所以我们可以使用我们学过的循环语法，说类似这样的话：对于 `cards` 列表中的每一张 `card`，打印出当前的 `card`。

那么这里发生了什么？第三行，我定义了一个包含三张牌的列表，顺序是 Jack, Queen, King。然后在第四行，我打乱了同样的这些牌。然后在第五行，我使用一个 `for` 循环，对于那个列表中的每一张牌，把它逐一打印出来，因为我使用的是 `print`，所以是每行一张。

好，让我们看看结果。在我的终端窗口下方，我将运行 `python generate.py` 并回车。Queen, King, Jack，看起来被打乱了，因为这不是我之前定义的顺序。我们再试一次。Queen, King, Jack。嗯，好吧，碰巧是一样的。但让我们看看。这可能只是运气不好。有了。Jack, Queen, King。看起来没被打乱，但至少我们现在得到了不同的排序。再来一次，Jack, Queen, King。嗯，不太好。Jack, Queen, King。不太好。这可能是你想跟他玩牌的人。Queen, Jack, King，有了。当然，我们这里只有三张牌。所以我们可能看到的排列组合并不多。如果我们随着时间的推移这样做，我们会看到所有可能的排列。但如果我们有，比如说，13 张或 52 张牌，我们会看到更多的排列组合。

所以我们现在有这三种生成随机信息的方法。第一种，简单的抛硬币，如果你想开始某种体育赛事。第二种，选择一个 1 到 10 之间的数字，如果你想基于此做决定。现在，使用 `shuffle`，我们甚至可以接受一个包含事物的列表并将它们打乱，从而得到某种随机行为。

嗯，让我在这里暂停一下，看看是否有关于 `random`、模块或这三个函数中的任何一个的问题。

**问：** 是的，如果我们想的话，可以增加或减少牌的概率吗？例如，有三张牌，概率是 33%。有没有机会增加或减少概率？

**答：** 你能设置这些概率吗？不能使用这些相同的函数。你能设置概率吗？但是你绝对可以实现一些你自己的函数，或者使用这个库和其他库中确实存在的更复杂的函数来施加更多控制。这些函数，当然是我们看过的这些，是为了非常用户友好和简单而设计的，它们为所有选项提供相等的概率。但你绝对可以使概率倾斜，尽管希望如果你正在实现一个赌博游戏之类的东西，你不会真的让某些牌比其他牌更有可能出现。

让我现在把注意力转回到我们这个随机性的实现，并考虑我们如何利用那些不一定在这个特定库中的其他类型的功能。嗯，事实证明 Python 还自带了一个 `statistics` 库。

这个库包含了各种用于进行更具统计性质的操作的函数，主要是计算平均数（mean）、中位数（median）、众数（mode）或你可能想要分析的数据集的其他方面。

那么我们该如何在 Python 中使用 `statistics` 模块呢？嗯，我们可能首先像对待 Python 中的任何其他模块一样，查看它的文档。我们会看到在该库中有大量的函数。其中一个函数非常简单：`average`（平均数，通常函数名为 `mean`）。这个函数允许你计算传入的一些数字的平均值。

让我到 VS Code 的终端窗口中，打开一个名为 `average.py` 的新文件。在这个文件的顶部，我将导入一个不同的库，这次是 Python 中的 `statistics` 模块。现在，我将调用我知道存在于该模块中的一个函数，即 `mean`，用于计算一些值的平均值。我将调用 `statistics.mean`。我将向这个 `mean` 函数传递一个包含一些值的列表。假设我正在快速计算我目前在学校的平均成绩。我第一次考试考得很好，得了 100%。第二次考试也考得不错，但没那么好，得了 90分。讽刺的是，我数学不太好。所以我想算出我这两次考试的平均分是多少。那么现在让我在这个列表中输入数字 100，逗号，90，从而传入一个包含两个值（两个整数 100 和 90）的列表。在这些方括号外面是圆括号，因为当然，这是我现在传递给名为 `mean` 的函数的参数。而这个 `mean` 函数位于名为 `statistics` 的模块中。

```python
# average.py
import statistics

result = statistics.mean([100, 90])
# print(result) # This line will be added next
```

嗯，仅仅计算平均值而不实际看到它是什么，并不是那么有趣。所以让我额外地将那个 `mean` 函数的返回值传递给通常使用的 `print` 函数。

```python
# average.py (final)
import statistics

result = statistics.mean([100, 90])
print(result)
```

现在让我在 VS Code 的终端窗口中，输入 `python average.py` 并回车。瞧，正如你可能预期的，我的平均分是 95。所以这里的区别仅仅在于我使用了 Python 自带的另一个不同的模块。但我需要导入它，而不是例如导入 `random` 模块。这次，我从文档中知道存在一个名为 `mean` 的函数。

## 三、 命令行参数 (Command-Line Arguments)

事实证明，Python 还附带了更多的功能，并且这些功能来自 Python 中的其他模块。有一个普遍称为命令行参数的功能。这不仅仅是 Python 的功能，而是更广泛的语言特性，它允许你提供输入，但不是在程序内部被提示时（就像我们调用 Python 的 `input` 函数时发生的那样）。相反，存在这种程序的命令行参数特性，允许你在命令行执行程序时就提供参数，也就是输入给程序。

所以，到目前为止，回想一下，我们通常运行的是 `python something.py`。例如，`python hello.py`。我从来没有真正在文件名后面输入任何单词或短语，但我可以这样做。实际上，当你在像我们这样的命令行环境中运行程序时，你可以在你输入的命令之后提供任意数量的单词、数字或短语。所有这些都会以某种方式作为输入传递给程序本身。你不必通过手动调用 `input` 函数来一次提示用户输入一个东西。

那么这在实际中意味着什么呢？嗯，让我回到 VS Code。让我建议我们考虑如何利用某个特定的模块。我将创建一个名为 `name.py` 的文件。这次我想使用一个新的模块，它将使我能够访问在命令行输入的那些值。

但是这个模块会是什么呢？嗯，这个模块将被称为 `sys`。`sys` 是 system（系统）的缩写，它包含了大量与系统本身以及你我输入的命令相关的功能。这个模块的文档在这个 URL。它列出了该模块附带的所有各种函数、变量等等。但我们将专注于一个更具体的东西，即这个：事实证明，在 Python 的 `sys` 模块中，有一个名为 `argv` 的变量神奇地为你存在。它代表 argument vector（参数向量），这是一种描述人类在提示符下按回车之前输入的所有单词列表的花哨方式。所有这些似乎都神奇地通过 Python 在一个名为 `sys.argv` 的变量中提供给你。这个变量是一个列表，这意味着第一个元素将是你输入的第一个单词。第二个元素将是你输入的第二个单词，依此类推。通过这个列表，你就可以弄清楚人类在提示符下实际输入了哪些单词，并可能利用这些信息来影响你自己程序的行为。

那么这在实际中意味着什么呢？嗯，在这个名为 `name.py` 的新标签页中，让我导入 `sys`。在那个 `sys` 模块中，我将可以访问 `sys.argv`，但我该如何使用它呢？

嗯，让我们这样做。我们不再编写一个总是查找 `input` 函数的返回值来确定用户想让我打印什么名字的 Hello World 程序了，让我们直接期望用户在运行 Python 程序时就告诉我们他们的名字是什么。这次，假设我想生成一大堆姓名标签，最初只有一个。在美国，很常见的是在翻领上贴一张写着“你好，我叫 David”的贴纸。所以我想打印出一些类似那样的文本。想法是，也许有一天我可以增强这个程序，甚至将该文本直接发送到打印机，动态生成那些姓名标签。

好，现在让我这样做。让我像往常一样打印出 "Hello"。但这次我会多说一点，让事情更有趣一些。"Hello, my name is"，引号引起来。然后，在那之后，我通常习惯于调用 `input`，将返回值存储在一个变量中，然后在这里传入该变量的名称。但我将直接跳到这里：`sys.argv[1]`。就是这样。我将有一个程序，它说 "Hello, my name is"，后面跟着 `sys.argv[1]` 中的任何内容。注意，这个 `.argv` 再次强调，是一个列表。回想一下我们关于循环和列表的讨论，我们使用这种方括号表示法来访问列表内部的各种元素。

```python
# name.py (version 1)
import sys

print("Hello, my name is", sys.argv[1])
```

好了，现在让我进入我的终端窗口，运行 `python name.py`。但这次，与其只按回车然后等待程序提示我输入名字，不如让我主动地在这个所谓的命令行中告诉这个程序我的名字是什么。就这样：D-A-V-I-D，用空格与文件名隔开。这样，现在当我执行 `python name.py David` 时，我在屏幕上看到，瞧，"Hello, my name is David"。

所以，仅基于这个演示，我认为我们可以推断出 `sys.argv` 中到底发生了什么，即使它乍听之下肯定相当复杂。让我们看看。在 `sys.argv` 中，我这里用的是 `[1]`。所以很明显，`sys.argv[1]` 存储的是 D-A-V-I-D。但它是一。在过去我们看循环时，回想一下我们说过它们是零索引的。也就是说，第一个元素是零。下一个元素是一。再下一个元素是二，依此类推。然而，在这里我却把它当作我的名字在列表的开头，索引为一。

嗯，让我问这个问题，`sys.argv[0]` 中可能是什么？`sys.argv[0]` 中——那个列表中真正的第一个元素——可能是什么？

**问：** 哦，是的。我认为它就像在 C 语言中一样，是程序的名字。

**答：** 确实，确实像在 C 语言中一样。另一种语言，是程序的名字。嗯，如果我们考虑我输入了什么，我当然输入了 `python`，因为那是我解释器的名字。我们并不真的需要知道那个，因为我们正在使用 Python 本身。但在那之后，我确实输入了两样东西。我输入了 `name.py`，就像我每次想让 Python 解释我写的程序时所做的那样。事实证明，按照惯例，Python 所做的是将你正在执行或解释的文件名存储在 `sys.argv[0]` 中，后面跟着你输入的任意数量的其他单词。所以一直以来，我们本可以访问程序的名字，坦白说，那并不是那么有趣。但我们现在也可以访问在那个提示符之后输入的单词了。

但是，当然，如果我什么都不输入，这里可能会发生什么？假设 `sys.argv` 的位置 1 总会有东西，这可能是我天真的想法。让我试试这个。`python name.py`。我没有给出我的名字，因为在这一点上，我甚至可能不知道你想要输入我的名字。所以现在让我按回车。哦，哦，我们现在看到了一个错误。Python 中一个所谓的异常，这是一个新的异常。这是一个 `IndexError`，它进一步说明 `list index out of range`（列表索引超出范围）。事实证明，这实际上是编程中最常见的错误之一，无论你是在 Python 中使用列表，还是在其他语言中使用数组或向量，就是试图访问某个不存在的元素。你试图在这个仅仅是一些值的列表的对象中走得太靠左，或者试图走得太靠右。

所以这里的错误当然是，我假设位置 1 会有东西，而实际上，只有位置 0 有值。但修复这个问题并不等同于改成 `[0]`。因为现在如果我重新运行这个程序，在 `name.py` 之后没有其他单词，它会说 "Hello, my name is name.py"，如果我们是为程序制作姓名标签，这没问题，但这当然不是我这里的目标。

所以，如果修复方法不只是把 1 改成 0，我还能如何处理这个错误呢？我还能如何处理这个错误？这个 `IndexError`，如果用户只是不记得或者不知道在提示符下输入他们的实际名字时发生的错误。

**问：** 我们可以总是在程序中加入一个异常处理，比如，如果在位置 1 没有东西，我们就出来说，好吧，我们没有得到参数或类似的东西。但如果有，我们就继续执行程序。

**答：** 完美。如果我可以简化一下，我们可以尝试执行这行代码，除非出现错误，我们将以其他方式处理它。理想情况下——一旦我成为一个足够强大的程序员，我会预见到这一点并从一开始就编写以下代码。但在学习时，看到一个错误，哦，我没意识到我应该检测到那个，然后回去改进你的代码，这当然是合理的。当然，如果你阅读了文档，吸收了过去的一些经验教训，你会养成尝试并自己检查其中一些异常的习惯。所以让我用你提出的其中一种可能的方式来解决这个问题。

让我们尝试如下处理这个异常。让我现在继续。与其盲目地调用这个 `print` 行，不如让我尝试打印出 "Hello, my name is such and such"，除非出现问题，特别是 `IndexError`，那么我想做什么呢？我会说类似 "Too few arguments"（参数太少）。我可以解释得更详细，但现在，我只想向用户解释他们给我的参数太少了，在提示符下给的单词太少了。

```python
# name.py (version 2 - try/except)
import sys

try:
    print("Hello, my name is", sys.argv[1])
except IndexError:
    print("Too few arguments")
```

所以现在，它仍然不会完全按我想要的方式工作。我仍然无法生成他们的姓名标签。但至少，他们不会看到一些神秘的错误消息，并认为他们自己把程序搞坏了。现在让我运行 `python name.py` 回车，看到 "Too few arguments"。好的，现在让我运行 `python name.py` 并输入我的名字 David。现在我们又回到正轨了。我看到我的名字也在屏幕上了。

但严格来说，我不必尝试这样做。我实际上可以在编写这段代码时更具防御性一点。也许我可以检查用户是否确实在提示符下提供了一个或多个名字，以便给他们更精确的错误消息。

那么我该怎么做呢？嗯，让我撤销我添加的异常处理。为什么我不更谨慎地尝试这样做呢？让我在这里引入一个条件判断。如果 `sys.argv` 的长度小于 2，或者等价地，只等于一个值——但我现在只坚持使用小于 2，那么就打印出 "Too few arguments"。我最终想要两个参数。我想要位置 0 的程序名。我想要位置 1 的人名。所以总共是两个参数。所以如果我的参数少于两个，就用这行 `print` 告诉用户。`elif` `sys.argv` 的长度比如说大于 2，比如他们在提示符下输入了太多单词，那么，让我们告诉他们，`print`，引号引起来，"Too many arguments"（参数太多）。`else` 如果他们做对了，给了我正好两个参数。`else`，让我们打印出我真正关心的内容。

```python
# name.py (version 3 - if/elif/else)
import sys

if len(sys.argv) < 2:
    print("Too few arguments")
elif len(sys.argv) > 2:
    print("Too many arguments")
else:
    print("Hello, my name is", sys.argv[1])
```
哦，我好像在 `elif` 那行的 `print` 语句里漏了一个双引号。让我加上去。好了，这个无关紧要的错误解决了。

```python
# name.py (version 3 - fixed syntax)
import sys

if len(sys.argv) < 2:
    print("Too few arguments")
elif len(sys.argv) > 2:
    print("Too many arguments")
else:
    print("Hello, my name is", sys.argv[1])
```

好了，让我到我的终端窗口，运行 `python name.py`。瞧。哦哦，一个完全不同类型的错误。这是一个语法错误（SyntaxError），我们以前见过。现在，回想一下，语法错误是我的错，比如，我搞砸了这里。我写了无效的语法。所以再多的条件判断或异常处理也无法真正捕获这个错误。我需要回去让我的程序能工作，因为它根本无法运行。嗯，让我上去看看。第 6 行是问题所在。确实，看起来我这里有一个未终止的字符串。我现在需要加上这个双引号。好了，现在无关紧要的错误消失了，让我重新运行 `python name.py` 并回车。现在，我们看到 "Too few arguments"。好的，也许它想要我的全名。现在让我运行 `python name.py David Malan`，在文件名后面输入两个单词并回车。现在，当然，是 "Too many arguments"。好吧。现在我将遵从并运行 `python name.py` 只输入 David。就这样。我的姓名标签打印在屏幕上了。

所以严格来说，如果我们能更聪明一点，并且仅仅检查我们担心的事情，我们就不必处理异常，特别是如果我们想给用户更精确的建议。我们不想只是告诉他们“不，出错了”，或者我们不想跳过。我们想告诉他们“不，参数太少了”或者“不，参数太多了”。我们已经在我们的词汇库中有了条件判断，通过它们我们现在可以表达这一点。

嗯，让我在这里暂停一下，看看现在是否有关于我们之前用 `IndexError` 处理错误的方式，或者现在我们如何通过首先检查是太少、太多，还是正好是我们想要的，从而主动避免所有 `IndexError` 的方式的问题。

**问：** 嗨，是的，谢谢。我想知道，你提到了使用全名。有没有一种方法，未来可能我们有的人想要他们的全名，有的人只想要他们的名字，我们把它区分开来，哦，这个人有全名，这个人只有一个名字？

**答：** 当然可以，请允许我建议我们稍后再讨论对多个名字的支持。但确实，我们可以做到。我应该注意到，我们现在就可以支持全名，如果我这样做。与其输入 David 空格 Malan，这有问题，因为再次强调，根据 `argv` 的工作原理定义，每个单词最终会出现在列表中的特定位置。但是如果我在命令行添加引号，单引号或双引号，现在，Python 会将这视为总共两样东西：文件名和这个全名。现在，当我按回车时，我看不到引号了。整个内容作为我的全名被传入了。如果我想进一步为多个人调整这个程序，我们也能做到。

现在关于这个使用 `if`, `elif`, `else` 的版本，或者之前使用 `except` 的版本，还有其他问题吗？

**问：** Python。我想问你，我们可以使用多个 `else` 语句吗？

**答：** 你能使用多个 `else` 语句吗？不，`else` 是你可以拥有的最后一个包罗万象的语句。你可以在中间有多个 `elif` 语句，但不能有多个 `else`。

**问：** [听不清]

**答：** 好的。好的，那么让我们把注意力转回到这段代码，看看我们是否可以通过添加一些像 `sys` 模块提供的额外功能来进一步改进它。

即使可以说这个版本的代码现在是正确的，但我不太喜欢它的一点是，我程序的核心，也就是打印姓名标签，被归入了 `else` 子句。这没问题。逻辑上是正确的，但总的来说，将所有错误处理与你真正关心的代码分开是很好的，将所有这些 `if`、`elif` 可能放在代码的顶部，检查以确保所有数据都符合预期。但是，如果仅仅是为了设计考虑，不把实际关心的代码隐藏在这个 `else` 语句中会更好。例如，我更倾向于在逻辑上这样做。我可以在顶部检查错误。然后在这里下面，打印姓名标签。如果这些是不同的代码块，并且所有这些都在这里左对齐，那就好了。

但我刚刚这样做是有问题的。从逻辑上讲，我刚刚通过去掉 `else` 并在第 10 行单独引入它（没有缩进，在条件判断之外）引入了什么 bug？

我刚刚引入了什么 bug？要明确是什么错误？

**问：** Name error（名字错误）。

**答：** 讽刺的是，这是一个 name error（与名字有关的错误），但不是 NameError 异常。这是一个关于我的名字的错误，但我觉得你对我来说卡住了。它会引发一个异常，因为即使我在顶部检查了 `sys.argv` 的长度，即使我再次检查了它是否大于 2，不仅仅是小于 2，而是大于，我仍然盲目地、错误地假设它现在会存在。所以要明确一点，如果我运行 `python name.py` 并且不输入任何参数——我参数太少了——我想我会看到我参数太少了，但我也会看到同样的异常。在我终端窗口输出的最顶部，是我的错误消息，“Too few arguments”。但是再次，在第 10 行，我盲目地继续索引我的列表的位置 1，而它并不存在。

```python
# name.py (version 4 - flawed logic without else)
import sys

if len(sys.argv) < 2:
    print("Too few arguments")
elif len(sys.argv) > 2:
    print("Too many arguments")
# Problem: This line runs regardless of the checks above if no exit happens
print("Hello, my name is", sys.argv[1]) # Will cause IndexError if len < 2
```

事实证明，有一种更好的方法来处理像这样的错误，特别是如果你正在用 Python 编写一个只是打算短暂运行然后无论如何都会退出的程序。但也许如果程序本身无法继续进行，我们可以开始提前退出。如果用户没有给我们想要的数据，也许，我们应该比通常更早地退出程序。

所以让我这样做。让我去掉我的注释，以便只关注代码本身。我建议，与其仅仅打印，引号引起来，“Too few arguments”，不如我使用 `sys` 模块附带的另一个函数。我将调用 `sys.exit`。顾名思义，它将完全做到这一点。在系统的帮助下，它将在那里的第 4 行退出我的程序。为什么可以这样做？嗯，如果你给我的参数太少，我对你，用户，无话可说。我不如早点退出。我也可以在第 6 行这样做。让我们不仅打印那个消息，而且 `sys.exit`，引号引起来，“Too many arguments”。打印出那个消息，然后就在那里退出。现在，我可以相信，到我到达第 8 行时，每个错误条件都已经被检查过了。所以我可以安全地假设 `sys.argv` 的位置 1 确实有一个项目。

```python
# name.py (version 5 - using sys.exit)
import sys

if len(sys.argv) < 2:
    sys.exit("Too few arguments")
elif len(sys.argv) > 2:
    sys.exit("Too many arguments")

# If we reach here, argv has exactly 2 elements
print("Hello, my name is", sys.argv[1])
```

那么现在让我运行这个，`python name.py`，回车，“Too few arguments”。但我回到了我的提示符。没有更多的事情发生。让我再运行一次。`python name.py David Malan`，没有引号，回车。“Too many arguments” 现在打印在这里。最后，`python name.py` 只输入 David，回车。“Hello, my name is David”。

所以我们在 `sys` 中有两种功能。现在，我们可以访问这个变量 `sys.argv`，这个参数向量，它给了我所有在提示符下输入的单词，包括程序自己的文件名。事实证明，如果我们进一步阅读文档，有一个 `exit` 函数可以接受不同类型的输入。但如果我像这样传递一个字符串，它确实会为我打印那个字符串，然后就在那里退出我的程序。

现在关于像这样从程序中退出的问题。要明确的是，一直以来，一旦 Python 到达你文件的底部，它无论如何都会退出。所以我现在使用 `sys.exit` 只是为了确保我比通常更早地退出。

**问：** 我的问题是关于 `sys.argv`。它能够一次接受或获取多个元素吗？比方说，例如，`python name.py David Malan` 我是男性，20岁。然后，比方说我只想访问你的名字，它在第一个索引。然后你的年龄，比如说，在第六个索引。我可以说 `sys.argv[1]` 和另一个用于 6 的，来访问我想要的吗？`sys.argv` 能同时做到这两个吗？

**答：** 简短回答——是的，如果我理解你的问题正确的话，即你建议在命令末尾有许多单词，并且你想访问那些单独的单词。绝对可以。在某种程度上，我会说，如果你在提示符下输入如此多的单词以至于顺序真的很重要，那会变得有点脆弱。事实证明有很多程序，并且 Python 中有功能可以让你提供那些值，比如姓名或年龄或任意数量的其他字段，可以按你想要的任何顺序，但需要传入更多一些文本信息来告诉程序你想如何使用它。所以简而言之，你描述的是可能的。让我做一个小型的实现，如下所示。

我建议我们回到我的代码。让我们建议我们现在实际上想要支持在提示符下输入多个值。所以将不再有“参数太多”这回事。假设我想生成的姓名标签不仅仅是给 David 的，而是给 David、Carter、Rongshin 以及组里所有想要姓名标签的其他人的。所以我将这样做。我将去掉我的 `elif` 条件，因为我不想再限制在提示符下输入的单词的最大数量了。我反而想迭代提示符下的每个名字。

## 四、 列表切片 (List Slices)

所以我要这样说。对于 `sys.argv` 中的每个 `arg`，这次打印出 `arg`。那么我在这里做什么呢？嗯，尽管语法有点不同，但想法和我们之前使用循环时是一样的。我使用 `for` 循环来迭代一个列表。这里涉及的列表是 `sys.argv`。`arg` 是我即时创建的一个变量。`for` 循环将确保第一次通过这个循环时，`arg` 被设置为命令行上的第一个单词。第二次通过循环时，Python 将确保 `arg` 现在被设置为命令行上的第二个东西，依此类推。`for` 循环就是这样工作的。它为我们更新变量。我不必叫它 `arg`。我可以叫它 `name`，只要我把两个地方都改成 `name` 就行。但如果我通常是在迭代参数，那么 `arg` 是合理的。

```python
# name.py (version 6 - loop over all args)
import sys

if len(sys.argv) < 2:
    sys.exit("Too few arguments")

# This loop currently includes the script name
for arg in sys.argv:
    print("Hello,", arg)
```

然而，如果我现在运行这个程序，不幸的是，有一个小 bug。即使我输入了 David、Carter 和 Rongshin，我也不会只得到三个姓名标签。在你看来，有人看到我即将遇到的 bug 吗？如果我有足够的姓名标签分发，这不算什么大事。但我会浪费一个，因为这将打印不是三个，而是四个姓名标签，其中第一个包含了程序本身的名称。也许不是什么大问题。也许那是我们不费心分发的贴纸，但这是浪费的。而且看起来确实不对。

那么我们如何能访问到 `argv` 的不是所有四个元素，而只是 `argv` 的一个切片（slice）呢？这实际上是 Python 和其他一些语言中的一个技术术语。取一个列表的切片意味着取它的一个子集，也许是从开头，也许是中间，也许是结尾。但切片是像列表这样的数据结构的一个子集。

那么在代码中我实际上该怎么做呢？嗯，在 Python 中，取一个列表的切片，也就是它的一个子集，实际上非常容易。你可以简单地这样做。在列表名称（在这个例子中是 `sys.argv`）的末尾，你可以使用方括号。然后在那些方括号中，你可以指定你想要保留的列表的开始和结束位置。我想从元素 1 开始，而不是 0。我想从元素 1 开始，然后一直到结尾。所以我实际上将完全省略第二个数字。没有必要有第二个数字。但我确实需要那个冒号，因为这将给我列表的一个切片。它将给我一个从位置 1 开始（而不是 0）的列表切片。冒号然后一个空白只是意味着它将给我其余的所有内容。所以这等价于切掉列表的第一个元素，并给我一个只包含那三个人名（而不是文件名本身）的新列表。

```python
# name.py (version 7 - using slice)
import sys

if len(sys.argv) < 2:
    sys.exit("Too few arguments")

# Slice sys.argv to exclude the script name (index 0)
for name in sys.argv[1:]:
    print("Hello,", name)
```

让我再试着运行这个。我将运行 `python name.py David Carter Rongshin`。这次希望我能得到三个且只有三个姓名标签，按回车。确实，我现在就这样做了。所以再次，使用 Python 中一些相对简单的语法，我们可以使用方括号，不仅仅是去访问特定的元素，比如 `[0]` 或 `[1]`。我们还可以通过 `[something:something]` 的方式获取列表的子集，即列表的切片，其中每个 `something` 是一个数字，表示开始或结束，并且它们是可选的，取决于你是想要所有的还是只是一部分。

现在关于这个增加了循环和使用新语法的切片的版本，有什么问题吗？

**问：** 我们可以从参数向量的末尾开始切片吗？

**答：** 你可以。你可以从参数向量的末尾切片。这可能会让人有点难以置信。让我这样做。让我想想。让我在这里的结尾用 `-1`。在这里使用负数并运行相同的命令，我们刚刚取消了 Rongshin 接收姓名标签的邀请。所以如果你使用负数，它的效果是从列表末尾反向计数。

```python
# Example of negative slice index (conceptual)
# sys.argv[1:-1]  # Would exclude the last argument
```
那是个好问题。现在关于切片，关于遍历 `sys.argv` 还有其他问题吗？

**问：** 嗨，我记得很早以前我们谈到浮点数值只保留两位小数。这和那是一回事吗，比如，因为我们用了 `:.2f` 的代码？那这和那个是一回事吗？为什么 `.2f` 中要包含 F，而这里你只有数字？

**答：** 非常好的问题。简短的回答是上下文很重要。我们键盘上的键就那么多。所以我们有时会用相同的符号来表示不同的东西。你所指的是 F 字符串（f-string）中用于实际格式化数字的格式代码，使用冒号，使用句点，使用数字，使用字母 F 等等。那是 Python 的 F 字符串特性非常特定的用法。这个例子与那个语法本身没有任何关系。这只是在不同的上下文中使用冒号来解决这个问题，来实现切片。Python 的作者本可以选择另一个符号。但老实说，看看我的键盘，我们没有那么多容易输入的符号可供选择。所以有时它们有不同的含义。也是个好问题。

## 五、 第三方库与包管理器 (Packages, PyPI, pip)

请允许我现在建议，我们进一步发展，从只使用那些 Python 自带的模块、库，转向讨论更普遍存在的包（package）。

如今 Python 如此流行和强大的原因之一是，外面还有很多第三方库，也称为包。严格来说，Python 本身有一个术语叫包（package），它本质上是一个在文件夹中实现的模块，不仅仅是一个文件，而是一个文件夹。但更普遍地说，包是一个第三方库，你我可以在我们自己的 Mac、PC 或云服务器上安装，从而获得其他人为我们实现的更多功能。

现在，你可以获取所有这些包的位置之一叫做 PyPI 网站，即 Python 包索引（Python Package Index），它的网址在这里（pypi.org）。这是一个可以通过命令行以及通过网页搜索的网站，允许你下载和安装各种各样的包。甚至 CS50 在像这样的服务中也有自己的一些包。

现在，有一个很有趣的包，它是对一个在命令行环境中存在多年的命令的致敬，叫做 `cowsay`。`cowsay` 是 Python 中的一个包，它允许你让一头牛在你的屏幕上说些什么。如果你好奇想了解它，它自己的文档在 pypi.org 上，具体在这个 URL。

但你实际上如何将包弄到你的系统中呢？嗯，技术上，你可以找出如何下载文件，也许解压缩它，然后把它放到你的 Mac 或 PC 上的正确位置。但如今，很多语言，包括 Python 在内，都有所谓的自己的包管理器。这里这个叫做 `pip`，它只是其中一个。所以 `pip` 是一个通常随 Python 本身一起提供的程序，它允许你通过只运行一个命令就在你自己的 Mac、PC 或云环境中安装包。然后，瞧，你就可以访问 Python 中一个全新的库了，这个库不是 Python 自带的，但现在它在你的系统上可供你使用。

让我们回到 VS Code。在我的终端窗口中，我将输入 `pip install cowsay`。现在这里发生了什么？`pip` 是命令，是包管理器。我想安装什么包？名为 `cowsay` 的包。我将按下回车。经过一点输出后，它已经成功安装了 `cowsay`。

现在这意味着什么？这意味着我现在可以在我自己的代码中导入它了。好，让我们看看这意味着什么。让我创建一个新文件，用代码命名为 `say.py`，因为我想让屏幕上说点什么。

在这个新标签页中，我将导入 `cowsay`，它想必现在已经安装好了。我还要导入 `sys`，因为我想在这个程序中使用一些命令行参数，这样我就可以快速运行它。并且不用 `input` 函数，我可以直接从提示符获取用户的名字。让我这样做。这次我将主动进行一些错误检查。与其使用小于或大于，这次我将说，如果 `sys.argv` 的长度确实等于 2。所以如果用户只提供了程序名和他们自己的名字，我们就没问题了。我将做以下事情：我将调用名为 `cowsay` 的包中一个名为 `cow` 的函数。我将传入一个字符串 "hello, "。然后像过去一样，我将只传入一个字符串，因为根据它的文档，它不像 `print`。我不能传入逗号这个，逗号那个。我只能传入一个字符串。所以我将使用连接操作符（像过去一样）连接 `sys.argv[1]` 的内容。只要我在这个程序名后面输入我的名字 David，它就应该最终出现在 `sys.argv[1]` 中，在这种情况下，这第 5 行代码应该将 "hello, " 与我的名字（中间有一个空格）连接起来。显然，一头牛会说出它。

```python
# say.py (using cowsay)
import cowsay
import sys

if len(sys.argv) == 2:
    cowsay.cow("hello, " + sys.argv[1])
```

那么让我们看看会发生什么。让我清屏并增大我的终端窗口。让我运行 `python say.py` 并输入我的名字 David，回车。这就是名为 `cowsay` 的程序。它真的让一头牛在屏幕上说了些什么。这是对过去一个程序的致敬，那个程序往往随许多系统一起提供。这也被称为 ASCII 艺术。这是一种仅使用键盘上的键在屏幕上打印出各种图片（有点像）的文本方式。

现在，我们真的可以在这里深入研究下去。这样做是否有值得怀疑的学术价值。所以我只做一次。事实证明 `cowsay` 包还附带了其他函数。例如，其中一个函数是 `trex`（霸王龙）。如果我现在增大我的终端窗口，我们也许会看到我们要去哪里。

```python
# say.py (using trex)
import cowsay
import sys

if len(sys.argv) == 2:
    cowsay.trex("hello, " + sys.argv[1])
```

现在让我再次运行，`python say.py`。这次，让我不提供我的名字，只是看看它是否坏了。它仍然没问题，因为我们有那个 `if` 条件，如果 `sys.argv` 的长度等于等于 2，并且只有当它等于等于 2 时，我们才做任何事情。这就是为什么我们在这里什么也看不到。现在让我合作一下，`say.py` 空格 David。它不再是一头牛了。但如果我在屏幕上缩小，是一只霸王龙。为什么？只是因为这些是你知道如何编程后可以做的事情。你甚至可以将它们打包起来，作为开源软件免费提供给他人。对我们来说，它更广泛地展示了一个特性，即能够安装这些第三方包以及在 Python 中如何做到这一点。

现在，我将把这个留在屏幕上一会儿，看看是否有关于牛、霸王龙或者更普遍的关于包的问题。我真正有资格谈论的只有其中之一。

**问：** 嗨，我有两个问题，这比预期的要早一点。所以第一个问题是，你在程序中调用的包，它们是否与，比方说，Java 中的某些东西相同，比如调用一个类，一个 Java 文件，以便使用它的函数？我的第二个问题是，像你使用的那样，使用命令行参数的实际目的是什么？因为这并不是真正最好的方式，如你所说，对用户友好，比如说，使用程序的人不知道他们想要什么——程序在问他们什么？

**答：** 非常好的问题。第一个关于与 Java 比较的问题，Python 包类似于 Java 包，在 Java 中你程序的顶部有 `something.something.something` 让你能访问一个类或其他东西。Python 本身支持类。我们稍后会更多地讨论它们。你可以在 Python 中做与在 Java 中非常相似的事情。但这里的类比确实是 Python 包对应 Java 包。

至于命令行参数，你问了一个好问题。我们为什么要使用它们，特别是如果它们不是字面上对用户友好的？老实说，对于不在此 Zoom 会议中的人来说，它们有点不那么用户友好。随着我们越来越多地学习编程和命令行参数，我敢说我们会变得更适应并倾向于更喜欢使用这些命令行参数来自定义命令的能力。为什么？生产力。它往往让你更快，因为你养成了确切知道如何配置你的软件的习惯，而无需手动回答问题。举个例子。一直以来我们都在运行 `python something.py`。你可以想象不这样做。你可以想象只输入 `python`，按回车。然后你被提示输入你想运行的文件名。所以你输入 `something.py`，然后它运行。不是什么大事，但我认为随着时间的推移，你会对这种繁琐感到有点厌倦。你会更倾向于只是自动化这个命令，一次又一次，特别是借助一些小便利，比如能够在键盘历史记录中按上下来重新运行那些相同的命令。自动化也很重要，如果你从这样的课程毕业并开始使用 Python 来自动化工作流程或个人项目等，能够在一行上指定所有输入就意味着你可以更快地完成工作。所以毫无疑问，绝对是这样。使用命令行参数是系统的一个更晦涩难懂的特性，我们大多数人不再那么熟悉了，因为有了 Windows、Mac OS 和其他有按钮、GUI 和菜单的操作系统。但你对编程越熟悉，我敢说你就越会倾向于喜欢这些功能，因为它们让你能更快地做事。

## 六、 API、Requests 与 JSON

话虽如此，请允许我建议我们转向另一个特别流行且同样易于安装的包，最终目的是使用 API。

现在，API 不是 Python 特有的东西。更普遍地说，API 是应用程序编程接口（Application Programming Interface）。它可以指 Python 文件和函数。但通常，API 真正指的是第三方服务，你我可以通过编写代码与之交谈。如今许多 API（但不是全部）都存在于互联网上，因此只要你有浏览器，或者只要你有一些 Python 编程或任何语言编程的经验，你就可以编写代码，实际上假装成一个浏览器，连接到服务器上的那个第三方 API，并下载一些数据，然后你可以将这些数据整合到你自己的程序中。

那么你该怎么做呢？嗯，Python 有一个非常流行的包，你可以通过 `pip` 安装，叫做 `requests`。`requests` 库允许你使用 Python 代码发出 Web 请求、互联网请求，本质上就像你自己是一个浏览器一样。因此，你可以自动化获取以 HTTP 或 HTTPS 开头的 URL 的过程。这个库的文档在这样一个 URL，但它也可以在命令行安装。即使它是第三方的，它也是 Python 中最流行和最常用的包之一。这再次是 Python 如此流行的原因之一。对于你我拥有或在编写自己项目时不可避免会遇到的问题，有太多的解决方案了。有一个非常活跃的生态系统，一个非常活跃的开源软件社区，对我们来说安装起来就是那么容易。

让我回到我的终端窗口，运行 `pip install requests` 以便在我自己的系统上安装这个包。经过几行输出后，我会看到它已成功安装。

现在，让我们创建一个新文件。例如，`itunes.py`。事实证明，苹果公司为其 iTunes 服务提供了自己的 API。这个软件让你能够下载和搜索音乐、歌曲以及其他信息。事实证明——让我回到我的电脑上，打开像 Chrome 这样的浏览器。让我访问这个 URL：`https://itunes.apple.com/search?entity=song&limit=1&term=weezer`。搜索?entity=song&limit=1&term=weezer。

我现在通过阅读苹果公司 iTunes API——应用程序编程接口——的文档，手动构建了这个 URL。他们告诉我的是，如果我想在他们的数据库中搜索关于歌曲的信息，我应该指定 `entity=song`，这样是歌曲而不是专辑或艺术家或其他东西。如果我只想获取一首歌的信息，我将提供 `limit=1`。如果我想搜索的乐队、艺术家是 Weezer，我应该指定 `term=weezer`。所以有了这个，如果我按回车访问这个 URL，我实际上最终会在我的 Mac 上的下载文件夹中得到一个文本文件。如果我打开我的浏览器刚刚下载的那个文本文件，我们会看到所有这些文本，乍一看可能有点神秘，但它实际上遵循一种模式。注意开头的这个花括号 `{` 和结尾的这个闭合花括号 `}`。注意这里的这个开方括号 `[` 和这里的这个闭合方括号 `]`。在这些语法片段之间是一大堆字符串和值。实际上，是一大堆键值对。我们在这里看到的是一种标准的文本格式，称为 JSON——JavaScript Object Notation（JavaScript 对象表示法），是的，它技术上与另一种名为 JavaScript 的编程语言有关。但 JSON 本身如今通常被用作一种与语言无关的格式，用于在计算机之间交换数据。所谓与语言无关，我的意思是你不必使用 JavaScript。你可以使用 Python 或任何其他语言来读取 JSON 或写入它。它是一种完全基于文本的格式，这意味着如果我用浏览器访问那个 URL，下载下来的只是一堆文本。但那些文本是以标准方式格式化的，使用花括号和方括号，使用引号和一些冒号，最终包含了苹果数据库中关于 Weezer 歌曲的所有信息，至少是第一首，因为我在他们的数据库中将其限制为一首。这就是一个 API，一个应用程序编程接口。一种机制，我可以通过它访问别人服务器上的数据，并以某种方式将其集成到我自己的程序中。

当然，我的浏览器 Chrome 不是我写的。我应该实际编写一些 Python 代码，也许假装成浏览器来抓取相同的数据。那么我们来做吧。让我回到 VS Code。让我用代码编写一个程序，`itunes.py`。我们将编写一些代码，通过它我可以使用 iTunes API，进而使用 Python 来获取关于我可能想要的任何乐队的信息。

我将在这里首先导入 `requests` 库，这是我之前安装的，用于发出那些 HTTP 请求。我将导入 `sys` 库，通过它我将能够使用命令行参数，比如指定我想搜索的乐队名称（如果不是 Weezer 的话）。然后在这里下面，我将插入一些错误检查，来说明如果 `sys.argv` 的长度不等于 2——所以如果用户没有提供给我他们想运行的文件名和一个乐队名，仅此而已，你知道吗。我们暂时就退出吧。我可以提供一个更具说明性的消息。但现在，我将保持简单，只是提前退出程序，以便我可以信任此后 `sys.argv` 包含我想要的内容。

```python
# itunes.py (initial structure)
import requests
import sys
import json # Added later for pretty printing

if len(sys.argv) != 2:
    sys.exit("Usage: python itunes.py <band_name>")

band_name = sys.argv[1]
api_url = f"https://itunes.apple.com/search?entity=song&limit=1&term={band_name}" # Limit initially 1

# response = requests.get(api_url) # This line will be added next
# print(response.json()) # This line will be added next
```

现在，我有机会使用 `requests` 库来编写一些 Python 代码，有效地假装成一个 Web 浏览器，以便连接到苹果自己服务器上的同一个 HTTPS URL。

所以现在我已经保证用户不仅输入了文件名，还在提示符下输入了一个乐队名，使得 `sys.argv` 的长度为 2，让我们执行 `requests.get`，这是 `requests` 包内部的一个函数，它将确实从服务器获取一些响应。我想获取的 URL 与之前完全相同：`https://itunes.apple.com/search?entity=song&limit=1&term=` 之前是 `weezer`。但让我们让这个程序有点交互性，实际上允许用户在命令行指定他们想搜索哪个艺术家。所以我将提前结束我的引号，然后像过去一样使用连接操作符追加 `sys.argv[1]`。（使用 f-string 更简洁）。现在，如果能将服务器的响应存储在一个变量中会很好。所以我将说 `response = ` 并将从服务器返回的所有响应存储在一个名为 `response` 的变量中。

```python
# itunes.py (making the request)
import requests
import sys
import json

if len(sys.argv) != 2:
    sys.exit("Usage: python itunes.py <band_name>")

band_name = sys.argv[1]
# Use f-string for cleaner URL construction
api_url = f"https://itunes.apple.com/search?entity=song&limit=1&term={band_name}"

response = requests.get(api_url)
# print(response.json()) # This line will be added next
```

在这里下面，我想先了解一下服务器返回给我的内容，以确保我知道接下来该如何进行。所以这还不会很漂亮。但我将打印出 `response.json()`，这确保我得到的数据在我的屏幕上格式化为 именно JSON，与我们在我屏幕上看到的相同文本格式。这还不是一个有用的程序。我真的只是在边学边做。

```python
# itunes.py (printing raw JSON)
import requests
import sys
import json

if len(sys.argv) != 2:
    sys.exit("Usage: python itunes.py <band_name>")

band_name = sys.argv[1]
api_url = f"https://itunes.apple.com/search?entity=song&limit=1&term={band_name}"

response = requests.get(api_url)
print(response.json())
```

但现在让我增大我的终端窗口，运行 `python itunes.py` 并输入一个乐队名，比如 Weezer，然后回车。我们在屏幕上看到的，格式与之前几乎相同，正是那个相同的文本。但你会在这里看到，这现在已经被标准化为一个 Python 字典。实际上苹果返回的是技术上的 JSON 响应，JavaScript Object Notation。但是 Python 的 `requests` 库正在将其转换为 Python 字典，碰巧，非常巧合地，使用了几乎相同的语法。它使用花括号 `{}` 来表示这里的字典，以及一个闭合花括号 `}` 来表示它的结束。对于其中的任何列表，它使用一个方括号 `[` 这里，以及一个闭合方括号 `]` 在这里下面。它使用引号——在这种情况下是单引号，或者等价地，双引号——来表示那个字典中的键。在一个冒号之后，它存储那个键的值。所以你会看到，我们确实有一个 `resultCount` 键，其值为 1，但随后有一个更有趣的结果键，叫做 `results`，其值是这整个数据列表。

老实说，这是一大块文本，我需要花很长时间才能弄清楚我看到的是什么。所以我建议暂时使用 Python 中的另一个库，它将允许我以更清晰的方式格式化我的数据。事实证明，Python 还自带一个名为 `json` 的特殊库，它允许你操作 JSON 数据，甚至只是“漂亮地打印”它，也就是以一种对你我来说更容易理解的方式格式化。

所以我回到我的代码。让我缩小我的终端窗口。我建议，仅仅是暂时的，我们这样做。让我导入这个额外的库 `json`，它随 Python 一起提供。所以我不需要用 `pip` 手动安装它。现在让我不仅打印出 `response.json()`（那是一大块难以理解的文本）。让我使用另一个名为 `json.dumps` 的函数，表示 dump string（转储字符串），并将那个 `response.json()` 的返回值传递给该函数。再次，我只是引入了另一个函数，我声称它的存在目的是漂亮地打印，在屏幕上以良好格式显示完全相同的信息。我从文档中知道这一点，因为我以前做过。但我希望内容能被很好地缩进。根据文档，如果我传入一个名为 `indent` 的命名参数，值为 2，那将使所有内容至少缩进两个空格。我可以用 4 或其他值。但这足以帮助我理解我得到的数据是什么。因为再次，我只是和你们一起学习。

```python
# itunes.py (using json.dumps for pretty printing)
import requests
import sys
import json

if len(sys.argv) != 2:
    sys.exit("Usage: python itunes.py <band_name>")

band_name = sys.argv[1]
api_url = f"https://itunes.apple.com/search?entity=song&limit=1&term={band_name}"

response = requests.get(api_url)

# Pretty print the JSON response
print(json.dumps(response.json(), indent=2))
```

所以让我再次增大我的终端窗口。让我运行 `python itunes.py`。再次，让我们搜索 Weezer 并回车。现在，注意它仍然有点神秘，因为这里有很多东西。但是天哪，我现在完全可以更容易地阅读这个了。注意，我现在仍然看到第一个花括号，这意味着嘿，这是 Python 中的一个字典。键和值的集合。第一个键叫做 `resultCount`。它碰巧现在用双引号显示。但这只是格式化的问题。可以是双引号或单引号，只要我们保持一致。那个键的值是 1。为什么？嗯，我告诉 URL 只将响应限制为一首 Weezer 的歌曲，所以我得到了一个包含一个结果的结果集。如果我增加那个限制，我可能能得到更多。然后这个响应中有趣的部分实际上是数据本身。注意在 `results` 键这里，有一个非常大的值。这个值是一个 Python 列表，由这个方括号 `[` 暗示。这个列表包含什么？嗯，我从之前快速浏览得知，它包含一个字典。这就是为什么我们在这里看到另一个花括号 `{`。

再次，如果这变得有点复杂，请记住字典只是键值对的集合。Python 使用花括号来表示这一点。一个字典在另一个字典内部是完全合理的，如果某个键的值本身就是另一个字典的话。所以这是一个常见的范式。即使它可能看起来有点神秘，它只是允许我们将更多的键与更多的值关联起来。

现在，这些信息中的大部分，我可能并不关心。例如，根据苹果公司的说法，Weezer 的唯一标识符显然是 115,234。如果我正在制作自己的数据库并且想让这个可搜索，这可能有用。但就今天的目的而言，我只关心曲目的名称，也就是键为 `trackName`。我们从 iTunes 这里得到的第一首也是唯一一首歌曲（因为我们将其限制为一首）是 Weezer 的那首你可能知道的歌，叫做 "Say It Ain't So"。

所以现在，我有了一点线索，如果我这里的目标是实现一个名为 `itunes.py` 的程序，它不仅仅是转储来自服务器的响应（这确实非常神秘）——而是打印出 iTunes 拥有的名为 Weezer 的乐队的所有歌曲，也许我可以以某种方式迭代这个。

让我回溯一下。这里的键叫做 `trackName`。它在一个字典内部，这个字典是这里 `results` 的值。所以我该如何获取这个呢？嗯，让我试试这个。让我缩小我的终端窗口。让我建议现在进行最后一次润色。我们不只是懒惰地打印出那个响应的内容，因为那对任何人来说都既不有趣也不漂亮。让我们这样做。让我创建一个新变量，仅仅是为了讨论方便，叫做 `o`（代表 object，对象）。我将调用 `o = response.json()`，只是为了将那个 JSON 响应具体地存储在一个名为 `o` 的变量中，但我可以给它起任何我想要的名字。

现在，我将这样做。对于那个对象的名为 `results` 的键中的每个 `result`，打印出那个 `result` 的 `trackName`。注意我使用了完全相同的大小写。`trackName` 有一个大写的 N。`result` 是全小写的。在我们运行实际程序之前，让我倒带一下。

在第 8 行（左右），我们使用 Python 向服务器发出 HTTP 请求，就像你我作为人类在浏览器中输入 URL 并按回车一样。这是 Python 的等价操作。然后我在第 10 行（左右）只是从那个包含服务器响应的变量中抓取我关心的 JSON 对象。也就是最顶部和最底部那些花括号之间的东西。但因为我们已经探索过，并且因为我之前阅读了文档，我知道那个对象有一个名为 `results` 的键。那个 `results` 键再次强调，是一个列表。目前，那个列表只包含一首歌，"Say It Ain't So"，因为我将我的响应限制为一首。但即便如此，我的循环也能工作。它只是迭代一次。每次通过那个循环，它将打印当前 `result` 的 `trackName`。

如果我想让这个更有趣一点，让我现在把这个限制从 1 改为 50，这样我至少能得到 50 个曲目名称。

```python
# itunes.py (final version - extracting track names)
import requests
import sys
import json

if len(sys.argv) != 2:
    sys.exit("Usage: python itunes.py <band_name>")

band_name = sys.argv[1]
# Increase limit to 50
api_url = f"https://itunes.apple.com/search?entity=song&limit=50&term={band_name}"

try:
    response = requests.get(api_url)
    response.raise_for_status() # Check for HTTP errors
    o = response.json()
    for result in o['results']:
        print(result['trackName'])
except requests.RequestException:
    sys.exit("Could not retrieve data from iTunes API.")
except KeyError:
    sys.exit("Unexpected data format received from iTunes API.")
except json.JSONDecodeError:
    sys.exit("Could not decode JSON response from iTunes API.")
```
*(Note: Added basic error handling for robustness, though not explicitly detailed in the original script)*

让我现在再次增大我的终端窗口，然后运行 `python itunes.py` 再次搜索像 Weezer 这样的乐队。开始了。瞧，这里有 iTunes 拥有的 Weezer 的 50 首歌。如果我们向上滚动到顶部，我们会看到第一首确实是 "Say It Ain't So"。但现在我们得到了 "Undone – The Sweater Song", "Buddy Holly"。显然是 "Say It Ain't So" 的另一个版本，也许来自另一张专辑，另一个 "Buddy Holly"，"Undone"，"My Name Is Jonas"，等等。

现在关于这个将 Python 与真实世界的第三方 API 集成的程序，有什么问题吗？

**问：** 是的，嗨。我们可以用 `break` 来代替 `system.exit` 吗？

**答：** 好问题，但是不行。`break` 再次强调，是用于跳出像我们之前看到的循环那样的结构。`sys.exit` 是用于跳出整个程序本身。暂时将 `break` 用于循环，将 `sys.exit` 用于终止整个程序。好问题。

现在关于这个程序或其他方面还有其他问题吗？

**问：** 我们从哪里得到键 `results` 的名字？

**答：** 我们从哪里得到键的名字？

**问：** `results` 本身。是的，我们可以改变 `results` 这个名字吗？

**答：** 你不能。所以我们可以在我们的程序中。要明确的是，那个 JSON 响应中返回的键来自 iTunes.Apple.com。某个工程师团队为我们决定了所有那些键应该叫什么，包括 `trackName`, `results`, `resultCount` 以及其他所有。你我绝对可以将那些相同的值存储在变量中，就像我在这里用 `o` 做的那样，就像我在这里用 `result` 做的那样。你可以使用 Python 变量将那些键重命名为你想要的任何东西。但是 JSON 响应是来自那个第三方服务器的。

还有其他问题吗？

**问：** 是的，先生。我有一个与 `cowsay` 包相关的问题。是的。所以先生，它能够放置哪种 ASCII 图形？

**答：** `cowsay` 包。我建议你参考幻灯片中早些时候的 URL，只因为那里更详尽。它们不仅有牛，还有霸王龙以及其他几种动物。我应该强调，我不认为这是一个你会在现实世界中经常使用的包。它真的只是用来代表你可以安装的包的类型。但我建议参考文档了解更多内容。但在有表情符号之前，更不用说 GIF、JPEG 和 PNG 了，ASCII 艺术就是我们所拥有的全部。但它在 `cowsay` 中永垂不朽。

## 七、 创建自定义库 (Custom Libraries)

嗯，请允许我现在将我们转回到 Python 的最后一个功能，那就是你们自己有能力制作自己的库。

到目前为止，我们一直把我们所有的函数写在一个文件里，`hello.py` 以及之后的所有文件。现在我们已经介绍了 Python 中的模块，`random` 和 `statistics`，我们可以导入那些 Python 自带的模块。但那也是别人的代码。我们现在还使用了 `pip` 这个包管理器来在系统上安装第三方包，并且仍然在使用别人的代码。但是回到原点，如果你自己发现自己反复实现同一种类的函数，或者你发现自己打开旧程序，把你写的代码复制粘贴到新程序中，因为你又遇到了同样的问题怎么办？一个好的做法是，以某种方式把你不断重用的代码捆绑起来，制作你自己的 Python 模块或包。你可以把它保存在本地你自己的 Mac、PC 或云服务器上。或者你可以完成实际打包的步骤，使其成为免费和开源的，并将其放在像 PyPI 这样的地方供他人使用。

好的，我将运行 `code sayings.py` 来创建一个全新的名为 `sayings.py` 的文件，它将是我自己的 `sayings` 模块。我将在里面定义几个简单的函数。我将定义一个 `hello` 函数，它接受一个 `name` 参数作为输入。那个函数将简单地打印出一个 F 字符串，包含 "hello, "，然后在花括号里是那个人的名字实际是什么。

```python
# sayings.py (initial version)
def hello(name):
    print(f"Hello, {name}")

# def goodbye(name): ... # This function will be added next
# def main(): ... # This function will be added next
# main() # This call will be added initially
```

然后我将定义另一个函数，一个 `goodbye` 函数，定义为 `def goodbye`，也接受一个 `name` 作为其输入。然后那个函数相比之下打印出一个 F 字符串，说 "goodbye, "，然后在花括号里是 `name`。

```python
# sayings.py (adding goodbye)
def hello(name):
    print(f"Hello, {name}")

def goodbye(name):
    print(f"Goodbye, {name}")

# def main(): ...
# main()
```

现在，为了确保这些函数按预期工作，我将在这里面也定义一个 `main` 函数，仅仅是为了测试的目的。我将定义一个 `main` 函数，它简单地做几个测试。例如，它调用 `hello`，参数是，引号引起来的，"world"，我们说吧？然后它将调用 `goodbye`，参数也是，引号引起来的，"world"。希望到时我运行这个程序时，在屏幕上会看到 "Hello world" 和 "Goodbye world"。

```python
# sayings.py (adding main for testing)
def hello(name):
    print(f"Hello, {name}")

def goodbye(name):
    print(f"Goodbye, {name}")

def main():
    hello("world")
    goodbye("world")

# main() # This call will be added next
```

当然，像往常一样，我需要明确告诉 Python 调用那个函数。所以我将在文件最底部调用 `main`。

```python
# sayings.py (initial version with direct main call)
def hello(name):
    print(f"Hello, {name}")

def goodbye(name):
    print(f"Goodbye, {name}")

def main():
    hello("world")
    goodbye("world")

main()
```

好了，让我们试试。`python sayings.py`，回车。确实，我看到了 "Hello world" 和 "Goodbye world"。所以我认为我可以合理地假设这些函数，尽管简单，在这一点上是相当正确的。

但是现在，假设我想使用这些函数，就好像我确实创建了自己的库，我自己的 Python 模块，并且它提供了一个 `hello` 函数供我或任何想使用它的人使用，或者一个 `goodbye` 函数也一样。

嗯，让我再次打开 `say.py`，但重新开始。与其让牛说任何话，不如让我让我自己的库来说话。所以我将像之前一样，导入 `sys` 以便我可以访问命令行参数。然后从我自己的名为 `sayings` 的模块中，我将导入 `hello`。因为我创建了一个名为 `sayings.py` 的文件，所以我可以说 `from sayings`。Python 会推断我的意思是 `sayings.py`，至少在当前目录下是这样。但我将特别地暂时只导入其中一个函数，即 `hello`。

现在，我可以做类似这样的事情。如果用户遵从，给我两个命令行参数，我可以通过检查 `sys.argv` 的长度来检查，然后我将调用这个新的 `hello` 函数，将 `sys.argv[1]` 作为其输入传递，这应该是我期望他们在提示符下输入的人名。

```python
# say.py (using custom library - initial)
import sys
from sayings import hello

if len(sys.argv) == 2:
    hello(sys.argv[1])
```

就这样。我将到我的终端窗口，运行 `python say.py` 和我自己的名字，因为我想让我自己的名字最终出现在命令行参数中，因此成为 `hello` 的一部分，所以当我稍后按回车时，我应该希望能看到 "Hello, David"。

就这样，回车。嗯，我看到了 "Hello world", "Goodbye world"。然后我看到了 "Hello, David"。那么为什么会发生这种情况呢？

嗯，事实证明，即使我按照我们过去的惯例做了所有事情，但这并不是最终调用 `main` 的真正正确方式。如果我盲目地在我的文件底部调用 `main`，这意味着每当这个文件被 Python 加载时，`main` 就会被调用。不幸的是，即使我像在我的 `say.py` 程序中那样导入这个文件或只是从这个文件中导入一个函数，情况也是如此。这就是说，在第 3 行这里，当我说 `from sayings import hello` 时，这实际上告诉 Python 去找到那个模块 `sayings.py`，从上到下、从左到右读取它，然后特别导入 `hello` 函数。不幸的是，当 Python 从上到下、从左到右读完文件时，回想一下那最后一行代码是调用 `main`。无论如何 `main` 都会被调用。

所以真的，使用 `main` 函数的正确方式——它确实解决了确保我们可以按任何顺序排列函数，并且所有函数在被调用时都已被定义的问题——我不应该无条件地在这个或任何我的程序的底部调用 `main`。我应该改用这个技巧。我应该说 `if __name__ == "__main__":`，那么并且只有在那时，你才应该实际调用 `main`。

```python
# sayings.py (corrected with if __name__ == "__main__")
def hello(name):
    print(f"Hello, {name}")

def goodbye(name):
    print(f"Goodbye, {name}")

def main():
    hello("world")
    goodbye("world")

if __name__ == "__main__":
    main()
```

嗯，事实证明这个变量是 Python 中的一个特殊符号，`__name__`（双下划线 name 双下划线）。注意 VS Code 因为它的字体没有完全显示那两个下划线。但它们确实在左右两边。这是一个特殊的变量，当你从命令行运行一个文件时，比如运行 `python sayings.py`，Python 会自动将其值设置为，引号引起来的，`"__main__"`。所以注意现在在 `sayings.py` 中有了这个额外的条件判断会发生什么。如果我运行 `python sayings.py`，它仍然像以前一样工作，因为当我使用 `python sayings.py` 运行这个文件时，`name` 会被自动设置为 `__main__`。

但是注意这个。当**我**反而像在这里一样导入文件时，`name` 将不会被设置为，引号引起来的，`"__main__"`。它将被设置为其他东西，技术上是模块的名称。所以这行高亮的代码，即使它会导致 Python 去找到 `sayings.py`，从上到下、从左到右读取它，这次它将忽略对 `main` 的调用，因为它被包裹在那个条件判断中。在这种情况下，当我导入一个文件而不是在命令行直接运行它时，根据那个 `name` 变量的值的定义，`main` 将不会被调用。

所以让我试试这个。与其运行 `python sayings.py`（这是模块，包含那个条件 `main`），不如让我在这里，运行 `python say.py`（这是我面前的程序，它从 `sayings` 导入 `hello`）。但因为那个条件判断，它不会向除我之外的任何人说 Hello（在这个例子中）。

```python
# say.py (running again after fixing sayings.py)
import sys
from sayings import hello

if len(sys.argv) == 2:
    hello(sys.argv[1])
```
*(Running `python say.py David` now correctly outputs only "Hello, David")*

好了，我们这周的课程到此结束了。我认为，只导入 Hello 之外的东西是合适的。为什么我不导入 `goodbye` 而不是 `hello` 呢。让我调用 `goodbye` 而不是 `hello`。这次当我运行 `python say.py` 时，我将不输入我自己的名字。请允许我，如果可以的话，输入整个世界，以便我们今天的最后感言是 "Goodbye world"。

```python
# say.py (final farewell version)
import sys
# Import goodbye instead
from sayings import goodbye

if len(sys.argv) == 2:
    # Call goodbye instead
    goodbye(sys.argv[1])
```
*(Running `python say.py world` outputs "Goodbye, world")*

确实，这就是本周的全部内容。我们下次再见。


---

# 要点回顾

**CS50P 第 4 讲 - 库 (Libraries)**

**一、 库与模块 (Libraries and Modules)**

-   **库 (Library)**: 指其他人或自己编写的代码文件，可在自己的程序中复用。
-   **模块 (Module)**: Python 中对库的称呼，通常包含一个或多个函数或其他功能。
-   **目的**: 鼓励代码复用，避免重复编写或复制粘贴相同功能的代码。
-   **获取**: Python 安装时会自带许多标准库（模块），例如 `random`。
-   **文档**: 可在 Python 官方文档网站 (docs.python.org) 查找模块的具体用法和包含的函数。

**二、 导入和使用模块 (Importing and Using Modules)**

-   **`import` 关键字**: 用于将模块加载到程序中。
    -   语法: `import module_name`
    -   使用方式: 调用模块内函数时需使用 `module_name.function_name()` 的形式。
    -   示例:
        -   `import random`
        -   `coin = random.choice(["heads", "tails"])` # 从列表中随机选择一项
        -   `number = random.randint(1, 10)` # 生成指定范围内的随机整数 (包含边界)
        -   `cards = ["Jack", "Queen", "King"]`
        -   `random.shuffle(cards)` # 原地打乱列表元素的顺序 (无返回值)
-   **`from` 关键字**: 用于从模块中导入特定的函数或变量到当前命名空间。
    -   语法: `from module_name import function_name` 或 `from module_name import *` (不推荐)
    -   使用方式: 可以直接调用函数名 `function_name()`，无需模块名前缀。
    -   示例:
        -   `from random import choice`
        -   `coin = choice(["heads", "tails"])`
    -   **优缺点**:
        -   优点: 代码更简洁，少打字。
        -   缺点: 可能导致命名冲突（如果你自己定义了同名函数/变量），降低代码可读性（不易看出函数来源）。对于简短程序或频繁使用的函数可能更方便。
-   **`statistics` 模块**: 提供统计相关函数。
    -   示例:
        -   `import statistics`
        -   `average = statistics.mean([100, 90])` # 计算平均值

**三、 命令行参数 (Command-Line Arguments)**

-   **概念**: 在执行 Python 脚本时，在命令行（终端）中传递给程序的额外输入信息，而非在程序运行时通过 `input()` 获取。
-   **`sys` 模块**: 提供与 Python 解释器和系统交互的功能。
    -   `sys.argv`: 一个列表 (list)，包含所有在命令行输入的参数。
        -   `sys.argv[0]` 永远是脚本文件本身的名称 (e.g., `name.py`)。
        -   `sys.argv[1]` 是第一个命令行参数。
        -   `sys.argv[2]` 是第二个，以此类推。
    -   **错误处理**:
        -   如果用户未提供足够的参数，直接访问如 `sys.argv[1]` 会引发 `IndexError` (列表索引超出范围)。
        -   处理方法 1 (异常处理): 使用 `try...except IndexError:` 捕获错误。
        -   处理方法 2 (条件检查): 使用 `len(sys.argv)` 检查参数数量是否符合预期。
            -   `if len(sys.argv) < 2:` # 参数过少
            -   `elif len(sys.argv) > 2:` # 参数过多
            -   `else:` # 参数数量正确
    -   **`sys.exit(message)`**: 终止程序执行，并可以输出一条错误消息到标准错误流。常用于参数检查不通过时提前退出程序，使主逻辑更清晰。
        -   示例:
            -   `if len(sys.argv) < 2: sys.exit("Too few arguments")`
            -   `if len(sys.argv) > 2: sys.exit("Too many arguments")`
            -   `name = sys.argv[1]` # 在检查通过后安全使用

**四、 列表切片 (List Slices)**

-   **概念**: 获取列表的一部分（子列表）。
-   **语法**: `list_name[start:end]`
    -   `start`: 起始索引（包含）。如果省略，默认为 0。
    -   `end`: 结束索引（不包含）。如果省略，默认为列表末尾。
-   **示例**:
    -   `sys.argv[1:]`: 获取从索引 1 开始到列表末尾的所有元素（即所有用户输入的命令行参数，不包括脚本名）。
    -   `sys.argv[1:-1]`: 获取从索引 1 开始到倒数第二个元素（不包括最后一个）。
    -   负数索引: `-1` 表示最后一个元素，`-2` 表示倒数第二个，以此类推。
-   **应用**: 在处理 `sys.argv` 时，常用于排除脚本名，只遍历用户提供的参数。
    -   `for arg in sys.argv[1:]: print("Hello,", arg)`

**五、 第三方库与包管理器 (Packages, PyPI, pip)**

-   **包 (Package)**: 第三方开发者编写的库，提供了 Python 标准库之外的更多功能。（技术上，包是一个包含 `__init__.py` 文件的目录，可以包含子模块）。
-   **PyPI (Python Package Index)**: 官方的第三方 Python 软件包存储库 (pypi.org)。
-   **`pip`**: Python 的包安装器 (Package Installer for Python)，用于从 PyPI 下载和安装第三方包。
    -   安装命令: `pip install package_name`
    -   示例: `pip install requests`
    -   示例 (趣味): `pip install cowsay`
        -   `import cowsay`
        -   `cowsay.cow("Hello")` 或 `cowsay.trex("Hello")`

**六、 API、Requests 与 JSON**

-   **API (Application Programming Interface)**: 应用程序编程接口，允许不同软件之间进行交互和数据交换。Web API 通常通过 HTTP 请求访问。
-   **`requests` 库**: 一个流行的第三方库，用于简化发送 HTTP 请求的操作。
    -   `response = requests.get(url)`: 发送 GET 请求到指定 URL，并将服务器响应存储在 `response` 对象中。
-   **JSON (JavaScript Object Notation)**: 一种轻量级的数据交换格式，易于人阅读和编写，也易于机器解析和生成。常用于 Web API 的数据传输。
    -   结构: 基于键值对（类似 Python 字典）和值的有序列表（类似 Python 列表）。
-   **处理 JSON 响应**:
    -   `response.json()`: `requests` 库提供的方法，将获取到的 JSON 格式响应直接解析为 Python 的字典或列表。
    -   示例 (iTunes API):
        -   构造查询 URL: `https://itunes.apple.com/search?entity=song&limit=50&term=band_name`
        -   发送请求: `response = requests.get(api_url)`
        -   解析 JSON: `data = response.json()`
        -   访问数据: 通过字典键和列表索引访问所需信息，例如 `data['results'][0]['trackName']`。
-   **`json` 模块**: Python 内置模块，用于处理 JSON 数据。
    -   `json.dumps(python_object, indent=...)`: 将 Python 对象（如字典或列表）序列化为 JSON 格式的字符串，`indent` 参数可用于美化输出（增加缩进）。常用于调试时查看 API 返回的复杂数据结构。

**七、 创建自定义库 (Custom Libraries)**

-   **动机**: 将自己频繁使用的函数封装起来，方便在不同项目中复用。
-   **实现**:
    -   创建一个新的 `.py` 文件（例如 `sayings.py`）。
    -   在该文件中定义所需的函数（例如 `def hello(name): ...`, `def goodbye(name): ...`）。
-   **使用**:
    -   在另一个 Python 文件（例如 `main_program.py`）中，使用 `import sayings` 或 `from sayings import hello` 来导入自定义模块或函数。
    -   调用导入的函数：`sayings.hello("World")` 或 `hello("World")`。
-   **`if __name__ == "__main__":`**
    -   **问题**: 直接在自定义库文件（如 `sayings.py`）底部调用函数（例如 `main()` 或测试代码）会导致这些代码在被其他文件 `import` 时也执行。
    -   **`__name__` 变量**: Python 中的一个特殊内置变量。
        -   当文件被直接运行时（`python sayings.py`），`__name__` 的值是 `"__main__"`。
        -   当文件被其他文件 `import` 时，`__name__` 的值是该模块的名称（例如 `"sayings"`）。
    -   **解决方案**: 将只希望在直接运行文件时执行的代码（如测试代码、`main()` 函数调用）放在 `if __name__ == "__main__":` 代码块内。这样可以确保这些代码在模块被导入时不会执行。
    -   标准实践:
        ```python
        # In sayings.py
        def hello(name):
            print(f"Hello, {name}")

        def goodbye(name):
            print(f"Goodbye, {name}")

        def main():
            # Test code
            hello("world")
            goodbye("world")

        if __name__ == "__main__":
            main()
        ```
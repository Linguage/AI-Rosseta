
# 「哈佛CS50P-Python编程导论」第6讲 - 文件 I/O

- 视频链接：[CS50P - Lecture 6 - File I/O](https://www.youtube.com/watch?v=KD-Yoel6EVQ&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=8)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。

---

### 内容介绍

本篇内容整理自 CS50 Python 编程入门系列的第六讲，主题为“文件 I/O”。在编程实践中，程序运行时产生的数据通常存储在内存中，这意味着一旦程序结束，这些宝贵的信息便会丢失。本次讲座的核心目的，正是要解决这一局限性，探讨如何通过文件输入与输出操作，实现数据的持久化存储，让信息能够在程序关闭后依然得以保留和复用。

讲座将从基础出发，首先回顾列表等内存数据结构的局限，进而引导至文件操作的必要性。内容逐步深入，涵盖了使用 Python 内建函数 `open()` 进行基本的文件读取（read）与写入（write、append）操作，并强调了正确处理换行符、管理文件句柄的重要性，特别推荐使用 `with` 语句来确保资源的妥善释放。

随后，讲座聚焦于处理结构化数据，详细介绍了 CSV（逗号分隔值）文件格式。不仅演示了手动解析 CSV 可能遇到的陷阱（如数据中包含分隔符），更着重介绍了 Python 标准库 `csv` 模块的强大功能，包括 `reader`、`DictReader`、`writer` 和 `DictWriter`，它们能更健壮、便捷地处理 CSV 数据。此外，还探讨了如何利用 `sorted()` 函数的 `key` 参数及 `lambda` 函数对复杂数据结构（如字典列表）进行排序。

最后，讲座将视野扩展至二进制文件，以图像处理为例，通过第三方库 `Pillow` 展示了如何读取、操作乃至创建动画 GIF 文件，体现了 Python 在处理多种文件类型方面的能力。

### 内容纲要

```
└── 文件 I/O (CS50P Lecture 6)
    ├── 一、 文件 I/O 基础
    │   ├── 引入：程序内存数据的临时性
    │   └── 目的：持久化存储数据
    ├── 二、 使用列表存储数据的局限性 (回顾)
    │   ├── 示例：names.py 初始版本
    │   ├── append() 添加元素
    │   ├── sorted() 排序列表
    │   └── 问题：程序退出后数据丢失
    ├── 三、 文件写入操作
    │   ├── open() 函数
    │   │   ├── 参数：文件名, 模式 ('w' - 写入/覆盖, 'a' - 追加)
    │   │   └── 返回：文件句柄
    │   ├── write() 方法
    │   │   └── 注意：不自动添加换行符 (\n)
    │   ├── close() 方法：保存并关闭文件
    │   └── 问答：'w' 模式覆盖问题与 'a' 模式追加解决方案
    │   └── 问答：手动添加换行符 '\n' 的必要性
    ├── 四、 使用 `with` 语句管理文件 (推荐)
    │   ├── 目的：自动关闭文件，更安全
    │   └── 语法：with open(...) as file: ...
    ├── 五、 文件读取操作
    │   ├── open() 函数 (模式 'r' - 读取，为默认)
    │   ├── 读取方法
    │   │   ├── readlines()：读取所有行为列表
    │   │   └── 直接迭代文件句柄：for line in file: (更 Pythonic)
    │   └── 处理行尾换行符
    │       ├── print() 的默认行为
    │       ├── 解决方法：print(..., end="") 或 line.rstrip() (推荐)
    │       └── 问答：为何 readlines 不自动去除 \n
    ├── 六、 读取文件并排序
    │   ├── 需求：按特定顺序处理数据
    │   ├── 方法：先读入列表 -> 再排序 -> 后处理
    │   ├── sorted() 函数
    │   │   └── 参数：reverse=True 实现反向排序
    │   └── 问答：关于反向排序
    │   └── 问答：关于限制数量和查找特定条目
    ├── 七、 处理结构化数据：CSV 文件
    │   ├── 问题：存储关联数据（如姓名和学院）
    │   ├── CSV 格式介绍：逗号分隔值
    │   ├── 手动解析 CSV
    │   │   ├── line.rstrip().split(',')
    │   │   ├── 索引访问 (row[0]) vs. 解包 (name, house = ...)
    │   │   └── 陷阱：数据本身包含逗号
    │   └── 问答：关于编辑文件中间行 vs 追加
    ├── 八、 使用 `csv` 模块处理 CSV 文件 (推荐)
    │   ├── 动机：处理复杂情况（引号、逗号），更健壮
    │   ├── import csv
    │   ├── 读取 CSV
    │   │   ├── csv.reader：返回行列表
    │   │   └── csv.DictReader：返回行字典 (需标题行，更灵活)
    │   ├── 写入 CSV
    │   │   ├── csv.writer：writerow() 接收列表
    │   │   └── csv.DictWriter：writerow() 接收字典 (需 fieldnames)
    │   └── 优势：自动处理引用和转义
    │   └── 问答：关于同时读写文件 (顺序访问模型)
    │   └── 问答：关于写入段落
    │   └── 问答：用户是否能选择键 (引出 DictReader/Writer)
    │   └── 问答：CSV 文件中换行符的作用 (约定)
    │   └── 问答：处理更多列数据 (DictReader 的优势)
    │   └── 问答：关于 DictReader 是否可以直接 append(row)
    │   └── 问答：读取 CSV 的最佳实践 (代码 vs 人为错误)
    ├── 九、 排序复杂数据结构 (列表中的字典)
    │   ├── 场景：对从 CSV 读取的字典列表排序
    │   ├── sorted() 函数与 key 参数
    │   ├── 方法1：定义辅助函数
    │   ├── 方法2：使用 lambda 匿名函数
    │   └── 问答：key 参数函数的执行方式
    │   └── 问答：关于嵌套字典 vs 字典列表
    │   └── 问答：关于 lambda 函数的使用和参数
    ├── 十、 处理二进制文件 (以图像为例)
    │   ├── 概念：文本文件 vs 二进制文件 (0s 和 1s)
    │   ├── Pillow (PIL) 库介绍：图像处理
    │   ├── 示例：创建动画 GIF
    │   │   ├── import sys, from PIL import Image
    │   │   ├── 获取命令行参数 (sys.argv[1:])
    │   │   ├── Image.open() 打开图像
    │   │   └── Image.save() 创建动画 (save_all, append_images, duration, loop)
    └── 十一、 总结
        └── 回顾文件 I/O 的能力：文本、CSV、二进制文件
```


---

# CS50P - 课程 6 - 文件 I/O 演讲实录

## 一、 文件 I/O 基础

[人群低语声] [音乐播放]

好的，这里是 CS50 的 Python 编程入门课。我是 David Malan，这是我们关于文件 I/O（输入与输出）的一周。

到目前为止，我们编写的几乎所有程序都只是将收集到的所有信息存储在内存中——也就是存储在变量里或者程序本身内部。这样做的缺点是，一旦程序退出，你输入的任何东西，你用那个程序做的任何事情，都会丢失。当然，通过使用你 Mac 或 PC 上的文件，你可以长期保存信息。而在编程的语境下，文件 I/O 就是编写代码，用来从文件中读取（也就是加载信息），或者向文件中写入（也就是保存信息）。

那么，让我们看看是否能从仅仅使用内存、变量等方式，过渡到实际编写能够为我们保存文件，从而持久化存储数据的代码。

## 二、 使用列表存储数据的局限性 (回顾)

为了做到这一点，我建议我们首先考虑一个熟悉的数据结构，一种我们以前见过的变量类型，那就是列表（list）。

使用列表，我们过去能够存储不止一条信息。使用一个变量，我们通常存储一个值。但如果那个变量是列表，我们就能存储多个值。不幸的是，列表存储在计算机的内存中。因此，一旦你的程序退出，即使是列表的内容也会消失。但至少让我们从一个起点开始。

我现在在 VS Code 里。我准备创建一个简单的程序，叫做 `names.py`，这个程序就是收集人们的名字，比如学生的名字。我一开始会用非常简单的方式来做，与我们过去获取用户输入并打印输出的方式一致。我会写类似这样的代码：

```python
name = input("What's your name? ")
# 将 input 的返回值存储在名为 name 的变量中
```

然后，像往常一样，我会非常简单地打印出一个漂亮的 f-string：

```python
print(f"Hello, {name}")
# 打印出 Hello, David 或 Hello, world，取决于谁在使用程序
```

我们来运行一下，提醒自己应该期待什么结果。如果我运行 `python names.py` 并回车，输入我的名字，比如 David，当然，我现在会看到 "Hello, David"。

但是，假设我们想支持不止一个名字，而是多个名字——比如说三个名字，这样我们就可以开始在程序中积累一些信息，以至于如果程序退出时我们总是丢弃这些信息，那将是一个真正的缺点。

好，让我们回到 `names.py` 的顶部。让我主动地给自己创建一个变量，这次叫做 `names`，复数形式。并将其设置为空列表。回想一下，方括号表示法，特别是里面什么都没有的时候，就意味着“给我一个空列表，我们可以随着时间的推移向其中添加东西”。

那么，我们想往里面添加什么呢？让我们添加三个来自用户的名字。我可以这样写：

```python
names = []
for _ in range(3):
    name = input("What's your name? ")
    names.append(name)
```

现在，在那个列表里，我就有了指定的名字——1个，2个，3个。需要注意的其他点是，我本可以在这里用一个变量，比如 `i`，这是常规做法。但如果我实际上在后续的任何行中都没有显式地使用 `i`，我不如就用下划线 `_`，这是一个 Pythonic 的约定。

而且，如果我想稍微清理一下代码，注意到我的 `name` 变量其实并不真的需要存在，因为我给它赋了一个值，然后立刻就把它追加（append）了。那么，我可以进一步精简代码，完全去掉那个变量，直接追加 `input` 的返回值：

```python
names = []
for _ in range(3):
    names.append(input("What's your name? "))
```

我认为这里的设计可以有两种看法。一方面，这行代码很短，而且可读。另一方面，如果我最终把提示语从 "What's your name?" 改成更长的内容，我们可能又想把它拆分成两行。但就目前而言，我认为它非常可读。

现在，在程序的后面部分，让我们把这些名字打印出来，但让我们按字母顺序对它们进行排序，这样收集它们，然后排序并打印出来才有意义。那么我该怎么做呢？

在 Python 中，在循环中对列表进行排序的最简单方法大概是这样的：

```python
# (前面的代码获取了 names 列表)

for name in sorted(names): # 注意这里使用了 sorted() 函数
    print(f"Hello, {name}")
```

回想一下，有一个叫做 `sorted` 的函数，它会返回那个列表的一个排序后的版本。现在我们打印 f-string "Hello, [name]"。

好了，让我运行一下这个。输入 `python names.py`。这次我输入几个名字。比如 Hermione？比如 Harry？比如 Ron？注意它们的顺序不完全是字母顺序。但当我按下回车，那个循环开始执行时，它会按排序后的顺序打印出 "Hello, Harry", "Hello, Hermione", "Hello, Ron"。

但是，当然了，如果我现在再次运行这个程序，所有的名字都丢失了。如果这是一个比现在这个更大的程序，每次都必须重新输入相同的信息可能会非常痛苦。要是能像现在手机、笔记本、台式机或云上的大多数程序一样，以某种方式保存这些信息，那该多好呢？

## 三、 文件写入操作

这就是文件 I/O 发挥作用的地方。这也是文件派上用场的地方。它们是一种在你的手机、Mac、PC 或某个云服务器的磁盘上持久存储信息的方式，这样当你回来再次运行程序时，它们还在那里。

那么，我们如何才能把这三个名字都保存在一个文件中，而不是每次都得重新输入呢？

让我先简化一下这个文件，再次只给自己一个名为 `name` 的变量。

```python
name = input("What's your name? ")
```

现在，让我们对这个值做更多的事情。与其仅仅把它添加到一个列表里或者立即打印出来，不如让我们把刚刚输入的这个人的名字保存到一个文件中。

那么，我们该怎么做呢？

在 Python 中，有一个叫做 `open` 的函数，它的作用就是打开一个文件，但是是以编程的方式打开它，这样你，作为程序员，就可以实际地从中读取信息或向其中写入信息。所以 `open` 就像是程序员版的在你 Mac 或 PC 上双击图标。但它是一种程序员的技术，因为它允许你精确地指定你想从哪个文件读取或向哪个文件写入什么内容。

形式上，它的文档在这里，你会看到它的用法相对直接。它最少只需要我们想打开的文件名，以及可选地，我们想如何打开它。

所以，回到 VS Code，我建议现在这样做。我准备调用这个叫做 `open` 的函数，传入一个参数 `'names.txt'`，这是我想要存储所有这些名字的文件名。我可以叫它任何名字。但因为它将只是文本，所以通常把它命名为 `something.txt`。

但我还要告诉 `open` 函数，我打算**写入**这个文件。所以，作为 `open` 的第二个参数，我会写上 `'w'`，代表 Write（写入），这会告诉 `open` 以一种允许我更改内容的方式打开文件。更好的是，如果这个文件还不存在，它会为我创建文件。

现在，`open` 函数返回所谓的“文件句柄”（file handle），这是一个特殊的值，允许我后续访问那个文件。所以我将把它赋值给一个像 `file` 这样的变量。

```python
file = open("names.txt", "w")
```

现在，我将非常简单地把这个人的名字写入那个文件。我会直接输入 `file`，也就是链接到那个文件的变量，然后是 `.write`，这是一个伴随打开的文件而来的函数（也称为方法），它允许我将那个名字写入文件。

```python
file.write(name)
```

最后，我将非常简单地执行 `file.close()`，这将关闭并有效地保存文件。

```python
file.close()
```

所以，这里的这三行代码，本质上就是程序员版的在你 Mac 或 PC 上双击图标，在 Microsoft Word 或其他程序中做些修改，然后点击“文件”->“保存”。我们用这三行代码就完成了所有这些操作。

好，现在我们来看看这是如何工作的。让我现在运行 `python names.py` 并回车。输入一个名字。我输入 Hermione，回车。好了，她去哪儿了？

嗯，让我现在输入 `code names.txt`，这个文件现在恰好存在了，因为我是用写入模式打开它的。如果我在一个标签页中打开它，我们会看到 Hermione 在那里。

好，让我们再运行一次 `names.py`。运行 `python names.py`，回车，这次我输入 Harry。让我再运行一次。这次我输入 Ron。现在让我去 `names.txt`，希望我能看到他们三个都在这里。

但是没有。我实际上只看到了 Ron。这可能解释了 Hermione 和 Harry 发生了什么，即使我很确定我运行了三次程序，并且我确实写了将他们的名字写入那个文件的代码？

**问：** （观众提问）我想是因为我们没有追加（append）它们，我们应该追加名字。因为我们是直接写入（writing），它会擦除旧内容，并用我们提到的最后一组字符替换它。

**答：** 完全正确。不幸的是，`'w'` 有点危险。它不仅会为你创建文件，而且每次你以该模式打开文件时，它还会为你**重新创建**文件。所以，如果你打开文件一次并写入 Hermione，那就像我们看到的那样工作得很好。但如果你再为 Harry 做一次，再为 Ron 做一次，代码是在工作。但每次它打开文件时，都会用全新的内容重新创建它，所以我们有一个只有 Hermione 的版本，一个只有 Harry 的版本，以及最后一个只有 Ron 的版本。但理想情况下，我想我们可能希望像 Vishal 说的那样，将每个名字**追加**（appending）到文件中，而不是每次都覆盖（clobbering）文件。

那么我该怎么做呢？这其实是一个相对容易的修复。让我这样做。首先，我移除旧版本的 `names.txt`。现在我修改我的代码，将 `'w'` 改为 `'a'`——`'a'` 代表 Append（追加），意思是一次又一次地添加到末尾、末尾、末尾。

```python
name = input("What's your name? ")
file = open("names.txt", "a") # 注意模式改为 'a'
file.write(name)
file.close()
```

现在让我重新运行 `python names.py`，回车。我还是从 Hermione 开始，因为我是新创建的文件。注意，如果我现在执行 `code names.txt`，回车，我们确实看到 Hermione 又回来了。所以移除文件后，即使我用了追加模式，它也确实被重新创建了，这很好。

但现在让我们看看当我回到终端，再次运行 `python names.py` 时会发生什么——这次输入 Harry。让我再运行一次——这次输入 Ron。所以希望这次，在那个第二个标签页 `names.txt` 里，我现在应该能看到他们三个了。但是，但是，但是，这看起来不太理想。

`HermioneHarryRon`

我显然做错了什么？尽管三个名字都在那里，但除非你知道每个名字在哪里结束、在哪里开始，否则要读回它们并不容易。

**问：** （观众提问）英文格式不正确。它是连接（concatenating）它们了。

**答：** 是的，它看起来像是在连接。但严格来说，它只是在向文件追加——首先是 Hermione，然后是 Harry，然后是 Ron。效果是将它们背靠背地组合起来，但它本身并不是连接。它真的只是追加。

让我们听听另一个想法。我到底做错了什么？或者等价地，我该如何修复？如果每个名字之间有某种间隔，以便我们能更清晰地阅读它们，那就好了。

**问：** （观众提问）你好。我们应该在写入新名字之前添加一个新行（new line）。

**答：** 很好。我们需要自己添加一个新行。回想一下，`print` 默认总是自动输出一个 `\n` 的行结束符，除非我们用名为 `end` 的命名参数覆盖它，但 `write` 不会这样做。`write` 完全按字面意思来。如果你说 `write Hermione`，那就是 H 到 e。如果你说 `write Harry`，你得到 H 到 y。你不会自动获得任何额外的换行符。所以，如果你想在每个名字的末尾都有一个换行符，我们必须手动完成。

那么，让我再次关闭 `names.txt`，并移除当前文件。让我回到我的代码。我可以用很多方式修复它，但我准备这样做。我将写入一个包含 `name` 和末尾 `\n` 的 f-string。我们可以用不同的方式来做。我们可以手动打印换行符或使用其他技术，但我准备使用我习惯的 f-string，一次性打印名字和换行符。

```python
name = input("What's your name? ")
file = open("names.txt", "a")
file.write(f"{name}\n") # 添加换行符
file.close()
```

我现在到终端窗口，再次运行 `python names.py`，回车。输入 Hermione。我再运行一次，输入 Harry。我再运行一次，这次输入 Ron。现在我运行 `code names.txt` 并打开那个文件。现在看起来文件干净多了。确实，每个名字都在自己的行上，并且还有一个行结束符，确保我们可以将一个名字与另一个区分开。

现在，如果我在编写代码，我敢打赌我可以通过查看大小写字母的差异来解析（也就是读取）之前那个连在一起的文件。但这很快就会变得混乱。一般来说，当长期在文件中存储数据时，你应该以某种清晰的方式来做，比如一次一个名字，并且用换行符分隔。

## 四、 使用 `with` 语句管理文件 (推荐)

好，现在回到这里，我建议这个代码现在工作正常了，但我们可以设计得更好一点。事实证明，在编写代码时，太容易有时会忘记关闭文件。有时这不一定是大问题。但有时它可能引发问题。文件可能会损坏、被意外删除或类似情况，这取决于你代码中发生了什么。

事实证明，如果你采用另一种方法，你就不一定需要自己调用 `close()` 了。在处理文件时，更 Pythonic 的做法是引入这个叫做 `with` 的关键字，它允许你指定，在这个上下文中，我希望你打开并**自动关闭**某个文件。

那么我们如何使用 `with` 呢？它看起来很简单。回到我的代码，我已经删除了 `close` 那行。我现在只需要这样写：

```python
name = input("What's your name? ")
with open("names.txt", "a") as file:
    file.write(f"{name}\n")
# 注意没有 file.close() 了
```

我不再写 `file = open(...)`，而是写 `with open(...)`，然后是和以前一样的参数，有点奇怪的是，我把变量放在了行尾。为什么？这只是这种写法的规定。你说 `with`，调用相关的函数，然后你说 `as` 并指定应该被赋予 `open` 返回值的变量名。然后我缩进下面的行，这样写入名字的那行代码现在就在这个 `with` 语句的上下文中了。这就确保了，如果我在这文件下面有更多不再缩进的代码，一旦第 4 行（现在是第 3 行）执行完毕，文件就会被自动关闭。

所以，这并没有改变刚才发生的事情，但它确实为我们自动化了至少关闭文件的过程，只是为了确保我不会忘记，并且不会出什么问题。

## 五、 文件读取操作

但是，假设现在我想从文件中读取这些名字。到目前为止，我所做的只是编写将名字写入文件的代码。但现在让我们假设，我们已经在文件中有所有这些名字了。而且，我们再添加一个吧。运行 `python names.py`，把 Draco 也加进去。

现在我们有了所有这四个名字，我们该如何读回它们呢？

我建议我们现在修改 `names.py`（或者我们可以创建另一个程序，但我将继续使用同一个名字以便我们专注于此）。现在我将编写读取现有文件的代码，这个文件包含 Hermione、Harry、Ron 和 Draco。

我该怎么做呢？思路是类似的。这次我将以 `with open` 开始，第一个参数是我想打开的文件名，和以前一样。

```python
with open("names.txt", "r") as file:
    # ... 读取操作 ...
```

我这次是以**读取模式**打开它——`'r'`。读取文件仅仅意味着加载它，而不是保存它。我将把返回值命名为 `file`。

现在我准备这样做。有很多方法可以做到，但一次性读取所有行的一种方法是：

```python
with open("names.txt", "r") as file:
    lines = file.readlines()
```

我声明一个名为 `lines` 的变量。我访问那个文件并调用一个随之而来的函数或方法，叫做 `readlines`。如果你阅读 Python 中关于文件 I/O 的文档，你会发现打开的文件带有一个特殊的方法，其作用就是读取文件中的所有行并将它们作为**列表**返回给我。

所以第 2 行（现在是第 2 行）所做的就是读取那个文件中的所有行，并将它们存储在一个名为 `lines` 的变量中。

现在，假设我想遍历所有这些行并打印出每个名字。

```python
with open("names.txt", "r") as file:
    lines = file.readlines()

for line in lines:
    print(f"Hello, {line}")
```

这是一个标准的 Python for 循环。`lines` 是一个列表。`line` 是将自动设置为其中每一行的变量。我打印出 "Hello," 然后是 `line` 本身。

好了，让我去终端窗口，现在运行 `python names.py`——我没有删除 `names.txt`，所以它仍然包含所有四个名字——然后回车。

```
Hello, Hermione

Hello, Harry

Hello, Ron

Hello, Draco

```

嗯，还不错，但这里有点难看。发生了什么？当我运行 `names.py` 时，它向 Hermione、Harry、Ron、Draco 问好。但现在行与行之间有了这些空隙。是什么解释了这个现象？至少，它看起来很难看。

**问：** （观众提问）这是因为在文本文件中，这些名字之间有换行符（newline symbols），而 `print` 总是在末尾添加另一个换行符。所以你两次使用了相同的符号。

**答：** 非常完美。这是一个很好的 bug 示例，程序中的一个错误。但如果你只考虑那些基本原理，比如我使用的每行代码是如何工作的？你应该能够推理出来，就像 Ripal 那样说，好吧，其中一个换行符来自文件中每个名字后面。然后，当然了，`print`，在这么多周之后，仍然免费为我们提供了那个额外的换行符。

所以有几种可能的解决方案。我当然可以这样做，这是我们过去做过的：

```python
# ... (读取 lines) ...
for line in lines:
    print(f"Hello, {line}", end="") # 传递 end="" 给 print
```

这没问题。但我认为稍微好一点的做法可能是这样做，从行的末尾**剥离**掉（strip off）实际的换行符本身：

```python
# ... (读取 lines) ...
for line in lines:
    print(f"Hello, {line.rstrip()}") # 使用 rstrip()
```

这样一来，`print` 就负责打印所有内容，包括人名和它自己添加的新行。而你只是剥离掉了文件中真正只是实现细节的东西。我们选择在我的文本文件中使用换行符来分隔一个名字和另一个名字。所以可以说，从设计的角度来看，剥离掉它，然后让 `print` 打印出真正只是名字的内容，会更干净一些。但这最终是一个设计决策。效果将完全相同。

好，如果我准备打开这个文件，读取所有行，然后遍历所有这些行并打印每一行，我实际上可以把这些合并成一件事。因为现在我做了两倍的工作。我读取所有行，然后我遍历所有行，只是为了打印它们中的每一个。

在 Python 中，对于文件，你实际上可以这样做。我准备擦除几乎所有这些行，只保留顶部的 `with` 语句。在这个 `with` 语句内部，我将这样写：

```python
with open("names.txt") as file: # 'r' 是默认模式，可以省略
    for line in file:
        print(f"Hello, {line.rstrip()}")
```

我将采取剥离行尾的方法。但请注意这有多么优雅（可以说是）。我在第 1 行打开了文件。如果我想遍历文件中的每一行，我不必非常明确地读取所有行，然后遍历所有行。我可以将这合并成一个思路。在 Python 中，你可以简单地说 `for line in file`，这将产生一个 for 循环的效果，它会逐一遍历文件中的每一行，并在每次迭代时，将这个变量 `line` 的值更新为 Hermione，然后是 Harry，然后是 Ron，然后是 Draco。

所以，这再次是 Python 吸引人的方面之一，它的读起来很像英语——`for line in file, print this`。这样写更紧凑一些。

## 六、 读取文件并排序

但是，如果我不想要完全是这种行为呢？因为注意，如果我现在运行 `python names.py`，结果是正确的。我看到了每个名字和每个 "hello"，并且它们之间没有额外的空格。但只是为了找点茬，我真的希望我们能对这些 "hello" 进行排序。我真的希望先看到 Draco，然后是 Harry，然后是 Hermione，然后是 Ron，不管他们在文件中出现的顺序如何。

所以我当然可以进入文件并手动更改文件。但如果那个文件会根据谁在程序中输入他们的名字而随时间变化，那真的不是一个好解决方案。在代码中，我应该能够加载文件，不管它看起来是什么样子，并一次性对它进行排序。

现在，这就是**不**做我刚才所做的事情的一个原因。我不能遍历文件中的每一行并打印它，同时又预先对所有内容进行排序。逻辑上，如果我一次只看一行并打印出来，那就太晚了，无法排序。我真的需要先读取所有行（不打印它们），对它们进行排序，然后再打印它们。所以我们必须退一步，才能添加这个新功能。

我该怎么做呢？嗯，让我结合一些之前的想法。

```python
names = [] # 1. 创建一个空列表来收集名字
with open("names.txt") as file:
    for line in file:
        names.append(line.rstrip()) # 2. 读取每一行，去除换行符，添加到列表

# 3. 文件读取完毕，现在对列表排序并打印
for name in sorted(names):
    print(f"Hello, {name}")
```

让我重新梳理一下。我先创建一个空列表 `names`，这样我就有地方积累所有这些行。然后我打开文件 `names.txt`。注意，如果你是为了读取文件而打开它，你不需要指定 `'r'`。那是隐含的默认值。所以你可以通过只说 `open("names.txt")` 来简化代码。你将能够读取文件但不能写入。我给自己一个变量 `file`。我以同样的方式迭代文件，`for line in file`。但这次我不打印每一行，而是将当前行（剥离掉末尾换行符后）追加到我的 `names` 列表中。这是向内存中的列表追加，而不是向文件本身追加。我这样做是为了把所有学生的名字都添加到这个列表中。

现在我可以使用之前熟悉的技术了。我退出这个 `with` 语句，因为现在我已经读完了整个文件。所以当我对文件中的每一行重复执行第 4 行和第 5 行（现在是第 3 行和第 4 行）后，我就处理完了文件。它可以关闭了。我现在在这个列表变量 `names` 中拥有了所有学生的名字。让我这样做：对于 `sorted(names)` 中的每个 `name`（使用 Python 的 `sorted` 函数），打印出 f-string "Hello, [name]"。

那么我现在做了什么？我在开始时创建了一个列表，只是为了有个地方收集我的数据。然后，在第 3 行到第 4 行，我从上到下迭代文件，一次读取一行，剥离掉换行符，并将纯粹的学生名字添加到这个列表中。我这样做的原因是为了在第 7 行（现在是第 6 行），我可以对所有这些名字进行排序（既然它们现在都在内存中了），并按顺序打印它们。我需要先将它们全部加载到内存中才能排序。否则，我会过早地打印它们，Draco 就会排在最后而不是最前。

所以，让我在终端窗口运行 `python names.py`，回车。好了。同样是四个 "hello" 的列表，但现在它们是排序的了。

这是一种非常常见的技术。当处理文件和更广泛的信息时，如果你想以某种方式更改数据，比如排序，那么在程序顶部创建某种变量（如列表），向其添加或追加信息以将其收集到一个地方，然后对该集合（列表）执行一些有趣的操作，这正是我在这里所做的。

（旁注：其实如果只是想排序文件内容并打印，可以更简洁：

```python
# 更简洁但灵活性较低的方式
# with open("names.txt") as file:
#     for line in sorted(file): # 直接对文件句柄排序
#         print(f"Hello, {line.rstrip()}")
```

这个版本也能得到相同的结果，但代码更紧凑。不过为了讨论方便，我们假设我们确实可能想在迭代数据时对其进行一些更改，比如强制转大写或小写等，所以我们保留了先收集到列表再处理的版本。）

让我暂停一下，看看现在关于文件 I/O 的读取、写入，或者现在将所有这些值累积到某个列表中的操作，是否有任何问题。

**问：** （观众提问）嗨。有没有办法对文件进行排序——如果你想按字母从 A 到 Z 排序，有没有办法把它反转成从 Z 到 A？你可以在末尾添加一个小扩展来做到吗？还是你必须创建一个新函数？

**答：** （主持人提问）你是说反转文件的内容吗？

**问：** （观众提问）是的，所以如果你不想按升序从 A 到 Z 排序，而是想按降序排序，有没有相应的扩展？

**答：** 确实有。而且，一如既往，文档是你的朋友。所以，如果目标不是按默认的字母顺序排序，而是按反向字母顺序排序，你可以查看 Python 的官方文档。你会看到 `sorted` 函数接受第一个参数，通常称为可迭代对象（iterable）。可迭代意味着你可以迭代它，也就是你可以一次一个地循环遍历它。文档中还会提到你可以指定一个 `key`（如何排序，稍后详述），但最后一个命名参数是 `reverse`。根据文档，它默认为 `False`。默认情况下不会反转。但如果我们把它改成 `True`，我敢打赌我们可以做到。

所以，回到 VS Code，就这样做。除了这个可迭代对象（也就是我的 `names` 列表）之外，我再向 `sorted` 传递第二个参数。可迭代对象再次强调，意味着它可以被循环遍历。我传入 `reverse=True`，从而覆盖了默认值 `False`。

```python
# ... (前面的代码) ...
for name in sorted(names, reverse=True): # 添加 reverse=True
    print(f"Hello, {name}")
```

现在让我运行 `python names.py`。现在 Ron 在最上面，Draco 在最下面。所以，同样地，以后每当你有类似的问题时，考虑一下：文档是怎么说的？看看那里是否有想法的萌芽，因为很可能，如果你遇到了某个问题，在你之前的某个程序员也遇到过同样的问题。

还有其他想法吗？

**问：** （观众提问）我们能限制名字的数量吗？第二个问题，我们能在列表中找到一个特定的名字吗？

**答：** 非常好的问题。我们能限制文件中的名字数量吗？我们能找到一个特定的名字吗？绝对可以。如果我们编写代码，比如说，我们可以先打开文件，计算里面已经有多少行，然后如果已经太多了，我们可以用 `sys.exit` 或其他消息退出，告诉用户“抱歉，班级已满”。至于找到特定的人，绝对可以。你可以想象打开文件，用 for 循环一遍又一遍地迭代它，然后添加一个条件判断。比如，`if current_line.rstrip() == "Harry":`，那么我们就找到了那个选中的人。然后你可以打印类似的信息。所以你绝对可以将这些想法与之前的想法（如条件判断）结合起来，来回答这些相同的问题。

关于文件 I/O 还有其他问题吗？

**问：** （观众提问）我刚想到这个函数，比如 `readlines`。它看起来是用这个特殊字符 `\`（应为 `\n`）来分隔所有行的。但看起来我们并不需要那个字符，而且我们总是把它剥离掉 (`strip`)。这看起来像是某种糟糕的设计或函数。为什么我们不直接在这个函数内部就把它剥离掉呢？

**答：** 非常好的问题。到目前为止，在我的例子中，我们使用 `rstrip` 来从行的末尾剥离所有这些空白字符。你可能不想这样做。在这种情况下，我剥离掉它是因为我知道这些行中的每一行都不是某种通用的文本行。每一行实际上代表一个我自己放在那里的名字。我使用换行符只是为了将一个值与另一个值分开。在其他情况下，你很可能希望保留那个行结束符，因为它可能是一长串文本、一个段落或类似的东西，你想让它与其他内容区分开。但这只是一种约定。我们必须用某种东西，大概是，来分隔一块文本和另一块文本。Python 中确实有其他函数实际上会为你处理掉空白字符的移除。不过，`readlines` 确实是按字面意思做的。它读取所有行，保持原样。

## 七、 处理结构化数据：CSV 文件

好，允许我把注意力转回到我们刚才停下的地方，也就是 `names.txt`，并提出，看起来我们有能力相当直接地存储这些名字中的每一个。

但是，如果我们想跟踪其他信息呢？假设我们想存储信息，包括学生的名字和他们在霍格沃茨的学院（House），无论是格兰芬多（Gryffindor）、斯莱特林（Slytherin）还是其他的。

那么，我们该把这些信息放在哪里呢？Hermione 在格兰芬多，所以我们可以在我们的文本文件中这样做：

```
Hermione
Gryffindor
Harry
Gryffindor
Ron
Gryffindor
Draco
Slytherin
```

但我担心——我现在担心我们是在混淆苹果和橙子，可以说是。有些行是名字。有些行是学院。所以这可能不是最好的设计，至少因为它令人困惑，或者说它有歧义。

所以也许我们可以采用一种约定。事实上，这正是很多程序员所做的。他们不把这个文件叫做 `names.txt`，而是，让我创建一个新文件，叫做 `names.csv`。CSV 代表**逗号分隔值 (Comma-Separated Values)**。这是一种非常普遍的约定，用来在同一个文件中存储多个相关的信息片段。

为了做到这一点，我将用逗号来分隔这些类型的数据，而不是用另一个换行符。我将让每个学生占据自己的一行，但我将使用逗号来分隔关于每个学生的信息。

```csv
Hermione,Gryffindor
Harry,Gryffindor
Ron,Gryffindor
Draco,Slytherin
```

所以现在我们有点像有了一个二维文件，如果你愿意这么说的话。逐行来看，我们有我们的学生。但如果你把这些逗号想象成代表一列，即使由于这些名字的长度不同它不是完全笔直的，有点锯齿状。你可以把这些逗号看作代表一列。

事实证明，这些 CSV 文件在你使用像 Microsoft Excel、Apple Numbers 或 Google Sheets 这样的软件时非常常用，并且你想导出数据以 CSV 文件形式与他人共享。反过来，如果你想将 CSV 文件导入到你偏爱的电子表格软件（如 Excel、Numbers 或 Google Sheets）中，你也可以这样做。所以 CSV 是一种非常常见、非常简单的文本格式，它只是用逗号分隔值，并最终用换行符分隔不同类型的记录（行）。

让我运行 `code students.csv` 来创建一个全新的、初始为空的文件。我们将向其中添加相同的名字，但也添加一些其他信息。

那么，如果我现在有了这个新文件 `students.csv`，里面可以说有一列名字和一列学院，我该如何修改我的代码来读取不仅仅是那些名字，还要读取那些名字和学院，以便它们不在同一行上——我们能以某种方式分别访问这两种类型的值？

好，让我创建一个新程序，叫做 `students.py`。在这个程序中，让我们来读取，不是一个普通的文本文件，而是一种特定类型的文本文件，一个 CSV，一个逗号分隔值文件。

为此，我将使用与之前类似的代码。

```python
students = [] # 我们可能需要一个列表来存储处理后的数据
with open("students.csv") as file:
    for line in file:
        # 如何处理每一行 'line' (例如 "Hermione,Gryffindor\n")？
```

现在我得稍微聪明一点了。让我回到 `students.csv`，看看这个文件。看起来在我的循环中，每次迭代，我都会得到一整行的文本。我不会自动只得到 Hermione 或只得到 Gryffindor。回想一下，循环将给我每一整行的文本。

所以，逻辑上，你会建议在一个读取一整行文本的 for 循环内部，我们该做什么，如果我们现在想访问像 Hermione 和 Gryffindor，Harry 和 Gryffindor 这样的**单个值**？我们该如何处理一行文本并访问那些单个的值，你认为呢？凭直觉，即使你不确定函数的名字会是什么。

**问：** （观众提问）你可以像使用字典那样访问它，比如使用键和值。

**答：** 理想情况下，我们会用键和值来访问它。但在故事的这个阶段，我们只有这个循环，这个循环每次给我一行文本。现在我是程序员。我必须解决这个问题。目前还没有涉及到字典。

还有其他的建议吗？

**问：** （观众提问）所以你可以根据逗号以某种方式分割（split）这两个词？

**答：** 是的，即使你不太确定哪个函数会做这个，直觉上，你想把这一整行文本——`Hermione,Gryffindor`，`Harry,Gryffindor` 等等——分割成两部分，如果你愿意这么说的话。而且非常棒的是，我们将使用的函数实际上就叫做 `split`，它可以根据任何字符进行分割，但你可以告诉它使用哪个字符。

所以，我回到 `students.py`，在这个循环内部，我准备这样做。我取当前的行 `line`。我像往常一样，使用 `rstrip()` 去除末尾的空白。然后，无论结果是什么，我现在调用 `split(',')`。

```python
with open("students.csv") as file:
    for line in file:
        row = line.rstrip().split(',') # 分割行
        # 'row' 现在是一个列表，例如 ['Hermione', 'Gryffindor']
```

`split` 函数（或方法）是字符串自带的。Python 中的任何 `str` 都有这个内置方法。如果你传入一个参数，比如逗号，这个 `split` 函数就会通过一次又一次地查找那个字符，将当前字符串分割成 1、2、3 或更多部分。最终，`split` 将返回给我们一个包含所有逗号左边和右边单个部分的**列表**。

所以我可以给自己一个变量，叫做 `row`。这是一种常见的范式。当你知道你正在迭代一个文件，特别是 CSV 文件时，通常会将它的每一行看作是一个**行（row）**，并将其中由逗号分隔的每个值看作是**列（columns）**，可以说是。所以我故意将我的变量命名为 `row`，只是为了与那个约定保持一致。

现在我想打印什么呢？嗯，我准备这样说。打印，比如下面的内容，一个 f-string：

```python
with open("students.csv") as file:
    for line in file:
        row = line.rstrip().split(',')
        print(f"{row[0]} is in {row[1]}") # 使用索引访问列表元素
```

我如何访问那一行的第一个东西？嗯，`row` 将有多少部分？两个，因为如果我按逗号分割，并且每行只有一个逗号，那将给我一个左边部分和一个右边部分，比如 Hermione 和 Gryffindor，Harry 和 Gryffindor。当我有一个像 `row` 这样的列表时，我如何访问单个值？我可以通过索引来做。我说 `row[0]`。这将访问列表的第一个元素，希望是学生的名字。然后，在那之后，我说 "is in"，然后我这里有另一个花括号，用于 `row[1]`。然后我关闭整个引号。

乍一看可能有点神秘。但大部分只是 f-string 语法，用花括号来插入值。我插入的是什么值？嗯，`row`，再次强调，是一个列表，它大概有两个元素——一个里面是 Hermione，另一个里面是 Gryffindor，等等。所以 `[0]` 是第一个元素，因为，记住，在 Python 中我们从 0 开始索引。而 `[1]` 将是第二个元素。

好，现在让我运行这个看看会发生什么——`python students.py`，回车。我们看到 "Hermione is in Gryffindor"。 "Harry is in Gryffindor"。 "Ron is in Gryffindor"。 "Draco is in Slytherin"。

所以我们现在从头开始实现了我们自己的代码，它实际上解析了（也就是读取并解释了）一个 CSV 文件。

现在，让我暂停一下看看是否有任何问题。但我们稍后会让这个更容易阅读。关于我们刚才通过逗号分割所做的操作，有任何问题吗？

**问：** （观众提问）我的问题是，我们能随时编辑代码的任何一行吗？还是我们唯一的选择是追加行？或者说，假设我们想，比如说，把 Harry 的学院改成斯莱特林或其他学院。

**答：** 是的，非常好的问题。如果你想在 Python 中更改文件中的某一行，而不仅仅是追加到末尾，该怎么办？你必须自己实现那个逻辑。例如，你可以想象现在打开文件并读入所有内容，然后可能迭代每一行。一旦你看到当前名字等于 `Harry`，你也许可以把他的学院改成 Slytherin。然后，就得由你来把所有这些更改写回文件。所以在那种情况下，最简单的方式可能是，先读取文件一次让它关闭。然后再打开它，但是以写入模式打开，并**重写整个文件**。进入文件并只更改其中一部分通常是不可能或不容易做到的，尽管你可以做到。更容易的做法实际上是读取整个文件，在内存中进行更改，然后写出整个文件。但是对于那些可能非常慢的大文件，你可以比这更聪明。

好，我现在建议我们稍微清理一下代码，因为我实际上觉得 `row[0]`, `row[1]` 这样读起来有点神秘——我认为目前写得不是很好。但事实证明，当你有一个像 `row` 这样的列表变量时，你不必把所有这些变量都扔到一个列表里。你实际上可以一次性**解包 (unpack)** 整个序列。也就是说，如果你知道像 `split` 这样的函数返回一个列表，但你预先知道它将返回列表中的两个值，第一个和第二个，你就不必把它们都扔到一个本身是列表的变量中。你可以实际上同时将它们解包到两个变量中，像这样做 `name, house = ...`。

```python
with open("students.csv") as file:
    for line in file:
        # row = line.rstrip().split(',') # 不再需要这一行
        name, house = line.rstrip().split(',') # 直接解包
        print(f"{name} is in {house}") # 现在使用变量名
```

所以这是一个很好的 Python 技术，不仅可以创建，而且可以自动地、并行地一次性赋给两个变量，而不是只有一个。这将产生把名字（Hermione）放在左边变量 `name` 中的效果，并把学院（Gryffindor）放在右边变量 `house` 中的效果。我们现在不再有 `row` 了。我们现在可以通过直接说 `name` 和 `house` 来让我们的代码更具可读性。只是稍微更可读一点，即使功能上代码现在完全相同。

好了，这个现在可以工作了。我通过再次运行来确认一下——`python students.py`，回车。我们看到文本如预期。

但是，假设为了讨论起见，我想对这个输出列表进行排序。我想再次先向 Draco 问好，然后是 Harry，然后是 Hermione，然后是 Ron。我该怎么做呢？

嗯，让我们从之前的例子中获取一些灵感，那时我们只处理名字，现在用这些完整的短语来做。“某某在某学院”。

好，让我这样做。我准备从头开始，给自己一个名为 `students` 的列表，初始为空列表。

```python
students = []
with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(',')
        # 不要立即打印，先收集起来
        sentence = f"{name} is in {house}"
        students.append(sentence) # 注意：这里添加的是构造好的字符串

# 读取完毕后排序并打印
for student_sentence in sorted(students):
    print(student_sentence)
```

我现在运行 `python students.py`，然后回车。我想我们会看到，确实，Draco 现在是第一个。Harry 是第二个。Hermione 是第三个。Ron 是第四个。

但这可以说有点草率，对吧？我构造了这些句子，然后对它们进行排序，这似乎有点取巧。而且即使我技术上想按名字排序，我实际上是按这些完整的英语句子排序。所以这没有错。它达到了预期的结果，但这并不是真正的良好设计，因为我只是碰巧幸运，英语是从左到右阅读的。因此，当我打印这个时，它能正确排序。

更好的做法，真的，是想出一种**按学生的名字**排序的技术，而不是按我在这里第 6 行（现在可能是第 5 行左右）构造的某个英语句子排序。

要实现这一点，我需要暂时让我的生活变得更复杂一些。我需要先收集关于每个学生的信息，然后再去组装那个句子。所以，我建议我们这样做。让我撤销最后几行代码，这样我们当前有两个变量，`name` 和 `house`，它们分别包含名字和学生的学院。我们仍然有我们的全局变量 `students`。但让我这样做。

回想一下，Python 支持**字典 (dictionaries)**。字典只是键和值的集合。所以你可以把某样东西和另一样东西关联起来，比如，把 `name` 和 Hermione 关联起来，把 `house` 和 Gryffindor 关联起来。这确实是一个字典。

所以让我这样做。让我暂时创建一个字典来存储名字和学院的这种关联。

```python
students = []
with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(',')
        student = {"name": name, "house": house} # 直接创建字典
        students.append(student) # 将字典添加到列表中

# 现在 'students' 是一个字典的列表:
# [{'name': 'Hermione', 'house': 'Gryffindor'}, {'name': 'Harry', 'house': 'Gryffindor'}, ...]

# 稍后我们会处理排序和打印
```

回想一下，你可以用方括号 `[]` 创建一个空列表，你可以用花括号 `{}` 创建一个空字典。或者，如果你像我刚才那样，习惯于创建一个空字典，然后立刻放入两个键 `name` 和 `house`，以及各自的两个值 `name` 和 `house`，你实际上可以一次性完成所有这些。

让我展示一个稍微不同的语法。我可以这样做。给我一个叫做 `student` 的变量，让我在右边使用花括号。但不要让它们为空，让我们现在就定义那些键和那些值。

```python
# (在循环内部)
student = {"name": name, "house": house}
```

这在一行中达到了与之前创建空字典再分别赋值完全相同的效果。它创建了一个新的非空字典，包含一个 `name` 键，其值是学生的名字，以及一个 `house` 键，其值是学生的学院。

我为什么要这样做？我承认我的代码变得更复杂了。代码行数更多了，但我现在收集了我拥有的关于学生的所有信息，同时仍然跟踪着哪个是名字，哪个是学院。与此同时，`students` 列表包含了所有学生的名字和学院（以字典形式组织在一起）。

我为什么要这样做？嗯，让我暂时做点简单的事情。

```python
# (在文件读取循环之后)
for student in students: # 'student' 现在是一个字典
    print(f"{student['name']} is in {student['house']}")
```

现在请注意一个细节。在这个 f-string 内部，我像往常一样使用我的花括号。我在那些花括号内部使用变量名，也像往常一样。然后我使用的不是 `[0]` 或 `[1]`，因为这些现在是字典，不是列表。但是我为什么用**单引号**来包围 `house` 和 `name`？

**问：** （观众提问）是的，因为你在第 12 行（现在可能是第 10 行左右）用了双引号。所以你必须告诉 Python 进行区分。

**答：** 完全正确。因为我已经在外层 f-string 使用了双引号，如果我想在内部给任何字符串加上引号——我确实需要为字典这样做，因为，回想一下，当你索引到字典时，你不用像列表那样的数字——0, 1, 2 往后——而是使用需要加引号的字符串。但如果你已经用了双引号，最简单的就是在内部使用单引号，这样 Python 就不会混淆哪个引号与哪个匹配。

所以，目前，当我运行这个程序时，它会打印出那些问候语。但它们还没有排序。事实上，我现在拥有的是一个**字典的列表**，而且还没有任何东西被排序。

## 九、 排序复杂数据结构 (列表中的字典)

那么，我该怎么做才能进一步改进呢？嗯，我们现在需要某种机制来对这些学生进行排序。但不幸的是，你不能这样做：

```python
# for student in sorted(students): # 这会失败！
#     ...
```

我们现在不能对所有学生进行排序，因为那些 `student` 不再是像以前那样的名字（字符串）了。它们也不是像以前那样的句子了。每个 `student` 都是一个**字典**，而如何对列表中的字典进行排序并不明显。

所以，理想情况下，我们想要什么呢？如果在第 9 行（现在可能是第 7 行）执行时，我们有一个包含所有这些学生的列表，并且该列表内部每个学生对应一个字典，并且每个字典有两个键，`name` 和 `house`，如果在代码中有办法告诉 Python，“根据每个字典中的这个**键**来排序这个列表”，那该多好呢？因为这将使我们能够按名字排序，甚至按学院排序，甚至按我们添加到该文件中的任何其他字段排序。

事实证明，我们可以这样做。我们可以告诉 `sorted` 函数，不仅仅是反转与否。它接受另一个命名参数叫做 `key`，你可以用它来指定应该使用哪个键来排序某个字典列表。

我建议我们这样做。我将首先定义一个函数——暂时先这样——叫做 `get_name`。这个函数的作用，给定一个 `student`（字典），就是简单地从那个特定的字典中返回学生的名字。

```python
def get_name(student):
  """给定一个学生字典，返回其名字"""
  return student["name"]

# ... (读取 students 列表的代码) ...

# 现在使用 key 参数来排序
for student in sorted(students, key=get_name):
    print(f"{student['name']} is in {student['house']}")
```

所以如果 `student` 是一个字典，这个函数将返回字面上的学生名字，仅此而已。这就是这个函数存在的唯一目的。

我现在想做什么？既然我有一个函数，给定一个学生就能返回给我学生的名字，我就可以这样做。我可以改变 `sorted` 函数，说，“使用一个等于 `get_name` 返回值的 `key`”。

这现在是 Python 的一个特性。Python 允许你将函数作为参数传递给其他函数。所以 `get_name` 是一个函数。`sorted` 是一个函数。我正在将 `get_name` 作为那个 `key` 参数的值传递给 `sorted`。

现在，我为什么要这样做？嗯，如果你想想 `get_name` 函数，它只是一段代码块，用于获取学生的名字。这很方便，因为这正是 `sorted` 需要的能力。当给定一个学生列表，其中每个都是字典时，`sorted` 需要知道，我该如何获取学生的名字？以便为你进行字母排序。Python 的作者们并不知道我们会在这个课堂上创建学生，所以他们不可能预先编写专门针对名为 `student` 的字段进行排序的代码，更不用说名为 `name` 或 `house` 的字段了。

那么他们做了什么？他们反而在 `sorted` 函数中内置了这个名为 `key` 的参数，允许我们，在这么多年后，告诉他们的函数 `sorted` 如何对这个字典列表进行排序。

现在看看会发生什么。如果我运行 `python students.py` 并回车，我现在得到了一个排序后的输出列表。为什么？因为现在那个字典列表已经全部按学生的名字排序了。

我还可以进一步这样做。如果像之前一样，我们想通过说 `reverse=True` 来反转整个事情，我们也可以这样做。

```python
for student in sorted(students, key=get_name, reverse=True):
    # ...
```

让我重新运行 `python students.py`，回车。现在它被反转了。现在是 Ron，然后是 Hermione，Harry，和 Draco。

但我们也可以做些不同的事情。比如说，如果我想按学院名称反向排序呢？我可以这样做。我可以把这个函数从 `get_name` 改为 `get_house`。我可以把上面的实现也改为 `get_house`。并且我返回的不是学生的名字，而是学生的学院。

```python
def get_house(student):
  """给定一个学生字典，返回其学院"""
  return student["house"]

# ... (读取 students 列表的代码) ...

# 按学院反向排序
for student in sorted(students, key=get_house, reverse=True):
    print(f"{student['name']} is in {student['house']}")
```

所以现在注意，如果我运行 `python students.py`，回车，注意现在它是按学院反向排序的。Slytherin 在前，然后是 Gryffindor。如果我去掉 `reverse` 但保留 `get_house` 并重新运行这个程序，现在它是按学院排序的。Gryffindor 在前，Slytherin 在后。

现在这样做的好处是，因为我使用了这个字典列表，并将学生的数据整合在一起，直到最后一刻我才最终进行打印，我现在对信息本身有了完全的控制权，我可以按这个或那个排序。我不必像第一次那样相当取巧地预先构造那些句子。

好了，刚才讲了很多。让我在这里暂停一下，看看是否有问题。

**问：** （观众提问）所以当我们排序文件时，每次都应该使用循环，或者文本字典，或者任何类型的列表吗？我们能仅仅通过排序来排序，而不是循环或任何类型的东西吗？

**答：** 好问题。简短的回答是，仅用 Python 本身，你是程序员。你需要进行排序。借助库和其他技术，绝对可以。你可以更多地自动化这些操作，因为其他人已经写了那些代码。我们目前所做的是自己从头开始做所有事情。但绝对地，通过其他函数或库，其中一些可以更容易地完成。

关于这种技术还有其他问题吗？

**问：** （观众提问）如果 `key` 等于函数的返回值，它能等于只是一个变量或一个值吗？

**答：** 嗯，是的。它应该等于一个值。我应该澄清一下，实际上，因为这可能不明显。所以，当你将像 `get_name` 或 `get_house` 这样的**函数**作为 `key` 的值传递给 `sorted` 函数时，`sorted` 函数会**自动为你**对列表中的每个字典**调用**那个函数。它使用 `get_name` 或 `get_house` 的**返回值**来决定实际应该使用哪些字符串进行比较，以决定哪个在字母顺序上是正确的。所以这个你只按名称传递的函数（你不在末尾传递括号），是由 `sorted` 函数调用的，以便为你弄清楚如何比较这些相同的值。

**问：** （观众提问）我们如何使用嵌套字典？我读到过关于嵌套字典的文章。嵌套字典和列表中的字典有什么区别？我想就是那个。

**答：** 当然。我们正在使用一个**字典的列表**。为什么？因为这些字典中的每一个都代表一个学生。而一个学生有名字和学院，我认为，我们想要保持这种关联。这是一个学生的列表，因为我们有多个学生——在这种情况下是四个。你可以创建一个字典的字典的结构。但我认为，那只是不能解决问题。我现在不需要字典的字典。我现在需要的是一个**键值对的列表**。就是这样。

好，我建议，如果我们回到 `students.py` 这里，并且我们恢复到使用 `get_name` 作为函数的方法，这个函数在这里被使用和定义，并且那个函数返回学生的名字，要清楚的是，`sorted` 函数将使用 `key` 的值——在这种情况下是 `get_name`——在它要排序的列表中的每个字典上**调用**那个函数。而那个函数，`get_name`，返回 `sorted` 实际用来决定事物是按这个顺序（从左到右）还是按那个顺序（从右到左）排列的**字符串**。它根据那个返回值来对这些东西进行字母排序。

所以注意，我在这里调用 `get_name` 函数时**没有**加括号。我只是按它的名字传递它，以便 `sorted` 函数可以为我调用那个 `get_name` 函数。

现在，事实证明，一如既往，如果你定义了某个东西，无论是一个变量还是，在这种情况下，一个函数，然后立即使用它，但再也不需要那个函数的名字，比如 `get_name`，我们实际上可以进一步精简这段代码。我实际上可以这样做。我可以完全去掉 `get_name` 函数，就像我可以去掉一个并非绝对必需的变量一样。

与其给 `key` 传递一个函数的名字，我实际上可以给 `key` 传递所谓的 **`lambda` 函数**，这是一个匿名函数，一个就是没有名字的函数。为什么？因为如果你只在一个地方调用它，你就不需要给它起名字。

在 Python 中，这样做的语法有点奇怪。但如果我写 `key=lambda`，然后是像 `student` 这样的东西，这是我期望这个函数接受的参数名，然后我甚至不输入 Return 键。我只是说，`student['name']`。

```python
# ... (读取 students 列表的代码) ...

# 使用 lambda 函数作为 key
for student in sorted(students, key=lambda student: student["name"]):
    print(f"{student['name']} is in {student['house']}")
```

那么我用我的代码在这里做了什么？我高亮的这部分代码等同于我刚才实现的 `get_name` 函数。语法上确实有点不同。我不用 `def`。我甚至没有给它起像 `get_name` 这样的名字。我反而使用了 Python 中另一个叫做 `lambda` 的关键字，它表示，“嘿，Python，来了一个函数，但它没有名字。它是匿名的。”那个函数接受一个参数。我可以叫它任何我想要的名字。我叫它 `student`。为什么？因为这个作为 `key` 传入的函数会被调用到那个列表中的每一个学生上，每一个字典上。我希望这个匿名函数返回什么？嗯，给定一个 `student`，我想索引到那个字典并访问他们的名字，以便最终返回字符串 Hermione、Harry、Ron 和 Draco。这就是 `sorted` 函数用来决定如何对这些包含其他键（如 `house`）的更大字典进行排序的依据。

所以如果我现在回到我的终端窗口并运行 `python students.py`，它似乎仍然工作得一样，但这可以说是一个稍微更好的设计，因为我没有通过定义某个其他函数并在唯一一个地方调用它来浪费代码行。我已经像是一气呵成地完成了所有事情。

好了，让我在这里暂停一下，看看是否专门有关于 `lambda` 或匿名函数以及这种代码精简的问题。

**问：** （观众提问）我有个问题，比如我们是否可以定义 lambda 两次。

**答：** 你可以使用 lambda 两次。你可以创建任意多个你想要的匿名函数。你通常在像这样的上下文中使用它们，当你想要传递给某个其他函数一个本身不需要名字的函数时。所以你绝对可以在不止一个地方使用它。我只是刚好只有一个用例。

关于 lambda 或匿名函数，还有其他具体问题吗？

**问：** （观众提问）比如说，如果我们的 lambda 需要多于一行呢？

**答：** 当然，如果你的 lambda 函数接受多个参数，那没问题。你可以在参数名 `student` 后面简单地指定逗号分隔的那些参数名，比如 `x` 和 `y` 等等。所以在这里，lambda 看起来与 `def` 有点不同，在于你没有括号，没有关键字 `def`，没有函数名。但最终它们达到了相同的效果。它们匿名地创建了一个函数，并允许你，例如，将其作为某个值传递进去。

## 八、 使用 `csv` 模块处理 CSV 文件 (推荐)

现在让我们把 `students.csv` 改成不包含学生在霍格沃茨的学院，而是他们长大的家。

```csv
name,home
Draco,"Malfoy Manor"
Ron,"The Burrow"
Harry,"Number Four, Privet Drive"
```

Draco，例如，在马尔福庄园（Malfoy Manor）长大。Ron 在陋居（The Burrow）长大。Harry 在女贞路 4 号（Number Four, Privet Drive）长大。而根据互联网，没人知道 Hermione 在哪里长大。电影显然在她长大的地方做了一些自由发挥。所以为此，我们实际上要移除 Hermione，因为她确切的出生地是未知的。所以我们仍然有三个学生。

但如果有人能发现现在潜在的问题，这怎么可能是一件坏事呢？

嗯，让我们试试运行我们自己的代码。回到 `students.py`。我建议我只是改变我的语义，因为我现在考虑的不是霍格沃茨的学院，而是学生自己的家。所以我只是改一些变量。我把 `house` 改成 `home`，这里也是，还有这里。

```python
students = []
with open("students.csv") as file:
    for line in file:
        # 注意：这里的 split(',') 会遇到问题！
        # name, home = line.rstrip().split(',') # 这一行需要修改
        # student = {"name": name, "home": home}
        # students.append(student)
        pass # 暂时跳过处理逻辑

# 假设我们稍后修复读取逻辑...
# def get_name(student):
#   return student["name"]
#
# for student in sorted(students, key=get_name):
#     print(f"{student['name']} is from {student['home']}") # 打印语句也更新
```

我仍然按名字对学生排序，但我要说他们不是来自某个学院，而是来自某个家。所以我只是改变了我的变量名和我的英语语法，最终打印出，例如，“Harry is from Number Four, Privet Drive” 等等。

但让我们看看当我运行这个版本的 `students.py`（修改了 `students.csv` 以包含那些家而不是学院）时会发生什么。回车。

哈，我们的第一个 `ValueError`，就像程序根本不工作一样。可能是什么解释了这个 `ValueError`？它的解释相当神秘地是，“要解包的值太多 (too many values to unpack)”。而出问题的行是涉及 `split` 的这一行。

```python
# 出错的代码行（概念上）：
name, home = line.rstrip().split(',')
```

怎么会，在所有这些程序成功运行之后，第 5 行（现在可能是第 4 行）突然就坏了呢？

**问：** （观众提问）在 `students.csv` 的那一行里，你有三个值。有一行你有三个值...

**答：** 是的，我花了很多时间试图弄清楚每个学生应该来自哪里，这样我们就能给自己制造这个问题。而且很奇妙的是，书的第一句话就是“女贞路 4 号”。所以那个地址里有逗号这个事实是有问题的。为什么？因为你和我很久以前决定就标准化使用逗号——CSV，逗号分隔值——来表示……我们标准化使用逗号是为了界定一个值和另一个值。如果我们在学生的家里有语法上的逗号，我们显然把它和这个特殊符号搞混了。而 `split` 函数现在，仅仅对于 Harry，试图把它分割成三个值，而不仅仅是两个。这就是为什么会有“要解包的值太多”的错误，因为我们只试图赋给两个变量，`name` 和 `home`（之前是 house）。

现在，我们能做什么呢？嗯，我们可以改变我们的方法，例如。一种并非不常见的范式是使用某种不太常见的东西，比如竖线 `|`。所以我可以进去把所有逗号改成竖线。那最终也可能反过来咬我们一口，就是如果我的文件最终某处有竖线，它可能仍然会坏掉。所以也许那不是最好的方法。

我或许可以做类似这样的事情。我可以像过去那样对数据进行转义。也许我可以在任何本身包含逗号的英文字符串周围加上引号。

```csv
name,home
Draco,"Malfoy Manor"
Ron,"The Burrow"
Harry,"Number Four, Privet Drive" # 用引号包围含逗号的字段
```

这没问题。我可以这样做，但那样我的代码 `students.py` 也将不得不改变，因为我现在不能只是天真地按逗号分割了。我将不得不更聪明一点。我将不得不考虑到**只**在那些**不在引号内部**的逗号上进行分割。哦，这很快就变得复杂起来了。

在这一点上，你需要退一步考虑一下，你知道吗，如果我们遇到了这个问题，很可能，在我们之前的许多其他人也遇到过同样的问题。将数据存储在文件中是非常普遍的。专门使用 CSV 文件是非常普遍的。所以你知道吗。为什么我们不看看 Python 中是否有一个现成的**库 (library)** 用来读取和/或写入 CSV 文件呢？与其重新发明轮子，可以说是，让我们看看是否可以通过站在前人的肩膀上——过去的程序员——来编写更好的代码，并实际使用他们的代码来完成 CSV 的读取和写入，这样我们就可以专注于我们关心的我们自己问题的那部分。

所以，让我们建议回到我们的代码，看看我们如何使用 `csv` 库。确实，在 Python 内部，有一个叫做 `csv` 的模块。它的文档在 Python 官方文档的这个 URL。但是有几个函数，如果我们直接开始使用，是相当容易访问的。

我建议我们这样做。回到我的代码。与其重新发明这个轮子，逐行读取文件，按逗号分割，现在还要处理引号、女贞路等等，不如这样做。在我的程序开始时，让我导入 `csv` 模块。

```python
import csv
import sys # 如果需要命令行参数

students = [] # 仍然需要列表来存储结果
```

让我们使用这个别人已经编写好的、处理了所有这些边缘情况（如果你愿意这么说的话）的库。我仍然会给自己一个初始为空的列表，用来存储所有这些学生。但我现在要稍微改变一下我的方法。

当我用 `with` 打开这个文件时，让我在这里稍微改动一下。我现在准备在这里这样说：

```python
with open("students.csv") as file:
    reader = csv.reader(file) # 使用 csv.reader
    for row in reader:
        # 'row' 是一个列表，例如 ['Harry', 'Number Four, Privet Drive']
        # csv.reader 自动处理了引号和逗号
        students.append({"name": row[0], "home": row[1]}) # 假设第一列是 name，第二列是 home
```

事实证明，如果你阅读 `csv` 模块的文档，它带有一个叫做 `reader` 的函数，其作用就是为你读取一个 CSV 文件，并弄清楚逗号在哪里，引号在哪里，所有潜在的边缘情况在哪里，并为你处理它们。你可以覆盖某些默认值或假设，以防你使用的不是逗号而是管道符或其他东西。但默认情况下，我认为它就能工作。

现在，我如何迭代一个 `reader` 而不是原始文件本身呢？几乎是一样的。这个库仍然允许你这样做。对于 `reader` 中的每一行 `row`——所以你现在不是直接迭代文件了。你正在迭代 `reader`，它，再次强调，将处理所有逗号、换行符等的解析。

对于 `reader` 中的每一行 `row`，我准备做什么？嗯，目前，我准备这样做。我准备向我的 `students` 列表追加以下字典：一个字典，它有一个 `name`，其值是当前行的第一列，以及它的 `home`（现在是 home 而不是 house）是该行的第二列。

值得注意的是，对于文件中的每一行，`reader` 确实返回给我一个 `row`。但它返回给我的是一个**列表**形式的 `row`。也就是说，那个列表的第一个元素将是学生的名字，和以前一样。那个列表的第二个元素将是学生的家，和现在一样。但如果我想访问这些元素中的每一个，记住列表是 0 索引的。我们从 0 开始计数，然后是 1，而不是 1 然后是 2。所以如果我想获取学生的名字，我用 `row[0]`。如果我想获取学生的家，我用 `row[1]`。

但是在我的 for 循环中，我们可以像之前那样进行解包。如果我知道 CSV 只会有两列，我甚至可以这样做：

```python
with open("students.csv") as file:
    reader = csv.reader(file)
    for name, home in reader: # 直接解包 reader 返回的列表
        students.append({"name": name, "home": home})
```

现在我不需要使用列表表示法了。我可以一次性解包所有东西，并在这里说 `name`，在这里说 `home`。我代码的其余部分可以保持完全相同，因为我现在在第 8 行（现在可能是第 6 行）做什么？我仍然在构造和以前一样的字典，尽管是为了家而不是学院。我现在是从 `reader` 获取那些值，而不是从文件本身和我使用的 `split` 获取。再次强调，`reader` 将要做的是弄清楚那些逗号在哪里，引号在哪里？并为你解决那个问题。

所以，现在让我到我的终端窗口，运行 `python students.py`，回车。现在我们成功地看到了，而且还是排序后的，Draco 来自 Malfoy Manor。Harry 来自 Number Four, comma, Privet Drive。Ron 来自 The Burrow。

现在关于使用来自那个 `csv` 模块的 `csv.reader` 的这种技术，有什么问题吗？它，再次强调，只是让我们摆脱了自己读取每一行、读取那些逗号并分割的麻烦。

**问：** （观众提问）所以我的问题与过去的事情有关。我认识到你每次都在读取一个文件——好吧，我们假设在这种情况下我们手头已经有 CSV 文件了。有没有可能让一个文件既可读又可写？所以在这种情况下，你可以把这些东西写入文件，但同时，你可以有另一个函数来读取文件并在你进行时对其进行更改？

**答：** 非常好的问题。简短的回答是，是的。然而，历史上，文件的思维模型是盒式磁带。很多年前，现在不太用了，但盒式磁带是顺序的，它们从头开始，如果你想到达结尾，你必须有点像倒带才能到达那个点。现在最接近的类比可能是像 Netflix 或任何流媒体服务，那里有一个你必须从左到右拖动的进度条。你不能只是跳到那里或跳到那里。你没有随机访问权限。所以文件的问题在于，如果你想读写它们，你或某个库需要跟踪你在文件中的位置，这样如果你从顶部读取，然后在底部写入，然后你想再次开始读取，你就需要寻道（seek）回到开头。所以这不是我们将在课堂上做的事情。它更复杂，但绝对是可行的。就我们的目的而言，我们通常会建议，读取文件。然后如果你想更改它，再把它写出去，而不是试图进行更零碎的更改，尽管如果文件非常大，更改整个文件在时间上会非常昂贵，那么零碎更改是好的。

关于这个 `csv.reader` 还有其他问题吗？

**问：** （观众提问）在那个文件里写一个段落可能吗？

**答：** 绝对可以。现在我写的是非常短的字符串，只是名字或像我之前做的学院。但你绝对可以写任意多的文本。

关于 `csv.reader` 还有其他问题吗？

**问：** （观众提问）用户能自己选择一个键吗？比如，输入键将是名字或代码。

**答：** 所以简短的回答是，是的，我们绝对可以编写一个程序，提示用户输入名字和家，名字和家。我们可以写出那些值。稍后我们将看到你如何写入 CSV 文件。目前，我作为创建 `students.csv` 的程序员，假设我知道列将是什么。因此，我相应地命名我的变量。

然而，这是一个很好的过渡，引向读取 CSV 的最后一个特性，那就是你不必依赖于要么获取一个列表形式的行并使用 `[0]` 或 `[1]`，要么不必像这样手动解包东西。我们实际上可以更聪明，开始在 CSV 文件本身中存储这些列的**名称**。

事实上，如果你们中有人曾经打开过电子表格文件，无论是在 Excel、Apple Numbers、Google Sheets 还是类似软件中，很可能你已经注意到第一行通常有点不同。它实际上有时是粗体的，或者它实际上包含了那些列的名称，那些下面属性的名称。我们可以在这里这样做。

在 `students.csv` 中，我不必只是假设学生的名字是第一个，学生的家是第二个。我可以明确地将那个信息**嵌入 (bake)** 到文件中，只是为了减少将来出错的可能性。我可以字面上使用这个文件的第一行，然后说 `name,home`。

```csv
name,home
Draco,"Malfoy Manor"
Ron,"The Burrow"
Harry,"Number Four, Privet Drive"
```

所以注意，`name` 不是字面上的某人名字，`home` 不是字面上的某人家。它们是字面上的单词 `name` 和 `home`，用逗号分隔。

如果我现在回到 `students.py` 并且不使用 `csv.reader`，而是使用 **`csv.DictReader`**，我实际上可以更灵活地处理我的 CSV 文件，不仅仅是为了这个例子，也为了其他例子。

让我这样做。与其使用 `csv.reader`，不如让我使用 `csv.DictReader`，它现在将从上到下迭代文件，将每一行文本加载为不是列的列表，而是列的**字典**。

```python
import csv

students = []
with open("students.csv") as file:
    reader = csv.DictReader(file) # 使用 DictReader
    for row in reader:
        # 'row' 现在是一个字典, e.g., {'name': 'Harry', 'home': 'Number Four, Privet Drive'}
        students.append({"name": row["name"], "home": row["home"]}) # 使用键来访问

# 后面排序和打印逻辑不变 (但现在基于字典列表)
# def get_name(student):
#  return student["name"]
#
# for student in sorted(students, key=get_name):
#     print(f"{student['name']} is from {student['home']}")
```

这样做的好处是，它将自动让我访问那些列名。我将恢复到只说 `for row in reader`，现在我将追加一个 `name` 和一个 `home`。但我将如何访问当前行的 `name` 和当前行的 `home` 呢？

嗯，早些时候，当我使用 `reader` 时，我用 `[0]` 表示第一个，`[1]` 表示第二个。`reader` 返回列表。`DictReader` 或字典读取器返回字典，一次一个。所以如果我想访问当前行的 `name`，我可以说 `row['name']`。对于 `home`，我可以说 `row['home']`。我现在可以访问那些相同的值了。

我必须做的唯一改变，要清楚的是，是在我的 CSV 文件中，我必须在第一行包含一些关于这些列是什么的小提示。

如果我现在运行这段代码，我认为它的行为应该几乎完全相同——`python students.py`。确实，我们得到了相同的句子。但现在我的代码对这个数据的变化更具鲁棒性了。

如果我用 Excel、Google Sheets 或 Apple Numbers 打开这个 CSV 文件，并且出于某种原因改变了列的顺序，也许这是你与别人共享的文件，而他们只是因为想从左到右以不同方式排序而移动了列，以前我的代码会坏掉，因为我假设名字总是第一个，家总是第二个。但如果我做了这个——无论是在那些程序中手动做还是在这里做——`home,name`，并且假设我反转了所有这些。家在前，然后是 Harry；陋居，然后是 Ron；最后是马尔福庄园，然后是 Draco。

```csv
home,name
"Malfoy Manor",Draco
"The Burrow",Ron
"Number Four, Privet Drive",Harry
```

注意我的文件现在完全翻转了。第一列现在是第二列，第二列是第一列。但我注意更新了那个文件的标题，第一行。注意我的 Python 代码，我根本不打算碰它。我将重新运行 `python students.py`，回车。它仍然能正常工作。

这也正是防御性编程的一个例子。如果有人更改了你的 CSV 文件，你的数据文件怎么办？理想情况下，那不会发生。但即使现在发生了，因为我使用的是 `DictReader`，它将为我从第一行推断出列名是什么，我的代码就能继续工作。所以它不断地变得，如果你愿意这么说的话，越来越好。

现在关于这种方法有什么问题吗？

**问：** （观众提问）是的，CSV 文件中换行符的重要性是什么？

**答：** CSV 文件中换行符的重要性是什么？部分上是一种约定。在文本文件的世界里，我们人类几十年来一直习惯于逐行存储数据。它在视觉上很方便。从文件中提取也很容易，因为你只需查找换行符。所以换行符只是将一些数据与另一些数据分开。我们可以使用键盘上的任何其他符号，但通常是按 Enter 键将数据移到下一行。只是一种约定。

还有其他问题吗？

**问：** （观众提问）如果你只有名字和家，它似乎工作得很好。我想知道如果你想放入更多数据会发生什么。比如说，你想在名字和家的基础上都添加一个学院。

**答：** 当然，如果你想把学院加回去——所以如果我在这里进去，在最后添加 `house`，然后在这里为 Harry 说 Gryffindor，为 Ron 说 Gryffindor，为 Draco 说 Slytherin。

```csv
home,name,house
"Malfoy Manor",Draco,Slytherin
"The Burrow",Ron,Gryffindor
"Number Four, Privet Drive",Harry,Gryffindor
```

现在我实际上有三列了，如果你愿意这么说的话——左边是家，中间是名字，右边是学院，每个都用逗号分隔，还有像 "Number Four, comma, Privet Drive" 这样仍然带引号的奇怪东西。注意，如果我回到 `students.py`，并且根本不改变代码，然后运行 `python students.py`，它仍然能正常工作。这就是 `DictReader` 如此强大的原因。它可以随时间变化。它可以有越来越多的列。你现有的代码不会坏掉。你的代码会坏掉，会脆弱得多，可以说是，如果你做了像“第一列永远是名字。第二列永远是学院”这样的假设。如果那些假设被打破，事情会很快坏掉——但在这种情况下不是问题。

好，让我建议，除了读取 CSV，我们至少也看一下我们可能如何写入 CSV。如果你正在编写一个程序，你想在其中存储的不仅仅是学生的名字，也许还有他们的家，我们如何能继续向这个文件中添加内容？

让我删除 `students.csv` 的内容，只重新添加一个简单的行 `name,home`，以便预期将更多的名字和家插入到这个文件中。然后让我转到 `students.py`，让我完全重新开始，以便这次写出数据。

我仍然要 `import csv`。我现在准备提示用户输入他们的名字——`input("What's your name?")`。我准备提示用户输入他们的家——`home = input("Where's your home?")`。

现在我准备打开文件，但这次是为了写入而不是读取，如下所示：

```python
import csv

name = input("What's your name? ")
home = input("Where's your home? ")

with open("students.csv", "a", newline="") as file: # 打开用于追加，注意 newline=""
    writer = csv.writer(file)
    writer.writerow([name, home]) # 传递一个包含值的列表
```

我将以**追加模式 (append mode 'a')** 打开它，这样我就能不断地向文件中添加更多的学生和家，而不是覆盖整个文件本身。（注意：在 Windows 上使用 `csv` 模块写入时，推荐指定 `newline=''` 以避免额外的空行）。我将使用变量名 `file`。

然后我准备给自己一个名为 `writer` 的变量，并将其设置为 `csv` 模块中另一个叫做 `csv.writer` 的函数的返回值。那个 `writer` 函数接受 `file` 变量作为其唯一参数。

现在我准备就这样做。我说 `writer.writerow`，我向 `writerow` 传递我想写入文件的那一行，**特别地是作为一个列表**。所以我将给它一个包含 `[name, home]` 的列表，当然，它们是那些变量的内容。

现在我准备保存文件（`with` 语句会自动完成）。我准备重新运行 `python students.py`，回车。你的名字是什么？嗯，我输入 Harry 作为我的名字，还有 "Number Four, comma, Privet Drive"，回车。现在注意，那个输入本身确实有一个逗号。所以如果我现在去看我的 CSV 文件，注意它已经自动为我加上了引号，这样后续从这个文件读取时就不会把那个逗号与 Harry 和他家之间的实际逗号混淆了。

好，让我再运行几次。重新运行 `python students.py`。这次我输入 Ron 和他的家 The Burrow。回到 `students.csv` 看看它是什么样子。现在我们看到 `Ron,The Burrow` 已经被自动添加到文件中了。再来一次——`python students.py`，回车。输入 Draco 的名字和他的家，也就是 Malfoy Manor，回车。如果我们回到 `students.csv`，现在，我们看到 Draco 也在文件本身中了。

这个库不仅负责写入每一行（根据函数名）。它还处理了对任何本身包含逗号的字符串（比如 Harry 自己的家）的转义（可以说是）。

事实证明，还有另一种方法可以实现同一个程序，而不必担心那个精确的顺序，一次又一次地只是传入一个列表。事实证明，如果我们跟踪哪个是名字，哪个是家，我们可以使用像字典这样的东西来关联那些键和那些值。

所以，让我后退一步，从文件中移除这些学生，再次只留下标题行——`name,home`。让我转到 `students.py`。这次，与其使用 `csv.writer`，我准备使用 **`csv.DictWriter`**。

```python
import csv

name = input("What's your name? ")
home = input("Where's your home? ")

# fieldnames 应该与 CSV 文件的标题行匹配
fieldnames = ["name", "home"]

with open("students.csv", "a", newline="") as file:
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    # 注意：如果文件是空的或者刚创建，你可能想先写入标题行
    # if file.tell() == 0: # 检查文件是否为空 (一种方法)
    #     writer.writeheader()
    writer.writerow({"name": name, "home": home}) # 传递一个字典
```

这是一个字典写入器，它将以大致相同的方式打开文件。但与其将一行写为一个包含 `name, home` 的列表，我现在要做的是如下操作。我将首先输出一个实际的**字典**，它的第一个键是 `name`，冒号，然后其值是将要输入的 `name`。我将传入一个键 `home`，引号括起来，其值当然是将要输入的 `home`。

但是对于 `DictWriter`，我确实需要给它一个关于在写出时那些列的顺序的提示，以便后续即使那些顺序改变了也能被读取。让我传入 `fieldnames`，这是 `DictWriter` 的第二个参数，等于，然后是一个包含我知道在这个文件中的实际列的列表，当然是 `['name', 'home']`。那些时候用引号括起来，因为那确实是我打算在那个文件中写入的列的字符串名称，可以说是。

好了，现在让我去我的终端窗口，运行 `python students.py`。这次我再次输入 Harry 的名字。我再次输入 "Number Four, comma, Privet Drive"，回车。现在回到 `students.csv`。瞧，Harry 又回到了文件中，并且它被正确地转义或加了引号。我相信如果我们再用 Ron 和 The Burrow 做一次，然后第三次用 Draco 和 Malfoy Manor 做一次，回车。回到 `students.csv`。通过这个 `DictWriter`，我们现在也有了所有那三个学生。

所以，鉴于对于 `csv.writer`，责任在我们自己，要传入一个包含我们想从左到右放入的所有值的列表，而对于 `DictWriter`，技术上，它们在字典中可以是任何顺序。事实上，我完全可以正确地这样做，传入 `home` 然后是 `name`。

```python
# 在 DictWriter 的 writerow 中，字典键的顺序不重要
writer.writerow({"home": home, "name": name})
```

但它是一个字典。所以在这种情况下顺序不重要，只要键在那里并且值在那里。而且因为我已经将 `fieldnames` 作为第二个参数传递给了 `DictWriter`，它确保了库确切地知道哪一列分别包含 `name` 或 `home`。

现在关于字典读取、字典写入，或者更普遍的 CSV，有什么问题吗？

**问：** （观众提问）在任何特定情况下我应该使用单引号还是双引号？因为在 `print` 之后，我们用单引号来表示字典的键。但在读取或写入之后，我们用双引号。

**答：** 好问题。在 Python 中，你通常可以用双引号，或者你可以用单引号。而且没关系。你应该只是保持自我一致，这样你的代码风格在整个过程中看起来都一样。不过有时候，交替使用是**必需**的。如果你已经像我之前那样为长 f-string 使用了双引号，但在那个 f-string 内部，我正在使用花括号插入一些变量的值，而那些变量是字典。为了索引到字典，你使用方括号然后是引号。但如果你已经在外面使用了双引号，你通常应该在这里使用单引号，反之亦然。但除此之外，我习惯于在所有地方都使用双引号。其他人习惯于在所有地方都使用单引号。只有在有时一个可能被误认为是另一个时才重要。

关于字典写入或读取还有其他问题吗？

**问：** （观众提问）是的，我的问题是，我们能在任何程序中使用多个 CSV 文件吗？

**答：** 绝对可以。你可以使用任意多个你想要的 CSV 文件。它只是你可以用来保存数据的格式之一。

关于 CSV 或文件 I/O 还有其他问题吗？

**问：** （观众提问）当你从文件作为字典读取时，你调用了字段。当你读取时，你不能只调用行吗？在 `students.py` 文件的先前版本中，当你读取每一行时，你是按名称分割出字段的。是的，所以当你向 `students` 列表追加时，你不能只调用 `for row in reader, students.append(row)`，而不是命名每个字段吗？

**答：** 哦，非常聪明。简短回答是，是的，因为 `DictReader` 每次返回一个字典，当你循环遍历它时，`row` **已经**是那个字典了。所以是的，你实际上可以这样做，效果在这种情况下确实是一样的。很好的观察。

关于 CSV 还有一个问题吗？

**问：** （观众提问）是的，根据我过去处理数据的经验，在读取 CSV 时，很多事情都可能出错。我不知道你是否能用几句话回答这是一个公平的问题。但是否有任何最佳实践来复核没有发生错误？

**答：** 非常好的问题。我会说，总的来说，如果你使用代码来生成 CSV 并读取 CSV，并且你使用的是一个好的库，理论上，不应该出任何问题。它应该是 100% 正确的，如果库是 100% 正确的话。你和我，人类，往往是问题所在。当你让一个**人**接触 CSV 时，或者当 Excel、Apple Numbers 或其他一些可能与你的代码期望不一致的工具介入时，那么是的，事情就可能坏掉。目标——有时，老实说，解决方案是手动修复。你进去修复 CSV，或者你进行大量的错误检查，或者你使用大量的 `try, except` 只是为了容忍数据中的错误。但总的来说，我会说，如果你在一个程序内部同时使用 CSV 或任何文件格式来读取和写入它，你不应该有这方面的担忧。你和我，人类，通常是问题所在——而且不是程序员，而是那些文件的用户。

## 十、 处理二进制文件 (以图像为例)

好了，允许我建议我们暂时放下 CSV，但要注意它们不是你可以用来读取或写入数据的唯一文件格式。事实上，它们是一种流行的格式，就像纯文本文件——`.txt` 文件一样。但你实际上可以以任何你想要的方式存储数据。我们只是选择了 CSV，因为它代表了你可能如何从文件中读取和写入，并以一种结构化的方式进行，你可以以某种方式在同一个文件中拥有多个键、多个值，而不必求助于否则会被称为**二进制文件 (binary file)** 的东西。

所以二进制文件是一个真正只有 0 和 1 的文件。它们可以以任何你可能想要的模式排列，特别是如果你想存储的不是文本信息，而是可能是图形、音频或视频信息。

事实证明，Python 在拥有几乎所有东西的库方面确实很擅长。事实上，有一个流行的叫做 **Pillow** 的库，它允许你浏览图像文件并对图像文件执行操作。你可以应用滤镜，像 Instagram 那样。你也可以让它们动起来。

所以我想我们暂时放下文本文件，再做一个演示，这次专注于这个特定的库和图像文件。

我建议我们转到 VS Code 并创建一个程序，最终目的是创建一个**动画 GIF (animated GIF)**。这些东西现在以 meme、动画、贴纸等形式无处不在。而动画 GIF 实际上只是一个内部包含多个图像的图像文件。你的电脑或手机会一张接一张地向你展示那些图像，有时是无限循环，一次又一次。只要有足够多的图像，它就会产生动画的幻觉，因为你我的大脑会在视觉上填补空白，并假设如果某物在移动，即使你每秒只看到一帧，或者某个序列，它看起来也像动画。所以它就像是视频文件的简化版。

好，我建议我们从另一个流行的编程语言的几个“造型 (costumes)”开始。让我打开我的第一个造型，编号 1。假设这里这是一个造型，或者实际上只是一个静态图像，`costume1.gif`。它只是一只猫的静态图片，完全没有动作。

现在让我打开第二个，`costume2.gif`，看起来有点不同。注意——我来回切换一下——这只猫的腿的排列方式有点不同，所以这是版本 1，这是版本 2。现在，这些猫来自 MIT 的一个叫做 Scratch 的编程语言，它允许你非常图形化地让所有这些以及更多东西动起来。但我们将只使用这两个静态图像，`costume1` 和 `costume2`，来创建我们自己的动画 GIF，之后你可以发短信给朋友或给他们发消息，就像网上的任何 meme 一样。

好，我建议我们创建这个动画 GIF，不是通过使用某个我们下载的现成程序，而是通过编写我们自己的代码。让我运行 `code costumes.py` 并创建我们自己的程序，它将接受两个或更多图像文件作为输入，然后通过本质上在这两个图像之间无限地来回切换来生成一个动画 GIF。

我该怎么做呢？嗯，让我们假设这将是一个名为 `costumes.py` 的程序，它期望两个**命令行参数 (command line arguments)**，即我们想要来回动画的单个造型的文件名。为此，我将导入 `sys`，以便我们最终能访问 `sys.argv`。然后，从这个 Pillow 库中，我将专门导入对**图像 (Image)** 的支持。

```python
import sys
from PIL import Image # 从 Pillow 库导入 Image
```

现在我给自己一个名为 `images` 的空列表，这样我就有一个列表用来存储这些图像中的一个、两个或更多。现在让我这样做。对于 `sys.argv` 中的每个参数 `arg`：

```python
images = []
# sys.argv[0] 是脚本名, 我们需要从索引 1 开始的文件名
for arg in sys.argv[1:]:
    image = Image.open(arg) # 使用 Image.open 打开图像文件
    images.append(image)   # 将 Image 对象添加到列表中
```

这是在做什么？我建议，最终，我希望能够运行 `python costumes.py`，然后作为命令行参数指定 `costume1.gif` 空格 `costume2.gif`。所以我希望从命令行接收那些文件名作为我的参数。

那么我在这里做什么呢？嗯，我正在迭代 `sys.argv` 中我命令行参数里的所有单词。我创建一个名为 `image` 的变量，我将那个特定的参数传递给来自 Pillow 库的这个函数 `Image.open`。那个库本质上将以一种能给我很多操作它的功能（比如动画）的方式打开那个图像。现在我准备将那个特定的 `image` 追加到我的 `images` 列表中。

就是这样。所以这个循环的目的就是迭代命令行参数并使用这个库打开那些图像。

最后一行非常直接。我准备这样做。我将获取那些图像中的第一个，它将在我的列表的位置 `0`，我将把它**保存 (save)** 到磁盘。也就是说，我将保存这个文件。

```python
# 确保至少有两个图像
if len(images) >= 2:
    images[0].save(
        "costumes.gif",    # 输出文件名
        save_all=True,    # 保存所有帧
        append_images=images[1:], # 要附加的图像列表 (从第二个开始)
        duration=200,     # 每帧持续时间 (毫秒)
        loop=0            # 循环次数 (0 表示无限循环)
    )
else:
    print("Need at least two images to animate.")

```

现在，过去当我们使用 CSV 或文本文件时，我必须做文件打开。我必须做文件写入，甚至可能还有关闭。对于这个库，我不需要那样做。Pillow 库通过只调用 `save` 就为我处理了打开、关闭和保存。

我将调用这个 `save` 函数。只是为了留出空间，因为我有许多参数要传递，我将移到另一行以便它能放下。我将传入我想创建的文件名，`costumes.gif`——那将是我的动画 GIF 的名字。我将告诉这个库保存我传递给它的**所有帧 (save all frames)**——第一个造型，第二个造型，如果我给了更多的话还有更多。然后我将向这个第一个图像——`images[0]`——**追加 (append)** 以下图像，`images` 等于这个 `images` 列表。这有点巧妙，但我准备这样做。我想在那里追加下一个图像，`images[1]`。现在我想为这些帧中的每一帧指定 200 毫秒的**持续时间 (duration)**，并且我希望它**永远循环 (loop forever)**。如果你指定 `loop=0`，也就是时间 0，那意味着它不会循环有限次数，而是无限次数。

我还需要做另一件事。回想一下，`sys.argv` 不仅仅包含我在我的程序名之后输入的单词，`sys.argv` 还包含什么？如果你回想一下我们关于命令行参数的讨论，除了我将要输入的像 `costume1.gif` 和 `costume2` 这样的单词，`sys.argv` 还有什么？

**答：** （观众/主持人回答）是的，我们实际上会得到我们想运行的程序的原始名称，`costumes.py`。确实，我们会得到程序的原始名称，在这种情况下是 `costumes.py`，它显然不是一个 GIF。所以记住，使用 Python 中的切片，我们可以这样做。如果 `sys.argv` 是一个列表，我们想得到那个列表的一个切片，第一个元素之后的所有东西，我们可以用 `[1:]`，这表示，从位置 1 开始，而不是 0，并取一个一直到末尾的切片。所以给我那个列表中除了第一项之外的所有东西，正如 McKenzie 指出的，那就是程序的名字。

现在，如果我没有犯任何错误，让我们看看会发生什么。我将运行 `python costumes.py`，现在我将指定我想动画的两个图像——`costume1.gif` 和 `costume2.gif`。

代码现在将做什么？嗯，回顾一下，我们使用 `sys` 库来访问那些命令行参数。我们使用 Pillow 库来将那些文件视为图像，并利用该库附带的所有功能。我使用这个 `images` 列表只是为了从命令行一次一个地累积所有这些图像。在第 7 行到第 9 行（现在可能在第 5-7 行左右），我只是用一个循环来迭代所有它们，并在用库打开它们之后将它们添加到这个列表中。最后一步，实际上只是一行代码，为了适应而分成了三行，我将保存第一个图像，但我要求库也将这个其他图像追加到它上面——不是 `[0]`，而是 `[1]`。如果我有更多，我也可以表达出来。我想把所有这些文件一起保存。我想在每帧之间暂停 200 毫秒——五分之一秒。我希望它无限次循环。

所以现在如果我像往常一样祈祷好运，按下回车，没有坏事发生，这几乎总是一件好事。现在让我运行 `code costumes.gif` 在 VS Code 中打开最终的图像。我想我应该会看到一只非常快乐的猫？确实如此。

## 十一、 总结

所以现在我们不仅看到了我们可以读取和写入文件，无论是文本形式的。我们现在可以读取和写入二进制的、由 0 和 1 组成的文件。我们只是触及了表面。这是使用了叫做 Pillow 的库。但最终，这将赋予我们以任何我们想要的方式读取和写入文件的能力。

所以我们现在已经看到，通过文件 I/O，我们不仅可以操作文本文件，无论是 TXT 文件还是 CSV，甚至也可以操作二进制文件。在这种情况下，它们恰好是图像。但如果我们深入研究，我们可以探索音频、视频以及更多内容，所有这些都通过这些简单的原语，这种以某种方式读取和写入文件的能力。

今天就到这里。下次再见。


---

# 要点回顾

**CS50P - 课程 6 - 文件 I/O 框架与要点**

**一、 文件 I/O 基础**
- **目的**: 解决程序运行结束后数据丢失的问题，实现数据持久化存储。
- **概念**: 文件 I/O (Input/Output) 指的是程序读取（加载）文件信息或写入（保存）文件信息的操作。
- **对比**: 内存（变量、列表）中的数据是临时的，程序退出即丢失；文件可以将数据长期保存在磁盘上。

**二、 使用列表存储数据的局限性 (回顾)**
- 列表 (`list`) 可以存储多个值，但仍存储在内存中。
- 示例 (`names.py` 初版):
    - 创建空列表 `names = []`。
    - 使用循环获取多个用户输入（如名字）。
    - 使用 `names.append(name)` 将输入添加到列表中。
    - 可以使用 `sorted(names)` 对列表内容进行排序。
    - **问题**: 程序结束后，列表中的名字全部丢失。

**三、 文件写入操作**
- **打开文件**: 使用 `open(filename, mode)` 函数。
    - `filename`: 要操作的文件名（例如 `'names.txt'`）。
    - `mode`: 打开模式。
        - `'w'` (Write): 写入模式。如果文件存在则**覆盖**，不存在则创建。
        - `'a'` (Append): 追加模式。在文件末尾添加内容，如果文件不存在则创建。
    - `open()` 返回一个“文件句柄”（file handle），通常赋值给一个变量（如 `file`）。
- **写入内容**: 使用文件句柄的 `write()` 方法。
    - 示例: `file.write(data)`。
    - **注意**: `write()` 方法**不会**自动添加换行符 (`\n`)。如果需要换行，必须手动添加，例如 `file.write(f"{name}\n")`。
- **关闭文件**: 使用文件句柄的 `close()` 方法。
    - 示例: `file.close()`。
    - **重要性**: 关闭文件以确保所有内容被写入磁盘并释放资源。

**四、 使用 `with` 语句管理文件 (推荐)**
- **目的**: 自动管理文件的打开和关闭，避免忘记调用 `close()`。
- **语法**: `with open(filename, mode) as variable:`
    - 在 `with` 代码块内执行文件操作。
    - 代码块结束后，文件会自动关闭，即使发生错误。
- 示例:
  ```python
  with open("names.txt", "a") as file:
      file.write(f"{name}\n")
  # 文件在此处自动关闭
  ```

**五、 文件读取操作**
- **打开文件**: 使用 `open(filename)` 或 `open(filename, 'r')`。
    - `'r'` (Read) 是默认模式，可以省略。
- **读取方式**:
    - `file.readlines()`: 读取所有行，并返回一个包含所有行的列表（每行末尾包含换行符 `\n`）。
    - **直接迭代**: 更 Pythonic 的方式是直接在 `with` 块中迭代文件句柄：
      ```python
      with open("names.txt") as file:
          for line in file:
              # 处理每一行 'line'
      ```
- **处理换行符**: 从文件中读取的行通常包含末尾的换行符 `\n`。
    - `print()` 默认也会添加换行符，导致输出出现多余空行。
    - **解决方法**:
        - 使用 `print(line, end="")` 抑制 `print` 的换行。
        - 使用字符串方法 `line.rstrip()` 去除行末尾的空白字符（包括 `\n`）。通常更推荐此方法，因为它处理的是数据本身。

**六、 读取文件并排序**
- **需求**: 读取文件内容后，按特定顺序（如字母顺序）处理或显示。
- **方法**:
    1. 创建一个空列表（如 `names = []`）。
    2. 打开文件并逐行读取。
    3. 对每一行使用 `rstrip()` 去除换行符，然后 `append` 到列表中。
    4. 文件读取完毕后（`with` 块结束），使用 `sorted(list_name)` 对列表进行排序。
    5. 迭代排序后的列表进行处理（如打印）。
- **`sorted()` 函数**:
    - `sorted(iterable)`: 返回一个新的已排序列表。
    - `sorted(iterable, reverse=True)`: 返回反向排序的列表。

**七、 处理结构化数据：CSV 文件**
- **问题**: 如何存储相关联的多个数据字段（如学生姓名和学院）？
- **CSV (Comma-Separated Values)**: 一种常见的文件格式。
    - 每行代表一条记录。
    - 每行中的字段由逗号分隔。
    - 是一种纯文本格式，易于读写和共享。
- **手动解析 CSV**:
    - 读取文件每一行。
    - 使用 `line.rstrip().split(',')` 方法按逗号分割字符串，返回一个字段列表。
    - 通过索引访问字段（如 `row[0]`, `row[1]`），但可读性较差。
    - **改进**: 使用列表/元组解包（Unpacking）直接赋值给变量（如 `name, house = line.rstrip().split(',')`），提高可读性。
- **CSV 的陷阱**: 如果数据本身包含逗号（如地址 "Number Four, Privet Drive"），简单的 `split(',')` 会出错。

**八、 使用 `csv` 模块处理 CSV 文件 (推荐)**
- **目的**: 提供更健壮、更便捷的方式来读写 CSV 文件，自动处理逗号、引号等特殊情况。
- **导入**: `import csv`
- **读取 CSV**:
    - `csv.reader(file_handle)`: 创建一个 reader 对象，迭代该对象会逐行返回一个**列表**，其中包含该行的字段。
        ```python
        with open("students.csv") as file:
            reader = csv.reader(file)
            for row in reader: # row 是一个列表 ['Harry', 'Gryffindor']
                name = row[0]
                house = row[1]
                # 或 name, house = row (如果列数确定)
        ```
    - `csv.DictReader(file_handle)`: 创建一个 DictReader 对象，它假定 CSV 文件**第一行是标题行**。迭代该对象会逐行返回一个**字典**，其中键是标题行的列名，值是该行对应字段的内容。
        ```python
        with open("students.csv") as file:
            reader = csv.DictReader(file)
            for row in reader: # row 是一个字典 {'name': 'Harry', 'house': 'Gryffindor'}
                name = row['name']
                house = row['house']
        ```
        - **优点**: 代码不依赖于列的顺序，更具鲁棒性。
- **写入 CSV**:
    - `csv.writer(file_handle)`: 创建一个 writer 对象。
        - 使用 `writer.writerow(list_of_values)` 写入一行，需要提供一个包含各字段值的**列表**。
    - `csv.DictWriter(file_handle, fieldnames=list_of_headers)`: 创建一个 DictWriter 对象。
        - `fieldnames`: 必须提供一个包含所有列标题（按期望顺序）的列表。
        - 使用 `writer.writerow(dictionary_of_values)` 写入一行，需要提供一个**字典**，键是列标题，值是对应字段的值。字典中键值对的顺序不重要。
        - （可选）`writer.writeheader()`: 写入标题行。
    - **优势**: `csv` 模块会自动处理需要加引号的字段（如包含逗号的字段）。

**九、 排序复杂数据结构 (列表中的字典)**
- **场景**: 读取 CSV 文件后，通常会将每行数据存储为一个字典，并将所有字典放入一个列表中（例如 `[{'name': 'Harry', 'house': 'Gryffindor'}, ...]`）。
- **排序方法**: 使用 `sorted()` 函数的 `key` 参数。
    - `key` 参数接收一个函数，该函数应用于列表中的每个元素，`sorted()` 会根据该函数的返回值进行排序。
    - **方法 1: 定义辅助函数**:
        ```python
        def get_name(student):
            return student['name']
        sorted_students = sorted(students, key=get_name)
        ```
    - **方法 2: 使用 `lambda` 函数**: 创建一个匿名的、单行的函数。
        ```python
        sorted_students = sorted(students, key=lambda student: student['name'])
        # 也可以按 house 排序: key=lambda student: student['house']
        ```

**十、 处理二进制文件 (以图像为例)**
- **概念**: 文件不仅可以是文本（TXT, CSV），也可以是二进制格式（如图像、音频、视频），由 0 和 1 组成。
- **库**: Python 拥有处理各种二进制格式的库。
- **示例：`Pillow` 库 (PIL)**: 用于图像处理。
    - **安装**: 通常需要单独安装 (`pip install Pillow`)。
    - **导入**: `from PIL import Image`
    - **打开图像**: `img = Image.open(image_filename)`
    - **创建动画 GIF**:
        1. 导入 `sys` (获取命令行参数) 和 `Image`。
        2. 获取命令行传入的多个静态图像文件名 (`sys.argv[1:]`)。
        3. 创建一个空列表 `images`。
        4. 循环遍历文件名，使用 `Image.open()` 打开每个图像，并 `append` 到 `images` 列表中。
        5. 使用第一个图像对象调用 `save()` 方法创建动画 GIF：
           ```python
           images[0].save(
               "output.gif",      # 输出文件名
               save_all=True,     # 保存所有帧
               append_images=images[1:], # 要附加的后续帧列表
               duration=200,      # 每帧持续时间 (毫秒)
               loop=0             # 循环次数 (0 表示无限循环)
           )
           ```

**十一、 总结**
- 文件 I/O 是实现数据持久化的关键。
- Python 提供了 `open()`, `write()`, `read()` 等基本操作，`with` 语句是管理文件的推荐方式。
- `csv` 模块是处理 CSV 文件的标准、健壮的工具 (`reader`, `DictReader`, `writer`, `DictWriter`)。
- `sorted()` 配合 `key` 和 `lambda` 可以方便地对复杂数据结构进行排序。
- 通过特定库（如 `Pillow`），Python 也可以方便地处理二进制文件（如图像）。
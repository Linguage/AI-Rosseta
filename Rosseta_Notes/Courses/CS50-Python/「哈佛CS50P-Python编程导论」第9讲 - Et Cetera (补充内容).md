
# 「哈佛CS50P-Python编程导论」第9讲 - Et Cetera (补充内容)

- 视频链接：[CS50P - Lecture 9 - Et Cetera](https://www.youtube.com/watch?v=6pgodt1mezg&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=11)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---
### 内容介绍

欢迎阅读 CS50 Python 编程入门课程第九讲的演讲实录。在本讲座中，主讲人 David Malan 将引导我们探索 Python 语言中一系列补充性的、但同样实用和强大的特性，这些内容在前几周的核心主题之外，被统称为“Et Cetera”。讲座的目标是拓宽学习者的视野，展示 Python 在基础概念之外所能提供的更多功能和编程范式。

内容涵盖了多种数据结构（如用于自动去重的 `set` 集合）、语言特性（如处理变量作用域的 `global` 关键字、表示常量的约定、用于提高代码质量的类型提示和文档字符串）、实用库（如简化命令行参数处理的 `argparse`），以及更高级的编程技巧。这包括灵活处理函数参数的解包（`*`, `**`）与可变参数（`*args`, `**kwargs`），受函数式编程启发的 `map` 和 `filter` 函数，Pythonic 的列表与字典推导式，便捷获取索引的 `enumerate`，以及高效处理大数据流的生成器和 `yield` 关键字。

### 内容纲要

```
CS50P 第 9 讲 - Et Cetera (补充内容)
├── 引言与回顾
│   ├── 课程回顾 (函数、变量、条件、循环、异常、库、测试、文件IO、正则、OOP)
│   └── 本讲目标：介绍 Python 中其他有用的“补充”特性 (Et Cetera)
├── `set` (集合)
│   ├── 概念：无序、无重复元素的集合
│   ├── 用途：自动去重
│   ├── 示例：提取霍格沃茨学院 (对比列表 vs 集合)
│   ├── 语法：`set()`, `.add()`
│   └── 成员检查：`in`
├── `global` 关键字与变量作用域
│   ├── 作用域概念：局部 vs 全局 (模块级)
│   ├── 问题：函数内修改全局变量 (`UnboundLocalError`)
│   ├── 解决方案 1：`global` 关键字
│   └── 解决方案 2 (更优)：面向对象封装 (类、实例变量 `self.var`)
├── 常量 (Constants)
│   ├── 概念：值不应改变的变量
│   ├── Python 约定：全大写命名 (如 `MEOWS = 3`)
│   ├── 示例：模块级常量、类级常量
│   └── 重点：Python 不强制常量性，依赖约定
├── 类型提示 (Type Hints) 与 `mypy`
│   ├── 背景：Python 是动态类型语言
│   ├── 概念：为代码添加类型标注 (变量、参数、返回值)
│   ├── 语法：`var: type`, `param: type`, `-> type`, `-> None`
│   ├── 工具 `mypy`：静态类型检查器
│   │   └── 用途：在运行前发现类型错误，提高代码健壮性
│   └── 作用：提高可读性、可维护性、辅助静态分析
├── 文档字符串 (Docstrings)
│   ├── 概念：标准化的代码文档方法
│   ├── 语法：三引号 (`"""..."""` 或 `'''...'''`)
│   ├── 内容与格式：总结、参数、类型、返回值、异常 (reStructuredText 示例)
│   └── 作用：提高可读性、支持工具自动生成文档
├── `argparse` 模块
│   ├── 问题：手动处理 `sys.argv` 的复杂性
│   ├── 解决方案：`argparse` 库，简化命令行接口创建
│   ├── 使用流程：创建解析器、添加参数定义 (`add_argument`)、解析参数 (`parse_args`)、访问参数值
│   └── 优点：自动化处理帮助信息、类型转换、默认值、错误处理
├── 解包 (Unpacking)
│   ├── 概念：将可迭代对象元素分配给变量或作为独立参数
│   ├── 变量赋值解包：`a, b = iterable`
│   ├── 函数调用解包 (`*`)：将列表/元组解包为位置参数 `func(*iterable)`
│   └── 函数调用解包 (`**`)：将字典解包为关键字参数 `func(**dictionary)`
├── 函数定义中的 `*args` 和 `**kwargs`
│   ├── 目的：定义可变参数函数 (Variadic functions)
│   ├── `*args`：收集多余的位置参数到元组
│   ├── `**kwargs`：收集多余的关键字参数到字典
│   └── 用途：创建灵活函数、函数包装 (`print` 函数为例)
├── 函数式编程相关特性
│   ├── `map(function, iterable)`：将函数应用于每个元素
│   └── `filter(function, iterable)`：根据函数返回值 (True/False) 筛选元素
├── 列表推导式 (List Comprehensions)
│   ├── 概念：简洁创建列表的语法
│   ├── 语法：`[expression for item in iterable if condition]`
│   └── 优点：通常比循环+`append` 或 `map`/`filter` 更紧凑
├── 字典推导式 (Dictionary Comprehensions)
│   ├── 概念：简洁创建字典的语法
│   └── 语法：`{key_expr: value_expr for item in iterable if condition}`
├── `enumerate` 函数
│   ├── 问题：迭代时同时需要索引和值
│   ├── 解决方案：`enumerate(iterable, start=0)`
│   └── 优点：比手动计数或 `range(len(...))` 更简洁
├── 生成器 (Generators)、迭代器 (Iterators)、`yield` 关键字
│   ├── 问题：处理大数据集时可能耗尽内存
│   ├── 概念：生成器函数使用 `yield` 产生一个迭代器，按需生成值
│   ├── `yield` 关键字：暂停函数状态，返回一个值，下次从暂停处继续
│   ├── 迭代器：表示数据流的对象，可逐个访问
│   ├── 示例：数羊程序 (对比一次性返回列表 vs 使用 `yield`)
│   └── 优点：极高的内存效率，可处理大数据流
└── 结论与展望
    ├── 本讲内容是工具箱的补充
    ├── 课程整体回顾
    ├── 强调解决问题和自学能力的重要性
    └── 最终演示：结合 `cowsay` 和 `pyttsx3`
```



# **CS50P 第 9 讲 - Et Cetera (补充内容)**

## **一、 引言与回顾**

[音乐播放]

DAVID J. MALAN：好的。这里是 CS50 的 Python 编程入门课程。我是 David Malan。

在过去的几周里，我们早期专注于函数和变量，然后是条件语句、循环、异常处理、一些库的使用、单元测试、文件布局、正则表达式、面向对象编程，以及等等（et cetera）。确实，今天我们关注的焦点就是“等等”——在掌握了那些基本概念之后，你可以用 Python 和更广泛的编程知识做更多的事情。

事实上，如果你开始翻阅 Python 的文档及其所有形式——所有这些都一如既往地可以在 `docs.python.org` 上找到——你会看到关于 Python 官方教程、库、参考手册、操作指南等的额外文档。在所有这些文档以及更多在线资料中，你会发现一些我们没有完全涉及到的细节。确实，尽管我们过去几周的主题围绕着相当广泛且对于解决 Python 中典型问题至关重要的话题，但事实证明，还有相当多的其他特性我们没有必要触及，它们不一定适合任何那些 overarching 的概念，或者如果我们在课程早期就讲授，可能会显得过于超前。

因此，在我们今天的最后一讲中，我们将真正关注你能用 Python 做的更多事情，并希望能激发你自学更多知识的兴趣。

## **二、 `set` (集合)**

例如，在 Python 的各种数据类型中，还有一种我们之前没有机会使用的数据类型，那就是集合（set）。在数学中，集合通常是一组值的集合，其中没有重复项。所以它不完全是列表；它更特殊一些，因为它能以某种方式为你消除任何重复项。事实证明，在 Python 中，这是一种实际的数据类型，你可以在自己的代码中使用。通过这里的文档，你或许能领会到，如果你想以某种方式自动过滤掉重复项，这是一个有用的工具。

让我打开 VS Code。让我给你们看一个我事先创建好的文件，叫做 `houses.py`。在 `houses.py` 中，我已经准备好了一个庞大的学生列表，里面包含许多字典，每个字典分别代表一个学生的名字和学院。这是一个相当大的字典，因此很适合对其进行迭代。

假设这里的目标很简单，就是找出霍格沃茨（哈利波特世界中）所有独特的学院有哪些？也许，不事先知道这些细节或在网上查找会更好。这里我们有一组学生的数据，虽然不详尽，但包含了所有学院。在这些学生中，他们居住的独特学院有哪些？当然，作为人类，我可以一眼看出是格兰芬多（Gryffindor）、斯莱特林（Slytherin）和拉文克劳（Ravenclaw）。但我们如何以编程方式为这些学生做到这一点呢？

让我们先尝试一种方法。在 `houses.py` 中，我建议我们首先创建一个名为 `houses` 的空列表，我将在其中累积每个唯一的学院。所以，每次我迭代这个字典列表时，只有当我之前没有见过这个学院时，我才会把它添加到这个列表中。

那么如何表达呢？嗯，让我像过去那样，用 `for student in students` 遍历所有学生。现在让我问一个问题。如果当前学生的学院——注意我正在索引当前学生，因为我知道它们是字典（dict）对象——如果那个学生的学院 `not in` 我的 `houses` 列表，那么，缩进后，我会执行 `houses.append`，因为 `houses` 是一个列表。我会将那个特定的学院附加到列表中。

然后，在最底部，让我做一些有点意思的事情，对于我累积在 `houses` 中的每个学院，我可以直接说 `houses`。但如果我只说 `houses`，一次性累积它们的意义何在呢？我完全可以在一个循环中完成所有事情。至少让我们用 `sorted` 对这些学院进行排序，这将按字母顺序对字符串进行排序。然后在其中打印每个学院。

现在让我在终端窗口中运行 `python houses.py` 并按 Enter。好了，结果出来了：Gryffindor, Ravenclaw, Slytherin，按字母顺序排列，尽管在上面的字典列表中，我们看到它们的顺序实际上是 Gryffindor, Gryffindor, Gryffindor, Slytherin, Ravenclaw。所以，我的代码似乎正确地对它们进行了排序。

这完全没问题，是解决这个问题的一种方法。但事实证明，我们可以利用 Python 语言内置的更多功能来自己解决这个问题。在这里，我有点在重新发明轮子，实际上是在重复集合（set）的概念，即重复项会被自动消除。

让我清空终端窗口，或许改变我在这里使用的对象类型。与其使用列表（也可以写成 `[]` 来创建空列表），不如让我创建一个空集合，方法是调用一个名为 `set` 的函数，它将返回给我 Python 中的某个对象，代表这种集合的概念，其中重复项会自动被消除。

现在，我可以精简我的代码了。因为我不必自己使用这个 `if` 条件。我想我可以这样做。在我的循环内部，让我执行 `houses.add`。注意，对于集合是 `add`，对于列表是 `append`。但根据文档，对于集合是 `add`。然后让我添加当前学生的学院。现在，我认为我代码的其余部分可以保持不变。我现在只是相信 Python 中 `set` 的文档，它会为我过滤掉重复项。我可以盲目地将所有这些学院 `add`, `add`, `add`, `add` 到集合中，任何已经存在的重复项都会消失。

运行 `python houses.py` 并按 Enter。瞧，我们又得到了同样的结果，只有那三个学院。

让我在这里暂停一下，看看关于 `set` 的使用是否有任何问题，它只是你可以使用的另一种数据类型，Python 世界中的另一个类，你可以在解决类似这样的问题时选用。

**提问：** 我们如何在集合中定位一个项目，例如，找到集合中的 Gryffindor？

**回答：** 如何在集合中查找项目？你可以使用与我们之前对列表使用的非常相似的语法。你可以使用像 `if "Gryffindor" in houses:` 这样的语法，然后你可以据此回答问题。所以你可以使用 `in` 和 `not in` 以及类似的函数。

**提问：** 关于 set 的其他问题？如果你的学院名称相似怎么办？比如说，Slytherin 中的 i 被换成了 o。`for` 循环会遍历学院名称中的每个字母吗？

**回答：** 它会比较字符串。所以，如果 Slytherin 出现多次，但拼写稍有错误或大小写不同，如果你没听错的话，那些会被视为不同的字符串。所以你会在结果中得到两个版本的 Slytherin。然而，我们过去已经看到，如果用户的数据确实可能混乱，我们如何清理它。我们可以强制所有内容为大写，或所有内容为小写，或者我们可以使用 `str` 内置的 `capitalize` 函数，或 `title` case（首字母大写）来为我们处理一些清理工作。在这种情况下，因为数据不是来自使用 `input` 函数的人类用户，而是我预先编写的代码，所以可以更安全地假设我把学院名称写对了。但如果数据来自用户，这绝对是一个风险。

## **三、 `global` 关键字与变量作用域**

让我把注意力转回到我们可以利用 Python 的其他一些特性上，如果我们更深入地研究文档并阅读更多关于其特性的内容。在某些语言中，有全局变量（global variables）的概念，你可以定义一个变量，它要么是函数局部的（local），就像我们多次看到的那样；要么如果你把变量放在所有函数之外，也许在文件的顶部，那通常会被认为是全局变量。或者在 Python 的世界里，它可能是特定于模块（module）的。但就所有意图和目的而言，对于一个给定的程序，它的行为就好像是全局的。

然而，事实证明，如果你在以后解决某个问题时这样做，即你有多个函数，并且确实有一个或多个变量在这些函数之外，你可能无法像你想象的那么容易地改变这些变量。

所以，让我回到 VS Code。稍后，我将创建一个新文件，比如叫做 `bank.py`。让我们实现一个银行的概念，我们可以在其中以各种形式存储像钱这样的东西。让我这样做。让我实现一个非常简单的银行，它只跟踪我的总余额，即我在这个银行里存储的美元或分或其他任何东西的数量。我将在顶部给自己一个名为 `balance` 的变量，它是一个整数，设置为零。

现在让我定义一个我们通常做的 `main` 函数。在我的 `main` 函数内部，让我打印出 "Balance:"，然后打印出 `balance` 变量本身的值。就像我们经常做的那样，向 `print` 传递多个参数，以便它们被单个空格隔开。现在，既然我有一个 `main` 函数，为将来做更有趣的事情打下基础，让我做我们通常的检查：如果这个文件的名字等于 `__main__`，那么就调用 `main`。

这是一个非常短的程序，但它可能代表了你将来在 Python 中解决某个问题的方式。你有一个 `main` 函数，最终会做一些有趣的事情。在你的文件顶部，你有一个或多个变量，把它们放在那里很有用，因为这样你就知道它们在哪里了。也许不仅是 `main` 函数，其他函数也可以访问它们。

那么，让我们看看。当我运行这个程序 `python bank.py` 时，根据我目前的直觉，我希望看到我当前的余额是零。也就是说，即使 `balance` 变量是在第 1 行定义的，我希望我仍然可以在 `main` 函数内部的第 5 行打印它，即使 `balance` 并未在我的 `main` 函数中定义。

开始了。按下 Enter。瞧，Balance: 0。所以它确实有效。即使你在 Python 的函数外部声明了一个变量，看起来你仍然可以访问它。你可以在像 `main` 这样的函数内部读取该变量的值。

好吧，让我们更大胆一点。因为这个程序并没有真正解决任何人的问题。让我们实现一个更完整的银行，比如能够向银行存款（deposit）和从银行取款（withdraw）。这样我就有了更多可能需要访问同一个变量的函数。

让我清空我的终端窗口。让我暂时假设我有能力存入，比如说，100 美元或 100 个硬币，无论这里的货币单位是什么。然后，也许我想立即取出其中的 50 美元或硬币。现在，让我在 `main` 函数的底部打印出我新的余额应该是多少，这样在理想情况下，一旦我存入 100 然后取出 50，从 0 开始，我希望我在第 8 行的新余额确实是 50。

好的。但我还没有实现这些函数。所以让我们像过去那样做。在这里下面，我将定义另一个函数 `deposit`。我会说它接受一个名为 `n` 的参数，代表硬币或美元等的数量。我将这样做：`balance += n`，从而改变 `n` 的值。（注：应为改变 `balance` 的值）我可以写得更冗长：`balance = balance + n`。但我将使用更简短的表示法。

现在，让我们实现 `withdraw`。定义一个名为 `withdraw` 的函数。它也接受一个变量——一个参数 `n`，代表美元或硬币的数量。现在，我将从 `balance` 中减去，使用 `balance -= n`。并且，如果这个文件的名字是 `main`，我仍然会调用 `main`。

那么我做了什么？我刚刚添加了不止一个，而是总共三个函数，所有这些函数显然都需要通过打印、增加或减少来访问 `balance`，正如我们在这里看到的。

好的。让我专注于这三个函数。让我回到我的终端窗口，运行 `python bank.py` 并按下 Enter。哇哦。

看来我们引入了一些问题。这些问题是什么？嗯，`UnboundLocalError` 可能是我们第一次看到这个错误。局部变量 `balance` 在赋值前被引用。这有点误导人，肯定会让人困惑。因为我绝对在我的代码顶部给 `balance` 赋了值。事实上，如果我向上滚动，那里没有任何改变或丢失。它肯定被赋了值。现在看来，在第 12 行，当 `deposit` 被调用时，我只是想再次访问那个变量。

那么直观上，什么可能解释这个错误信息，`UnboundLocalError`？当涉及到这些在我的文件顶部的所谓全局变量时，Python 告诉我们它能做什么或不能做什么？

**提问者：** 所以，如果你想改变这个变量，你应该在 `main` 函数内部写。全局变量是不可变的。

**回答 (David Malan)：** 是的。

**提问者：** [听不清]

**回答 (David Malan)：** 所以如果你想改变它的值，它可能需要是函数局部的。然而，如果你试图在函数中改变一个全局变量，显然是行不通的。所以读取一个全局变量是可以的。读取意味着访问它、打印它等等。但显然，你不能以同样的方式从这些函数内部写入一个全局变量。

好吧。也许解决方法是这样做。让我清空我的终端窗口和那个错误。也许我可以这样做。让我们去掉全局变量。让我们把它放在，例如，`main` 函数内部。这样现在能行吗？好吧，让我现在试试。`python bank.py` Enter。

仅仅这样做并没有解决问题。我仍然有 `UnboundLocalError`。不过这次，是出于不同的原因。事实证明，现在第 2 行的 `balance` 根据定义是一个局部变量。局部变量是在函数上下文中存在的变量，至少在这种情况下是这样。全局变量则相反，它不存在于函数上下文中，例如在我的文件顶部。所以这是 Python 中的另一个区别。如果你在像 `main` 这样的函数中声明一个变量，就像我在第 2 行对 `balance` 所做的那样，它确实是该函数局部的。`deposit` 和 `withdraw` 函数无法访问同一个变量。为什么？因为它对 `main` 是局部的。

所以你现在可能会想，我们陷入了一个恶性循环。好吧，也许解决方案是将 `balance` 移到全局范围，这样所有三个函数都可以访问它。但显然，正如 Elena 指出的，我们开始的地方，我们因此不能改变它。

事实证明，在 Python 中解决这个问题的办法，讽刺的是，正是这个关键字：`global`。如果你以前用其他语言编程过，可能会觉得有点不同。但在 Python 中确实有一个名为 `global` 的关键字，它允许你告诉一个函数，嘿，这不是你的局部变量。我的意思是让它成为一个我希望你编辑的全局变量。

所以如果我回到 VS Code，清空我的终端窗口以消除那个错误。让我撤销我刚才做的更改，把 `balance` 放回我文件的顶部。但这次，我要做的是，我要通知我的两个需要改变 `balance` 值的函数，即 `deposit` 和 `withdraw`，它确实是全局的，方法是在这里以及这里都输入 `global balance`。我仍然在第 13 行和第 18 行保留同样的代码，它们增加和减少 `balance`。但是现在使用关键字 `global` 对 Python 来说是一个小小的提示，哦，好的。它不是一个局部变量。这不是你引入的一个 bug。你的意思是让我编辑上面的那个变量。

所以现在，让我在我的终端窗口运行 `python bank.py`。我希望看到我的余额是 $0 + 100 - 50 = 50$。确实，现在是了。根据我第 5 行的第一个打印语句，它开始是 0。但最终在第 8 行的总额是 50。

让我在这里暂停一下，看看现在关于这些全局或局部变量是否有任何问题。

**提问：** 如果你同时在全局（例如文件顶部）和一个函数内部声明了一个同名变量，会发生什么？

**回答：** 好问题。你总是在考虑所谓的边界情况（corner cases）。所以，如果你既在全局声明了一个变量，又在一个函数内部声明了一个同名变量，后者会“遮蔽”（shadow）前者。也就是说，你将能够使用后者，即局部变量。但它对全局变量没有影响。暂时地，Python 只会知道局部变量的存在。所以总的来说，经验法则是，就是不要那样做。不仅因为它可能在你的代码中产生 bug，因为你没有改变你打算改变的东西。而且对其他读者来说也可能不明显。

**提问：** 关于全局或局部变量的其他问题？好的，如果我们决定在 main 函数内部将 balance 作为参数添加会怎样？

**回答：** 是的，另一个好的直觉。但在这种情况下，那也解决不了问题。因为如果你把像 `balance` 这样的变量传递给每个函数，然后在该函数内部改变它，它实际上只会改变一个局部副本。它不会改变那些函数外部的东西。

所以我认为我们实际上需要一个完全更好的方法。事实上，请允许我过渡到对这个相同程序的修改。回想一下，我们最近研究了面向对象编程（object-oriented programming）的概念。通过它，你可以模拟现实世界的实体，例如银行，并且你可以模拟和封装（encapsulate）关于该现实世界实体的信息，例如某人的账户余额。

所以让我建议我们实际上这样做。让我从头开始 `bank.py`。完全去掉全局变量。实际上使用一些面向对象的代码。让我定义一个名为 `Account` 的类来代表某人的银行账户。然后，让我用我的 `__init__` 方法进行初始化，该方法按照惯例至少接受一个名为 `self` 的参数。让我将每个人的银行账户初始化为某个值，比如零。

现在，我该怎么做呢？好吧，我将执行 `self.balance = 0`。从而给我一个名为 `balance` 的实例变量，为这个账户初始化为零。但我将主动地记住我们还引入了属性（properties）的概念，它可能会与我的实例变量名称冲突。所以，按照惯例，我将这样做。我将主动地将这个实例变量重命名为 `_balance`，以有效地表明它是私有的，尽管 Python 并不强制执行这一点。这只是给我自己的一个视觉提示，表明这是我不应该——或者其他代码不应该触碰的东西，只有这个类中的函数可以。

现在，让我继续。让我定义一个实际的名为 `balance` 的函数，它实际上将是一个属性（property），其存在的目的只是返回 `self._balance`。我将明确地说明这确实是这个类的一个属性，使用 `@property` 装饰器。

现在，让我重新实现那另外两个函数，`deposit` 和 `withdraw`，但在这个类的范围内。所以，我要说，`def deposit(self, n):`。它像往常一样接受一个参数 `self`，但还有一个额外的参数 `n`，代表要存入的美元或硬币的数量。现在我如何操作这个呢？好吧，我将执行 `self._balance += n`。

然后在这里下面，我将执行 `def withdraw(self, n):`，就像 `deposit` 一样。但在这里，我将执行 `self._balance -= n`。

现在，如果我移到这个类的下方，我将定义一个 `main` 函数，这样我现在就可以尝试运行它了。我将通过调用 `Account` 构造函数（即类名加两个括号，如果我不向 `__init__` 传递任何参数的话）来创建一个 `Account` 对象。我现在将像之前一样打印出我账户的余额。但要做到这一点，我将像这样访问该账户的属性：`account.balance`。我现在将存入另外 100 美元或硬币，使用 `account.deposit(100)`。然后，像之前一样，出于某种原因，我将立即取出其中的 50，使用 `account.withdraw(50)`。现在，我将最后一次打印 "Balance:" 后面跟着 `account.balance`，再次访问那个属性。当然，为了让这一切正常工作，我需要一个这样的 `if __name__ == "__main__":` 检查，然后调用 `main`。

现在，在我运行这个之前，你会看到它相当快地升级了。我本来有一个非常简单的目标，即实现银行的概念。最终我能够通过将 `balance` 声明为全局，然后告诉我的每个函数它确实是全局的，来完美地实现这一点。但这并不是我们现在可用的最佳封装形式。根据我们对面向对象编程的关注，如果我们试图实现像银行账户这样的现实世界实体，这就是类允许我们做的。它允许我们可能更清晰地解决同样的问题，特别是如果我们要随着时间的推移积累越来越多的函数或方法。

所以，如果我这里没有犯任何错误，如果我现在运行 `python bank.py` 并按下 Enter，你会看到它工作得很好。因为在 Python 的类世界中，这些所谓的实例变量根据定义，对于该类中的所有方法都是可访问的，因为我们都是通过那个特殊的参数 `self` 来访问它们的。

那么，该用哪种方式呢？对于一个相当小的脚本，你只是想实现一个有一些全局信息（比如账户余额）的脚本，然后你需要在其他地方操作它，`global` 关键字是解决该问题的一种方案。但总的来说，在许多语言中，Python 在某种程度上也包括在内，使用全局变量往往不受欢迎，仅仅是因为事情会很快变得混乱。而且，如果你的信息一部分在这里，一部分在你的函数里，那么你的信息到底存储在哪里会很快变得不那么明显。所以总的来说，经验法则是谨慎使用全局变量。尽管从技术上讲，在 Python 中，如果我们确实在实现一个库而不仅仅是一个程序，这些全局变量在技术上是模块局部的。简而言之，尽量少用全局变量。但当你确实需要用时，对于这些同样的问题是有解决方案的。

现在对全局变量或我们使用成熟的面向对象编程重新实现相同想法有任何问题吗？

**提问：** 我只想问一下，这个属性（property）是做什么的？

**回答：** 这个属性是做什么的。所以如果我回到 VS Code 这里，你会看到这是我们在面向对象编程讲座中看到的一种技术。属性是一个受到某种保护的实例变量。它允许我控制它如何被读取和写入。所以在这种情况下，我只有通常所谓的 getter（获取器）。这里没有提到 getter 这个词。这个 `@property` 意味着，函数 `balance` 将允许我，回想一下，使用像 `account.balance` 这样的语法，我可以假装 `balance`（没有下划线）确实是一个实例变量。但我现在可以阻止像我在 `main` 函数中的代码那样试图改变 `balance`。因为我没有 setter（设置器），我将无法做类似 `account.balance = 1000` 的事情来给自己 1000 美元或硬币，因为我没有定义 setter。所以，再次强调，根据我们对面向对象编程的关注，这些属性只是允许我进行一些更细粒度的控制。

## **四、 常量 (Constants)**

有些语言允许你定义所谓的常量（constant）变量。也就是说，一旦你给它们赋值，你就不能改变该变量的值。这通常是一件好事，因为它允许你进行防御性编程。万一你不小心，或者其他人不小心试图修改该变量的值，如果你在某种语言中已将其声明为常量，它就不能被更改，或者通常不费很大力气是无法更改的。

不幸的是，在 Python 中，我们再次处于一种“君子协定”（honor system）的状态。我们有约定来表明某物应该被当作常量来对待。但这实际上并没有被语言强制执行。例如，让我回到 VS Code。让我创建一个新文件，例如叫做 `meows.py`。让我们看看我们是否能实现猫在屏幕上喵喵叫的概念。

所以，执行 `code meows.py`。在 `meows.py` 中，让我实现一个非常简单的程序，让一只猫叫三次。这样如何：`for i in range(3): print("meow")`。

好的。我们过去已经看到如何稍微清理一下这个。例如，如果我实际上没有使用 `i`，我最好在 Pythonic 的方式下将该变量的名称更改为下划线 `_`，即使这在这里没有功能上的效果。但是我们在这里随机硬编码（hardcoded）了一个 3，也就是说，明确地输入到我的代码中。当你的代码只有两行时，这完全不是什么大问题。但想象一下，这是一个更大的程序，有几十甚至几百行。想象一下，其中一行代码的某个地方就有一个 3。你永远不会轻易找到那个 3。而且你或你的同事或其他人在你的代码中硬编码了像 3 这样的魔法值（magic value），这将很容易被忽略。

所以，通常最佳实践是，不仅在 Python 中，在其他语言中也是如此，每当你有一个本质上是常量的值，比如一个不应该改变的数字 3，至少要让它浮现出来，把它放到你的代码顶部，这样你的代码的常量值就很明显了。我的意思是这样：

在这个文件的顶部，对于同事，坦率地说，对于明天的我（在我忘记今天做了什么之后），定义一个像 `MEOWS` 这样的变量并将其设置为 3，可能会更清晰一些。然后，与其在这里硬编码 3，或者在一个更大的程序的更深处硬编码，不如让我直接将该变量的值传递给我的循环。这样，对我来说就很明显了，`MEOWS` 显然是喵喵叫的次数。如果我将来想改变它，我唯一需要改变的代码就在文件的最顶部。我不需要到处寻找或者弄清楚什么会坏掉，我需要改变什么。我只知道我可以在顶部更改这些常量。

然而，Python 的问题在于 Python 实际上并不能让变量成为常量。在 Python 和其他一些语言中，这确实是一个约定，至少在你想要向世界表明你不应该触碰这个变量时，将其大写。它是常量。但我的代码中没有任何东西能阻止我说，“你知道吗？今天我想要四声喵喵叫。” 那样是可行的。然而，在其他语言中，通常会有一个关键字或其他语法机制，允许你阻止当前第 3 行的执行。这样，当你试图运行你的代码时，你实际上会得到一个明确的错误消息，说：你不能这样做。所以 Python 在这些约定方面，再次更倾向于君子协定。

现在，事实证明，还有其他类型的“常量”，Python 通常会体现出来。事实上，让我稍微改变一下。让我删除这个版本的 `meows.py`。让我再次引入一个类，来自我们关于面向对象编程的讨论，比如一个代表猫（cat）的类，另一个现实世界的实体。

回想一下，在类中，你不仅可以有实例变量（instance variables），还可以有类变量（class variables）。也就是说，类内部的变量，它们本身不属于 `self`，但该类内部的所有方法都可以访问它们。在这里，同样有一个约定，但 Python 并不强制执行，即拥有类常量（class constants）。在类内部，你可能想要一个变量，它应该、应该、应该不被改变。但你只是想通过将其名称大写来在视觉上表明这一点。

例如，如果一只猫默认的喵喵叫次数应该是 3，我可以 буквально 在我的类内部，但在我定义的任何方法之外，创建一个全大写的类变量，并赋予它相同的值。然后，如果我想创建一个方法，比如 `meow`，作为一个实例方法，它可能会像我们知道的那样接受 `self`。然后，我可能会在这里写我的循环 `for _ in range(...)`——现在我需要访问这个。约定是说 `Cat.MEOWS`，以明确我想要的是与名为 `Cat` 的类相关联的 `MEOWS` 变量。然后我将打印出一声喵喵叫。

现在，在我的代码底部，类的外部，让我做类似这样的事情。让我使用 `Cat` 构造函数实例化一只猫。注意这一点很重要。根据我们对 OOP 的讨论，类名按照约定是大写的。但这边的变量是小写的。我可以叫它 `c` 或其他任何名字。但我有点喜欢称它为小写的 `cat` 和大写的 `Cat` 这种对称性。现在，如果我想让这只特定的猫喵喵叫默认的三次，我可以这样做：`cat.meow()`。这个 `meow` 方法将根据第 5 行，访问那个类常量。但再次强调，它只是在“你不应该触碰它”的意义上是常量，而不是说语言会实际强制执行。

那么，让我继续用 `python meows.py` 运行这个。好了，这就是我们的三声喵喵叫。

## **五、 类型提示 (Type Hints) 与 `mypy`**

事实证明，Python 是一种动态类型（dynamically typed）语言。也就是说，它不是强类型（strongly typed）的。当你想用一个 `int` 时，你不必告诉程序你正在使用 `int`。你不必告诉程序你正在使用 `str`、`float`、`set` 或其他任何类型。总的来说，到目前为止，你和我，当我们创建变量时，我们只是给变量一个名字。我们经常使用等号 `=` 给它赋一些其他值。老实说，Python 只是动态地判断出它是什么类型的变量。如果是 `"Hello, world"`，变量就是 `str`。如果是整数 `50`，变量就是 `int`。

现在，在其他语言中，包括 C、C++、Java 等，程序员有时需要指定你希望某个变量是什么类型。这样做的好处是它可以帮助你更容易地检测到 bug。因为如果你打算让一个变量存储字符串或整数，但你不小心存储了整数或字符串（相反的类型），或者完全是其他东西，你的语言可以为你检测到这种错误。例如，当你运行程序时，它会说：“不，你犯了个错误。” 你可以在你的实际用户发现之前修复它。

在 Python 中，这里也是一个更友好的环境，你可以向 Python 本身提供关于变量应该是什么类型的提示（hints）。但语言本身并不强制执行这些。相反，你可以使用一个工具来告诉你是否正确地使用了变量。但这通常是你作为程序员在实际发布代码给世界之前会运行的工具。或者如果你有某种自动化流程，你可以在实际发布代码之前运行这类工具，就像你可以用其他程序重新格式化或检查（lint）你的代码一样。

那么我们如何使用这些所谓的类型提示（type hints）呢？嗯，它们在通常的地方，Python 自己的文档中有记载。事实证明，有一个程序非常流行，用于检查你的代码是否遵守了你自己的类型提示。这个程序叫做 `mypy`。它只是其中之一，但这一个特别受欢迎，并且可以用通常的方式轻松安装：`pip install mypy`。它自己的文档在这个 URL。但我们将简单地用它来检查我们的变量是否确实使用了正确的类型。

那么我们该怎么做呢？好的，让我回到 VS Code，清空我的终端窗口，实际上删除当前的 `meows.py`。让我们实现一个不同版本的 `meows`，它只有一个名为 `meow` 的函数，负责在屏幕上实际执行喵喵叫。然后，我将在下面直接调用该函数。为了简单起见，我不会费心使用 `main` 函数，这样我们就可以像往常一样只关注新内容。

所以这里我们定义一个名为 `meow` 的函数。它将接受一个表示喵喵叫次数的数字，例如 `n` 代表 number。在这个函数内部，我将执行我通常的 `for _ in range(n): print("meow")`。根据我们之前的代码，我认为这是正确的。我没有费心将变量定义为 `i`。我改用下划线，因为我没有在任何地方使用它。但我认为我现在有了一个能工作的函数，其目的是喵喵叫零次、一次、两次、三次或更多次。

好吧，让我们使用这个函数，再次强调，不使用 `main`。我将把我的函数放在最顶部，因为只有一个。我将在第 6 行编写我的代码。所以我要——我要向用户询问一个数字。我将以通常的方式提示他们输入喵喵叫的次数。现在，我将用那个数字调用 `meow` 函数。

现在，你们中的一些人可能已经看到我哪里做错了。但也许我自己没有看到。所以让我进入我的终端窗口运行 `python meows.py`，目的是提示我。这似乎工作正常。我将输入 3。我现在期望 `meow` 函数打印出三次 "meow"。Enter。但是不行。这里有某种 `TypeError`。`str` 对象不能被解释为整数。

这可能是为什么呢？这可能是为什么？

**提问者：** 因为 `input` 函数返回的是字符串而不是整数。

**回答 (David Malan)：** 完全正确。`input` 函数返回一个字符串（`str`），而不是一个整数（`int`）。所以过去，我们解决这个问题的办法当然就是使用 `int()` 函数将字符串转换为整数。

但是现在，让我开始更具防御性地编程，这样老实说，我甚至根本不会遇到这种情况。让我这样做。让我给我的函数添加所谓的类型提示（type hint），明确指定 `meow` 函数应该传入什么类型的变量。我现在要修改我的代码和函数的第一行，指定 `n: int`，这是一个类型提示，我添加了冒号、空格和单词 `int` 这一事实并没有创建另一个 `int` 或类似的东西。这只是一个提示，一个注解（annotation），可以这么说，告诉 Python 左边的这个名为 `n` 的变量应该是一个 `int`。

现在，不幸的是，Python 本身并不在乎。因为再次强调，这些类型提示并没有被语言强制执行。这是设计使然。语言本身和社区更倾向于让 Python 保持动态类型，而不是强类型到要求这些必须为真。但如果我运行 `meows.py`，再次输入 3，同样的错误还在那里。

但是让我尝试一下这个 `mypy` 程序，一个能够理解类型提示的程序示例。如果我主动运行它，就可以在我的代码中发现像这样的 bug，在我（或者更糟的是，用户）实际运行并遇到像这里的 `TypeError` 这样神秘的东西之前。

让我清空我的终端窗口，这次运行 `mypy meows.py`。所以我将对我的程序运行 `mypy`，但我并没有运行 Python 本身。当我按下 Enter 时，我们会看到这个。好的。我们现在看到 `mypy` 显然在第 7 行发现了一个错误。错误：`meow` 的参数 1 类型不兼容，应为 `int`，实为 `str`。

所以它仍然是一个错误消息。但 `mypy` 不是我的用户会使用的程序。这是你和我作为程序员会使用的程序。因为我们现在在发布这个程序给世界之前运行了这段代码，我现在甚至在代码被调用或运行之前就能看到，哦，我似乎错误地使用了 `meow` 的参数。我最好以某种方式修复这个问题。

好吧，我实际上可以在提示中甚至为我自己的变量添加类型提示，以便以另一种方式捕获这个错误。如果我知道在第 6 行我已经创建了一个名为 `number` 的变量，并且我知道我已经将 `input` 的返回值赋给了它，我可以给 `mypy` 和类似的工具另一个提示，说：“你知道吗？这个名为 `number` 的变量也应该是一个 `int`。” 也就是说，如果我现在开始养成给所有变量和函数参数添加注解的习惯，也许 `mypy` 实际上可以帮助我在运行 Python 本身之前就很快地发现问题。

让我们再试一次。`mypy meows.py` 并按 Enter。这次，注意到 `mypy` 实际上更快地发现了错误。注意这次它在第 6 行发现了错误：类型不兼容，赋值表达式的类型是 `str`，变量的类型是 `int`。所以在我们调用 `meow` 之前，第 6 行通过这个类型提示，在被 `mypy` 使用和分析时，帮助我发现，“哦，等等。我一开始就不应该将 `input` 的返回值赋给我的 `number` 变量。” 为什么？`mypy` 刚刚向我指出，一个返回 `str`，我期望的是 `int`。让我现在修复这个问题。

所以让我清空我的终端窗口。现在让我做你们大多数人可能一开始就认为我经过这几周后应该做的事情。但是现在，让我将 `input` 的返回值转换为整数。为了今天的目的，我不会尝试捕获任何异常之类的。我们只假设用户正确地输入了。

现在，让我运行 `mypy meows.py`，不仅给我的函数参数、我的函数、以及下面第 6 行的变量添加了类型提示。而且我现在也修复了问题本身。让我运行 `mypy`。成功，在一个源文件中没有发现问题。

现在，对我来说，运行像 `python meows.py` 这样的命令就更合理了，并且相信当我输入 3 时，至少我不会得到 `TypeError`。也就是说，我作为程序员在变量类型方面没有搞砸。为什么？因为当我在一开始编写代码时，我提供了这些注解、这些提示，告知像 `mypy` 这样的工具，我的意图最好与实际代码的行为一致。

让我在这里暂停一下，看看现在关于类型提示或 `mypy` 是否有任何问题。

**提问：** 这些被使用的普遍程度如何？或者说，它只是更多地用于更复杂的代码中，在那些代码中更难确保你实际使用的变量类型是正确的吗？

**回答：** 这是个好问题。这更像是一个观点问题。Python 的设计初衷是在这些细节上更加通用和灵活，部分是为了可写性，使其更容易、更快地编写代码，部分是为了性能，这样像 Python 这样的程序就不必费心检查这些细节，我们可以直接进入代码。然而，现实情况是，强类型检查对于代码的正确性来说往往是件好事。为什么？因为像 `mypy` 这样的程序可以在你的代码甚至运行之前就发现已知存在的错误。这对于防御性编程往往是有利的。所以情况基本上是这样的，在 Python 生态系统中，你可以用这种方式注解你的类型。你可以使用工具来利用这些类型提示。但到目前为止，Python 本身并不强制执行或期望强制执行这些约定。在更大的代码库中，在专业的代码库中，商业代码库中，可能取决于项目经理或工程团队，他们很可能希望自己使用类型提示。为什么？如果它能降低 bug 的概率。

事实上，让我现在提出一个建议——想象一种情况，我不是期望 `meow` 打印出 "meow, meow, meow" 若干次，假设我不小心认为 `meow` 函数只是返回 "meow" 若干次。例如，当我们在关注单元测试时，我们看到，拥有返回值（无论是 `int` 还是 `string`）的函数，而不是仅仅产生像打印东西这样的副作用（side effect），通常是件好事。所以也许我还停留在那种思维模式中。我只是暂时错误地假设 `meow` 返回一个值，比如 "meow"，或 "meow meow"，或 "meow meow meow"，一个包含若干 "meow" 的大字符串，而不是像它目前在第 3 行那样清晰地只是打印它自己。

因此，假设我不小心做了类似这样的事情。与其只是获取数字并将其传递给 `meow`，假设我做了这个。假设我声明了一个名为 `meows` 的新变量，我认为它的类型应该是 `str`。再次假设，我不小心认为 `meow` 函数返回给我一个包含那些喵喵叫的字符串，这样我之后就可以自己打印它们。这可以说更有利于测试我的 `meow` 函数。为什么？因为我可以期望它返回 "meow"，或者 "meow meow"，或者 "meow meow meow"，用换行符分隔，返回一个 `str`，然后我可以在像单元测试这样的东西中断言它等于我期望的值。我现在不打算写任何单元测试。但让我们假设这就是我现在的心态。

所以在第 7 行，我假设我想将 `meow` 的返回值赋给一个名为 `meows` 的新变量，我用这个类型提示将其注解为 `str`，只是为了让我们看到另一个变量。这个不是 `int` 而是 `str`。

好吧，让我现在运行这段代码，`python meows.py`，Enter，输入 3。你会看到一个奇怪的 bug。"meow meow meow None"。

嗯，这是为什么呢？事实证明，目前，我的 `meow` 函数只有一个副作用。它只是打印出 "meow" 若干次。它没有显式地返回值，不像如果有 `return` 关键字那样。那么默认情况下，当 Python 中的函数没有显式返回值时，它的隐式返回值实际上是 `None`。所以我们在这里看到的是——在第 8 行，因为我将 `meow` 的返回值（即 `None`）赋给了我的 `meows` 变量，第 3 行仍然在打印 "meow meow meow"。而第 8 行现在错误地打印出了 `None`。因为我不小心认为 `meow` 返回一个值，但它没有。所以它的返回值实际上是 `None`。所以我很奇怪地在底部打印出了单词 `None`。

那么我该如何捕捉这种错误呢？我可能会犯这个错误。但如果我养成了用这个新特性——类型提示——来注解我的代码的习惯，也许犯这种错误的频率会降低。

你可以这样做。让我清空我的终端窗口以消除那个残留物。在上面这里，让我另外用一些看起来有点奇怪的语法指定我的 `meow` 函数实际上按设计返回 `None`。所以你确实使用这种箭头符号 `->`。在 Python 中提示函数的返回值时，你会这样做。在括号后面，一个空格，一个连字符，一个大于号，像一个箭头，然后另一个空格，然后是返回值的类型。目前，它确实会——[吞咽声]不好意思——返回 `None`。

但现在，至少我可以这样捕捉它。如果我现在运行的不是 Python 而是 `mypy` 来检查我的代码——如果使用类型提示，这将是我现在养成的一个习惯。在我运行程序之前检查我是否正确使用了所有类型。我们会看到现在 `mypy` 在第 7 行发现了 `meow`，引号引起来，“不返回值”。`mypy` 知道这一点，因为我已经主动地将我的 `meow` 函数注解为返回值为 `None`。所以现在 `mypy` 可以检测到。我现在应该意识到，“哦，等等。我在这里犯傻了。`meow` 显然不返回值。” 我不应该在第 7 行像它返回值那样对待它。让我现在实际修复这个问题。

那么我该如何修复呢？好吧，让我们实践我们在关注单元测试时所宣扬的，让像 `meow` 这样的函数没有像打印自身的副作用。而是让它返回实际的字符串。我实际上可以很简洁地做到这一点。让我清空我终端窗口中的错误信息。让我去掉这里的循环。这次让我说，好吧，`meow` 将返回一个值，一个实际的 `str` 或字符串。所以我把 `None` 改成了 `str`。

现在，我可以用很多种方式来实现它，甚至可能使用循环。但回想一下，我们在 Python 中有这种语法，我认为它能为我们解决这个问题。如果我想返回一个包含 n 个 "meow" 的字符串，我实际上可以这样做，回想一下：`return "meow\n" * n`。这是一种巧妙的单行代码，避免了使用 `for` 循环或更复杂的东西，只是说，将 "meow\n" 乘以自身三次，或者 n 次，在这种情况下，通常是这样，这样我就能得到一个包含零个、一个、两个、三个或更多 "meow" 的大字符串。

我想现在我第 6 行的代码实际上是正确的。我现在已经改变了 `meow` 的行为，让它像我假装一直认为的那样工作。所以我将结果存储在复数 `meows` 这个 `str` 类型的变量中。因为现在，`meow` 函数确实有一个 `str` 类型的返回值，根据这个类型提示也是如此。

好的。让我现在打印 `meows`。但是因为我的每个 "meow" 都带有一个尾随的换行符 `\n`，我将主动修复一个小的美观 bug。我只是避免在那三个 "meow" 的末尾输出一个额外的换行符，通过 `print(meows, end="")`。所以如果我现在运行 `python meows.py`，输入 3，这就是我的 "meow meow meow"。现在没有提到 `None` 了。

现在对类型提示、这些注解和 `mypy`，以及使用它们来防御性地编写代码，从而有望降低你自己 bug 的概率，有任何问题吗？

**提问：** 返回语句第三行有双引号包含 `meow \n`，为什么程序不把它当作 [字符串？]？（注：提问者可能想问为什么可以做乘法）

**回答：** 为什么程序不把它当作——奇怪的？

**提问者：** [听不清]，是的。

**回答：** 回想一下，在课程早期，我们看到 `+` 作为连接运算符，允许你连接左右两边的字符串。乘法 `*` 对于字符串来说也是一个重载（overloaded）的运算符。如果你左边有一个字符串，右边有一个 `int`，它会“乘以”这个字符串，可以这么说，通过连接或拼接那么多个 "meow" 在一起。所以这是面向对象编程和我们过去看到的运算符重载（operator overloading）的一个特性。

**提问：** 关于类型提示或 `mypy` 的其他问题？我们不能对这个变量 `number` 的数据类型进行类型转换（typecast）吗？

**回答：** 不行。你仍然——让我纠正一下术语。在这种情况下，它不被称为类型转换（typecasting），因为它不像 C 或 C++ 那样在这些类型之间存在等价性。你实际上是在第 5 行将一个 `str` *转换*（converting）为一个 `int`。你仍然必须这样做。因为例如，`mypy` 会在你试图将右边的 `str` 赋给左边的 `int` 时向你报错。你必须仍然使用 `int()` 函数。`int` 本身仍然是一个函数。它不是类型提示。但是单词 `int` 现在在这些类型提示中以另一种方式被使用。所以这个 `int()` 仍然是一个函数调用，就像它一直以来那样。左边的 `n: int` 语法是关键字 `int` 的另一种用法，但是以类型提示的形式。所以你仍然必须自己进行转换。

## **六、 文档字符串 (Docstrings)**

好的。让我建议我们过渡到 Python 的另一个值得了解的特性，特别是因为当你看别人编写的代码或库时，你会看到它，即所谓的文档字符串（docstring 或 document strings）。

事实证明，在 Python 的世界里，根据另一个 PEP（Python Enhancement Proposal），即 PEP 257，有一种标准化的方式，它基本上标准化了你应该如何为你的函数（以及代码的其他方面）编写文档。

例如，让我回到我的 `meows.py` 文件。让我建议我们现在也开始为这段代码编写文档，这样我就知道 `meow` 函数是做什么的。事实上，使用文档字符串表示法的标准方法如下：

要注释这个函数，不是在它上面，像你通常习惯于对普通代码做的那样使用 `#` 注释符，比如 `# meow n times`，而是实际上在它的 *内部*。但不是像这样使用普通的哈希注释符号。事实证明，当你正式地为像 `meow` 这样的函数编写文档时，你不使用所谓的常规内联注释。你改用这种语法。你使用三个引号，可以是双引号或单引号。然后你写出你的注释，`Meow n times.`。然后在末尾再次写上相同的三个引号。所以要么是开头和结尾各三个双引号，要么是开头和结尾各三个单引号。

Python 内置了某些工具和某些假设，如果它检测到使用这种文档字符串格式（左右各三个引号）的注释，它会假定那确实是该函数的文档。事实证明，在 Python 生态系统中，有很多工具你可以用来自动分析你的代码，为你提取所有这些文档字符串，甚至为你的函数生成网页或 PDF 文档。所以存在这些约定，如果你遵守它们，你就可以开始为其他人编写代码文档，通过从你自己的代码中自动生成文档，而无需手动从头开始编写。

现在，事实证明，如果你的函数确实接受参数，并且可能做更多的事情，有多种约定可以用来标准化文档字符串中的信息，以便可能使用你的函数的人类程序员（无论是你自己、同事还是互联网上的其他人）能够理解。

所以你可能会看到这样的写法。仍然使用上下各三个引号，你可能会看到你对函数的一句话解释，`Meows n times.`。有时根据风格和用途，它可能仍然在第一行，但下面有一行空行。但我将保持所有内容统一缩进。这也是一些流行的 Python 文档工具使用的约定。你会使用类似这样的语法：

```python
"""Meows n times.

:param n: Number of times to meow
:type n: int
:raises TypeError: If n is not an int
:return: A string of n meows, one per line
:rtype: str
"""
```

`:param n: description`，然后是 `n` 是什么的描述，`Number of times to meow`。然后 `:type n: int`，这只是表明 `n` 的类型是整数。

然后，如果这个函数实际上可能引发异常，你也可以记录下来。实际上，这不完全是——好吧，可以说这是我的错。如果 `n` 作为参数传入，但实际上不是 `int`，也许是 `float`、`string` 或其他东西，这里的乘法符号 `*` 将无法工作。它不会乘以字符串。它会触发我知道根据经验是 `TypeError` 的错误。所以我将主动在我的文档中说明，这个函数，从技术上讲，如果你使用不当，可能会引发 `TypeError`，即使我在这里上面用这个注解提示你应该传入一个 `int`。再次强调，Python 不强制执行这一点。所以如果你传入一个 `float`，这个函数实际上可能会引发 `TypeError`。所以这可能发生在 `If n is not an int` 的情况下。

然后，最后，为了清晰起见，为了其他程序员，我可能会说，这个函数 `return` 一个包含 n 个喵喵叫的字符串，每行一个。而那个值的返回类型（`:rtype:`）将是 `str`。

现在，我在这里使用的所有这些语法本身并不是 Python。这是一种被称为 reStructuredText 的约定，它是一种类似 Markdown 的语言形式，用于文档、网站、博客等等。但它是 Python 世界中记录你自己函数的流行约定之一。

所以这与类型提示从根本上没有任何关系。类型提示是 Python 的一个特性。我在这里所做的只是遵守一个第三方约定，即在 Python 文档字符串的开始和结束之间放入某种标准格式，以便这些第三方工具可以为我从上到下、从左到右地分析我的代码，并理想地为我生成文档。它可以生成 PDF、网页或其他东西，这样我或我的同事就不需要不仅编写代码，还要手动为我们的代码创建文档。我们可以将所有内容放在一起，并使用工具为我们生成文档。

现在对这些文档字符串有任何问题吗？这再次强调是记录你自己代码的一种约定，通常遵循一些标准语法。

**提问：** 是的。所以当你说你会记录它并把它放到 PDF 中，这样做的目的是发布它并分享你的函数，以便其他用户可以使用它吗？

**回答：** 当然。过去，当我们安装一些第三方库时，例如几周前的 `cowsay`。回想一下，我向你们展示了它有哪些函数。但如果你阅读文档，你可能实际上会看到它是由那个程序的作者为我们记录的。现在，我不相信他们使用了这种特定的语法。但对于你和我来说，能够阅读一些网页或 PDF 来告诉我们如何使用这个库，而不是浪费时间阅读别人的代码并试图推断存在哪些函数以及如何使用它们，这绝对是有用的。为我们自己的代码或库提供适当的文档，往往对开发者更友好。

**提问：** 其他问题？是的。使用文档字符串时，当它被用来生成 PDF 或其他东西时，它会包含任何代码吗？所以如果你在你的注释中引用代码，如果在注释本身中引用代码，而没有看到代码可能没有意义。这些工具会包含代码吗？

**回答：** 简短的回答是，你可以这样做。不是在我这里使用的约定中。但实际上有一种聪明的方法可以在你的文档字符串中写入函数的示例输入和示例输出。如果你使用我们没有讨论过的另一个工具，那个工具将使用那些示例输入运行你的代码。它会检查你的输出是否与你的示例输出匹配。如果不匹配，程序会向你报错，说：“你某个地方有 bug。” 所以这只是另一种方式，你可以使用文档字符串不仅来记录，甚至来捕捉你代码中的错误。

这已经很多了。还有一些内容要讲。我们为什么不在这里休息五分钟呢？当我们回来时，我们将看看 Python 的另一个特性，另一个能更快编写代码的库。

[休息]

## **七、 `argparse` 模块**

好的。假设我们想修改这个 `meows` 程序，让它实际接收输入不是来自闪烁提示符的 `input` 函数，而是来自命令行。回想一下在我们讨论库时，你可以使用像 `sys.argv` 这样的东西来获取人类用户在运行你的程序时提供的命令行参数。那么我们为什么不快速编写一个使用命令行参数而不是 `input` 的 `meow` 版本呢？

所以，我将删除我们到目前为止所做的。让我建议我们像过去那样导入 `sys`。让我们这样做。如果用户没有输入任何命令行参数怎么办？那么我的程序就只喵一声，只是为了让它在视觉上做一些有趣的事情。否则，让我们也给用户一个选项来指定我希望猫喵多少次。

让我们从简单的开始。首先，让我们这样做。如果 `len(sys.argv)` 等于 1，也就是说用户只输入了程序名，在他们的命令中程序名之后没有任何其他内容，那么让我们就打印一声喵喵叫。否则，现在，让我们打印出类似这样的东西。否则，打印出程序的用法（usage），这将是 `usage: meows.py`，只是为了让用户知道程序本身叫做 `meows.py`。

现在让我到我的终端窗口开始输入 `python meows.py`。在这一点上，注意到 `len(sys.argv)` 确实应该是 1。为什么？嗯，`python` 这个名字根本不会出现在 `sys.argv` 中。但是 `meows.py`，这个文件名会。它将进入 `sys.argv[0]`。但这只有一个元素。所以这个东西的长度是 1。右边没有更多东西了。所以当我按下 Enter 时，我们应该确实看到一声喵喵叫。

如果我不配合，假设我做了类似 `meows 3` Enter 的操作。那么我将看到一个提醒，说明如何使用这个程序。打印出单词 `usage`、一个冒号、然后是程序名，也许还有一些如何使用它的解释，这是一种常见的约定。所以我保持得很简单。

但让我们更花哨一点。如果我真的希望用户输入的可能不是 3，而是更复杂的东西呢？事实上，在从命令行控制程序时，提供所谓的开关（switches）或标志（flags）是非常普遍的，你会传入像 `-n` 这样的东西，语义上表示“这个次数”，然后通常是一个空格，然后是像数字 3 这样的东西。这仍然允许我在命令行做其他事情，如果我愿意的话。但是我标准化了向这个程序提供命令行参数的方式，使用 `-n 3`，这只是让我的程序知道 3 是什么意思的一种更可靠的方式。如果我只是执行 `meows.py 3`，那么 3 的含义就不那么明显了。至少使用像 `-n 3` 这样的语法，特别是如果你最终阅读了这个程序的文档，“哦，`-n` 表示次数。明白了。” 这是一种传入两个额外参数但它们之间有某种关系的方式。

那么我如何修改我的程序来理解 `-n 3` 呢？好吧，如果我像这样使用 `sys`，我可以这样做。`elif len(sys.argv) == 3:`。因为注意，在我的提示符下有 1、2、3 个东西。所以 `sys.argv` 是 0、1 和 2，总共三个由空格分隔的东西。如果它等于 3——并且为了安全起见，`and sys.argv[1] == "-n"`，那么让我们这样做。让我们将 `sys.argv[2]` 转换为整数，并将其赋给一个变量，例如叫做 `n`。然后，让我们这样做。`for _ in range(n):` 让我们打印出一些喵喵叫。现在，也许仍然有机会用 `meow` 来整合我的打印行。但现在，我将把这些想法分开。所以，我将像之前一样处理没有参数的默认情况。

现在，更有趣的是，我将这样做以明确。我将检查用户是否给了我三个命令行参数：程序名、`-n` 和一个数字。如果他们给我的第二个东西，在 `sys.argv[1]` 中，确实等于 `-n`，那么我将假设下一个东西，`sys.argv[2]`，将是一个整数。我将把它转换成整数并存储在这个变量 `n` 中。现在，只使用一个循环，我将打印出那么多次 "meow"。

好的，所以这有点像是我们早期关注循环、早期关注命令行参数的结合，只是创建了一个程序，我可以声称它代表了很多命令行程序的工作方式，即使我们通常没有使用很多像这样的。但是在命令行用像 `-n` 或 `-其他东西` 这样的命令行参数来配置你即将运行的程序，这是非常常见的。

现在，我将按下 Enter。我想我应该看到，确实是三声喵喵叫。相比之下，如果我在末尾输入 2，我应该看到两声喵喵叫。如果我输入 1，我应该看到一声喵喵叫。坦率地说，如果我完全省略这个，我也应该看到一声喵喵叫，因为那是我之前的默认情况。

现在，让我们假设这个程序最终变得更加复杂。让我们想象一个世界，我不想只支持 `-n`。也许我想支持 `-a`, `-b`, `-c`, `-d`，以及一大堆其他的。或者，到那时，我也许应该给它们单词。所以也许是 `--number`。在计算中，通常的约定是使用单破折号加单个字母，如 `n`，但如果你实际使用一个完整的单词如 `number`，则使用双破折号。所以命令行参数可能是 `-n`，或者也许是 `--number`。但你可以想象，如果现在你想支持 `-n`, `-a`, `-b`, `-c` 等等，代码会变得多么复杂。你将不得不到处检查。如果它们以不同的顺序出现怎么办？你将不得不检查 `-n` 是第一个，还是第二个，还是第三个，还是第四个？我的意思是，仅仅为了做一些相对简单的事情，比如允许用户将命令行参数传递给你的程序，这就很快变得非常痛苦。

嗯，这就是为什么，一如既往地，存在库。另一个 Python 自带的、可能值得了解的库是这个叫做 `argparse` 的库。事实上，对于我自己或 CS50 团队用 Python 编写的许多工具，只要它们比我们课堂上的许多演示更复杂一点，并且更类似于这个我们想允许用户在命令行传入配置选项的情况，我们就非常频繁地使用 `argparse`。通过支持像 `-n` 或 `-a` 或 `-b` 或 `-c` 这样的东西，`argparse` 是一个库，根据它的文档，它会自动为你处理所有这些所谓的解析（parsing），即命令行参数的分析，这样你就可以专注于编写你程序的有趣部分，而不是命令行参数部分。

那么我们该如何使用它呢？好吧，让我回到 VS Code。让我清空我的终端窗口。让我建议我重写这个，不使用 `sys`，而是实际使用 `argparse`。我将从简单一点开始，然后逐步构建。

所以让我暂时扔掉所有这些，转而导入 `argparse`。`Argparse` 代表参数解析器（argument parser）。解析（parse）某物意味着读取它，有点像把它拆开来分析它。所以这确实会为我做这些。

现在，让我这样做。对于这个库，了解一点我们现在都会的面向对象编程是有帮助的。我将创建一个名为 `parser` 的变量。虽然我可以叫它任何我想要的名字。我将把它设置为 `argparse.ArgumentParser()` 的返回值，其中 A 和 P 大写。这是 Python 自带的、在这个库中的一个名为 `ArgumentParser` 的类的构造函数。

现在，我将配置这个参数解析器，让它知道我自己想在我的程序中支持的特定命令行参数。我将这样做：`parser.add_argument("-n")`。所以这显然是 `parser` 对象中的一个方法。我将添加一个 `-n` 参数。足够简单。

现在我将实际解析命令行参数。我将执行 `args = parser.parse_args()`，或者我可以给这个变量起任何我想要的名字。默认情况下，`parse_args` 会自动为我查看 `sys.argv`。我不需要自己导入 `sys`。我可以让参数解析器，它的代码去导入 `sys`，查看 `sys.argv`，并找出 `-n` 或其他任何东西实际在哪里。

现在的好处是，因为这行代码导致解析器解析了所有的命令行参数，我现在在这个名为 `args` 的变量中有了这个对象，里面包含了所有这些命令行参数的值，无论它们以什么顺序出现。当我只有一个参数时，这没什么大不了，因为它最终只会去一个地方。但如果我有 `-n`, `-a`, `-b`, `-c`，你可以想象它们会以各种不同的顺序出现。它们绝对不必按字母顺序排列。用户应该能够以他们想要的任何顺序输入它们。这对可用性更好。`Argparser` 会为我解决所有这些问题。

我现在需要做的就是这个。如果我想迭代那么多个参数对应的喵喵叫次数，我可以这样做：`for _ in range(int(args.n)):`。点 `.` 是我们一直用来访问对象内部属性（如 properties）的语法。而 `args` 就是这样一个对象。它是 `parse_args` 函数为我返回的对象。我现在将打印出 "meow" 这么多次。

所以它不是超级简单。这是我需要编写和理解的三行新代码。但它已经比我的 `if`、`elif`、`or`、`and` 以及所有那些布尔逻辑更简单、更紧凑了。它为我处理了很多事情。

所以，如果我没有犯任何错误，让我现在运行 `python meows.py` Enter。我确实犯了一个错误。这里出了什么问题？什么错了？嗯，我肯定没有按照我打算的方式运行它。所以 `-n 3` Enter。所以它确实有效。但如果我不配合，这实际上似乎是一个更糟糕的版本。如果我不传入 `-n` 和一个数字，它就会因为 `TypeError` 而出错。`int()` 的参数必须是字符串、类字节对象或实数，而不是 'NoneType'。`None` 是返回的结果。所以这里显然有一个错误。

但是这个库更灵活。我实际上可以提供一些关于如何使用这个东西的文档。那么我怎么知道如何使用它呢？嗯，通常在 Python 和许多编程环境中，惯例是用一个特殊的参数 `-h` 或 `--help` 来运行程序。我敢说，几乎总是你会看到某种用法信息。事实上，这就是我现在看到的。我刚刚运行了 `python meows.py -h`。我再做一次。让我清屏，这次用英文的 `--help`，Enter。我看到了同样的东西。

目前它不是很有用。它只在上面显示了用法是什么。这有点有趣。这是计算中的标准语法。我们在 Python 的文档中也见过类似的东西。这只是意味着程序的名字当然是 `meows.py`。方括号，在文档中几乎总是意味着它是可选的。所以我不需要输入 `-h`，但我可以。我不需要输入 `-n` 和另一个值，但我可以。然后，下面是对这些选项的一些解释，更详细地告诉我也可以用 `--help` 而不仅仅是 `-h`。但这太通用了。这与我的程序无关。当我实际将这个软件发布给世界时，这对我的用户没有帮助。

所以让我来改进它。让我给我的参数解析器添加一个人类用户会看到的描述（description）。`description="Meow like a cat"` 将是这个名为 `description` 的命名参数的值。让我再给我的 `-n` 参数添加一个 `help` 参数，只是解释一下 `-n` 的意思，`help="Number of times to meow"`。我不会改变其他任何东西。但我将回到我的终端窗口运行 `python meow...` 我将运行 `python meows.py -h`，或者等效地 `--help`。现在注意到这个更用户友好了。如果我向上滚动，我们仍然看到相同的用法。但是有一句简短的英文解释，说这个程序像猫一样喵喵叫。如果我现在看选项，哦，这就是 `n` 的意思。它是喵喵叫的次数。而这个大写的 N，一个元变量（mental variable），如果你愿意这么称呼它的话，只是向我表明，按照惯例，我需要在小写的 `-n` 后面输入一个数字。

所以，尽管如此，如果我的程序在我没有任何命令行参数的情况下运行时仍然不仅仅是崩溃，那就好了。理想情况下，我的程序应该像我手动使用 `sys.argv` 的版本那样处理这种情况。所以我们只需要给这个库添加一点点更多的功能。如果我阅读文档，我会看到 `add_argument` 接受另一个命名参数。如果你愿意，你可以为 `-n` 指定一个默认值（`default`），例如 1。我将在这里这样做。你还可以进一步指定它必须是一个 `int` (`type=int`)。这还会带来额外的好处，如果我告诉 `argparse` 确保 `-n` 的值是一个 `int`，我就不需要手动进行转换了。我可以相信在第 7 行，当我访问我的 `args` 对象内部名为 `n` 的属性时，它会自动为我变成一个 `int`。

再次强调，这就是库的价值所在。让它为你做所有的工作，这样你就可以回到手头有趣的项，无论你试图解决什么问题。在这种情况下，诚然，不是那么有趣，但像猫一样喵喵叫。

让我现在运行 `python meows.py` 并按 Enter。这次没有任何参数。现在它喵喵叫了。为什么？因为我指定了如果我作为用户不指定 `-n`，它显然会有一个默认值 1。而且我不需要将该值从 `str` 转换为 `int`，因为我告诉了 `argparse` 请直接为我把它变成 `int`。

现在对 `argparse` 或者说这个原则——即将那些商品化的东西，那些每个人程序最终都需要做的东西外包出去，这样你就可以专注于你自己项目中有趣的部分——有任何问题吗？

**提问：** `args.n` 包含什么？

**回答：** `args.n` 包含什么？它包含人类用户在 `-n` 后面的空格后输入的那个整数。好问题。

**提问：** 其他问题？是的。当你为参数指定类型时，如果——这基本上是否处理了用户在这种情况下输入字符串的异常？

**回答：** 一个非常好的问题。假设人类用户没有输入数字，因此不是 `int`。好吧，让我们看看会发生什么。所以 `python meows.py -n dog`，其中 `dog` 显然不是一个数字。Enter。瞧，我们看到了一个自动生成的错误消息。有点神秘，我承认。但我看到了用法的提醒和关于这个无效之处的简要解释。再次强调，这就是允许你，允许我专注于编写我们关心的实际代码，而让库为我们自动化处理其中一些事情的原因。

## **八、 解包 (Unpacking)**

好的。好吧，允许我现在建议我们看看 Python 的另一个我们以前见过的特性。但事实证明，随着我们的程序变得更加复杂，我们试图解决的问题本身也变得更加复杂，我们可以更强大地使用它。

让我转到 VS Code，关闭 `meows.py`，并创建一个新文件，例如叫做 `unpack.py`。所以 `code unpack.py`。让我提醒一下我们所说的解包（unpacking）是什么意思。因为这实际上是我们以前见过的 Python 特性。

例如，假设我编写一个程序，提示用户输入他们的名字，比如 "David Malan"。如果我们可以将用户的名字拆分成两个独立的变量，那不是很好吗？我们过去做这个的时候用了几种不同的方法。但其中一种涉及解包从某个操作返回的单个值，比如一个列表或其他数据结构，并立即将其放入两个变量中。

让我们在这里做一下。让我调用 `input` 函数，问别人 "What's your name?"。然后，让我稍微天真地用单个空格进行分割（`split(' ')`）。所以我假设目前唯一的用户是像我这样的人，David 空格 Malan。没有中间名，没有多个名字。只有一个姓和一个名，这本身对其他用户来说可能是有 bug 的。但现在，为了简单起见，只是为了提醒我们，我现在可以用类似 `first, _ = ...` 的方式解包那个返回值。

现在我可以做类似这样的事情，比如用 f-string 打印出 "Hello, " 然后在花括号里是 `first`。如果我只想问候我自己或任何其他用户为 "Hello, David"，不带姓氏。坦率地说，如果我没有使用姓氏，回想一下，Python 的约定是直接将其命名为下划线 `_`，以明确表示你没有使用那个值。但它确实需要存在，因为你一次性解包了两个值。

所以如果我运行这个，它不会太陌生。我现在就运行 `python unpack.py`。我会输入 "David Malan"，它有一个空格。好了，"Hello, David"。

好吧，事实证明，还有其他解包值的方法。还有 Python 提供的其他特性，尤其是在定义和使用函数方面。这稍微更中级一些的功能，如果你愿意这么说的话，它很有用，因为一旦你熟悉了像这样的语法，你就可以开始编写更优雅、更强大的代码。

所以让我建议我们不再只是玩弄 "Hello names" 了，而是做一些可能再次涉及到一些货币的事情。所以也许不是美元和美分，但也许，像过去一样，是一些加隆（galleons）、西可（sickles）和纳特（knuts），它们之间存在数学关系，说明在魔法世界中多少个这些货币彼此相等。

让我这样做。让我定义一个简单的函数 `total`，它只告诉我某人在古灵阁（Gringotts，魔法世界的银行）金库的总价值，基于他们拥有的加隆、西可和纳特的数量，这再次是魔法世界的货币，而不是我们实际人类世界的。所以这个 `total` 函数可能接受像 `galleons`、`sickles` 和 `knuts` 这样的变量。然后它将返回公式，我承认这个公式是我自己查的。事实证明，将加隆和西可转换为纳特的公式是这样的：$galleons \times 17 + sickles$，然后将所有这些乘以 29，最后再加上单独的纳特：$(galleons \times 17 + sickles) \times 29 + knuts$。不确定这在书或电影中是以多详细的方式出现的。但我们有了官方公式。

好的。现在让我们这样做。让我用一些示例输入调用 `total` 函数。假设像哈利这样的人有 100 加隆，50 西可和 25 纳特。让我在屏幕上打印出来。好吧，如果 `total` 返回一个整数，我想这个算术表达式会这样做，那么让我将 `total` 的返回值传递给 `print`。然后为了清晰起见，让我在末尾写上 `knuts`。这样我就知道这里的度量单位确实是总纳特数。

现在，让我在我的终端窗口运行 `python unpack.py` 并按 Enter。事实证明，数学上，如果我的计算正确，100 加隆加 50 西可加 25 纳特总共等于 50,775 纳特。只是避免使用我们自己的人类货币。但我至少目前还没有做任何类似解包的事情。

现在让我建议我这样做。只是为了讨论起见，让我建议我保持 `total` 函数不变。但让我把我的所有硬币存储在一个列表中。所以 `coins` 按从左到右的顺序是 `[100, 50, 25]`，只是因为在这个故事中，出于某种原因，我所有的硬币都按这个顺序放在一个列表中。有点像一个钱包。

那么我该如何传入这个呢？好吧，我不会两次硬编码相同的值。只是为了讨论起见，我该如何将列表的各个元素传递给我的 `total` 函数呢？嗯，当然，我可以像往常一样使用数字索引来处理这个列表，通过 `coins[0]`, `coins[1]`, `coins[2]`。这是列表的老式用法。如果我有一个名为 `coins` 的列表，并且里面有三个元素，那么这些元素的索引分别是 0、1 和 2，从左到右。所以我现在在这里做的只是将列表中的第一个元素作为 `galleons` 传入，列表中的第二个元素作为 `sickles` 传入，列表中的第三个元素作为我的 `knuts` 传入。这当然与这个函数的签名相符，`total` 函数期望我按那个顺序从左到右传入这三个东西。

让我运行一下，只是为了确保我没有破坏任何东西，`unpack.py` 并按 Enter。数学计算仍然正确。但这有点冗长——有点冗长。如果我能直接把 `coins` 列表传递给这个 `total` 函数，那不是很好吗？如果我能只说类似 `total(coins)` 这样的话，那不是很好吗？

但让我暂停一下，问问大家，为什么这样做实际上行不通？从技术上讲，它确实传入了所有三个值。但为什么当我运行这个时，我会得到某种错误？

**提问者 (Eric)：** 因为你正在把一个列表传递给 `galleons`。

**回答 (David Malan)：** 是的。我正在把一个列表传递给 `galleons`，而没有给 `sickles` 和 `knuts` 任何东西。并且注意，那些没有默认值。代码的第一行没有等号，这意味着 Python 不会知道那里应该假设什么值。所以看起来它就是行不通。另外，正如 Eric 指出的，类型也错了。它是一个列表，而不是像之前那样的整数。

所以让我们实际运行这个不正确的版本，`python unpack.py` Enter，`TypeError`。这可能是你所期望的，就像我在这里搞砸了类型一样。并且我被要求传入两个位置参数，`sickles` 和 `knuts`，它们甚至没有被传入。所以我在这里肯定出错了。

但这当然似乎很不幸，如果唯一的解决方案是做我之前做的事情，即索引到第一个元素，索引到第二个元素，索引到第三个元素。你可以想象，对于接受更多参数的更大、更复杂的函数，这将变得非常冗长，老实说，也很容易出错，可能只是我打字错误。

但这里也是你可以做所谓的，再次强调，在 Python 中解包（unpacking）一个值的地方。现在，一个列表被打包了多个值。我当前的列表有这三个值，分别是 100、50 和 25。但它们都被打包在这个列表中。如果我能解包那个列表，就像我之前解包 `str` 类的 `split` 函数的返回值到多个东西中一样，那不是很好吗？

事实上，我确实可以做到。Python 实际上允许我传入的不是 `coins`，而是 `*coins`。所以如果你在你的变量前面使用单个星号 `*`，那将解包它。它将取一个序列，在这种情况下是大小为 3 的 `coins`，并将其“爆炸”（explode），如果你愿意这么说的话，解包成三个独立的参数。不需要逗号。Python 会为你处理这个。但是传入 `*coins` 的效果是传入该列表的各个成员。在这种情况下，它们将分别是 100、50 和 25。这很完美，因为现在它将分别与 `galleons`, `sickles`, `knuts` 对齐。

所以现在当我运行 `python unpack.py` 时，我们又回到了正轨，数学计算也正确。但我通过引入这个新符号（我们当然在其他上下文中用于乘法等）清理了我的代码。但现在，它也用于以这种方式进行解包。

关于我们刚刚做的有什么问题吗？这是一个单一的操作符，但它已经相当强大了。因为它允许我们获取一个数据结构并将其解包，然后单独传入。

**提问：** 这对元组（tuples）、集合（sets）、字典（dicts）也适用吗？

**回答：** 元组，是的。集合，我不知道。[问旁边人 Ranshin？] 我不知道顺序是否保留。不。哦，那是不行，还是你在查？顺序不保留。所以它对集合不起作用？它对集合不起作用。对不起，我在这里口头谷歌了一下，只是为了节省我们一些击键次数。所以它适用于顺序确实被保留的枚举类型。我们稍后会看到另一个例子，它实际上可以以不同的方式用于字典，字典现在确实保留顺序。

**提问：** 关于以这种方式解包的其他问题？是的。你好。

**回答：** 你好。

**提问：** 你能用解包来获取值，例如 10 加 50 加 25，而不是用 for 循环然后结果相加吗？

**回答：** 简短回答，不行。如果你想要单个值，你应该像在这种情况下那样，直接索引到那些特定的位置。这里返回的是多个值，相当于一个逗号分隔的列表。所以如果你关心单个位置，你会使用之前的方法。

**提问：** 关于解包还有一个问题？如果我们已经声明了——我们声明了一些默认值。如果你用这个作为两个点（注：可能指列表只有两个元素），它会报错，还是会跳过它？

**回答：** 好问题。如果我没听错的话，比如说，列表有四个值，像这样，而你仍然在解包它，但函数只期望三个。好吧，让我们试试。`python unpack.py` Enter。又一个 `TypeError`。这次它需要 3 个位置参数，但给出了 4 个。所以在这种情况下，责任在于我们程序员不要这样做。所以可能很脆弱，但如果我能控制这个列表的内容，那是可以避免的。

事实上，让我现在建议我们看看这个的另一个变体。我们不仅仅使用位置参数，即我们相信第一个是 `galleons`，第二个是 `sickles`，第三个是 `knuts`。假设我们实际上像在 Python 中允许的那样传入了名称。那么，从技术上讲，我们可以以任何顺序传入它们，Python 会使用命名参数（named parameters）来解决这个问题。

那么我该怎么做呢？好吧，起初会有点倒退。所以让我去掉这里的列表。让我现在把它改成手动传入我关心的值。`galleons` 我仍然希望等于 100。`sickles` 我希望等于 50。而 `knuts` 我希望等于 25。这是老式的参数传递。它不再是位置性的。我明确指定了这些参数的名称。但这能行，因为这正是我 `total` 函数中这些参数的名称，和之前一样。

让我们确保，尽管如此，我没有破坏任何东西。让我们运行 `python unpack.py` Enter。好了，仍然是 50,775 纳特。

好吧，一旦你开始给事物命名和赋值，命名和赋值，这可能应该让你想到我们在 Python 甚至其他语言中最通用的数据结构之一，即字典（dictionary）。记住，字典只是一系列键值对（key-value pairs）的集合，名称及其各自的值。

所以这有点打开了一个机会。如果我这样做呢？如果出于某种原因，在我的程序中，我有一个像之前那样名为 `coins` 的变量。但不是像之前那样让它成为一个包含三个值的列表，如果它是一个合适的字典呢？所以如果它是 `{"galleons": 100, "sickles": 50, "knuts": 25}`，每个键值对用冒号分隔。让我把我的方括号改成这次是花括号 `{}`，回想一下，这是我们在 Python 中用于字典或 `dict` 对象的符号。

所以现在，我有一个名为 `coins` 的字典。不是列表。它是一个键和值的集合，三个键：`galleons`, `sickles`, `knuts`，和三个值：分别是 100, 50 和 25。如果我现在要将这些单独的值传入我的 `total` 函数，我可以像往常一样用我的字典来做。所以我现在用老式的方法。`coins` 是我字典的名字。我索引它不是用数字（像列表那样），而是用单词。所以 `coins["galleons"]`，`coins["sickles"]`，以及最后，`coins["knuts"]`。这又变得冗长了。这可能不是最好的方法。但我们稍后会回溯。这只是，如果你碰巧把所有的硬币都存储在一个字典里，你如何将 `galleons`, `sickles`, `knuts` 分别传入你的函数。

让我们确保我没有破坏任何东西。让我们重新运行 `python unpack.py`，我们仍然没问题。

现在，我们怎么会遇到这种情况呢？好吧，像往常一样，想象这个程序比这里的这个稍微长一点。不知何故你正在使用字典，也许只是为了跟踪某人的钱包，比如他们每种类型的硬币有多少。因此，使用字典是完全合理的。但是然后你想打印出总数。该死。如果那个 `total` 函数不接受字典，所以你不能只是做一些像传入 `coins` 这样简单好用的事情。出于我们之前看到的原因，那会导致 `TypeError`。`total` 函数期望三个参数，三个整数。你不能直接传入一个字典。但如果那是你用来存储那个人钱包的数据结构，好吧，我们数据类型之间存在这种冲突有点不幸。

好吧，这是我们可以做的。我们不能传入 `coins`。因为看，如果我尝试这样做并运行 `python unpack.py`，我们会得到另一个 `TypeError`。缺少两个必需的位置参数：`sickles` 和 `knuts`。我必须传入三个东西。

但是，太棒了，Python 允许你也解包字典。对于字典，你不用单个星号 `*`，你用两个 `**`。这种语法的效果是传入三个带名称的值。它的效果是传入 `galleons=100, sickles=50, knuts=25`。所以它与列表解包有相似的效果。但列表解包只是传入了值，100, 50, 25，实际上是用逗号分隔。当解包字典时，它传入键和值，概念上用等号分隔，就像我们的函数期望的那样。

所以如果我现在再次运行 `python unpack.py`，我们仍然没问题，但我们再次精简了我们的代码。现在，我给了自己另一个选择。我可以像我们之前做的那样，将巫师的钱包存储在一个列表中。或者我可以用字典来存储它，更具体，更通用。

所以，为了清楚起见，让我倒带。`**coins` 和我稍微倒带一点到我们第一个命名参数的例子是等价的，和我这里高亮显示的是等价的。当你解包一个字典时，它会传入所有的键和所有的值，很像这里的语法。但让我精简一下，回到我们刚才结束的地方。

现在对解包有什么问题吗？

**提问：** 在这个字典中，我们能有——不是常量名称值对，而是可变数量的名称值对吗？

**回答：** 简短回答，是的。你可以有比我这里的三个更多的键值对。但是如果 `total` 函数只期望三个，那么解包它就行不通。所以如果我在这里添加一些东西，比如让我给魔法世界引入便士（pennies）。假设我有一个便士。现在我运行同样的代码，`python unpack.py`，我们又回到了 `TypeError`。我得到了一个意外的关键字参数 `pennies`，因为 `total` 函数不期望这个。我们稍后会看到，太棒了，对此有一个解决方案。但目前，它行不通。

**提问：** 关于用字典或列表解包的其他问题？在列表——在列表值中，我们给出了相同数量的参数，并且我们在函数中声明了一个默认值。现在，如果你使用这个星号，它会覆盖那个值还是会跳过那个默认值？

**回答：** 好问题。如果我们在这里上面确实有默认值，例如 `galleons=0, sickles=0, knuts=0`，这样做的好处是，回想一下我们之前关于函数参数的讨论，你现在不必传入所有这些值。它们将默认为那些零。因此，你可以传入少于三个的值，无论是在这种情况下使用列表还是字典进行解包。我故意没有这样做，因为我想让我们在这种情况下遇到这个特定的错误。但你绝对可以回去添加那些默认值。

## **九、 函数定义中的 `*args` 和 `**kwargs`**

事实证明，这个单星号 `*` 或双星号 `**` 不仅在解包的上下文中使用。同样的语法实际上在 Python 中被用作一个视觉指示符，当一个函数本身可能接受可变数量的参数时。也就是说，一个函数可以是可变参数的（variadic）。这意味着它不一定非要接受，比如说，三个特定的参数。即使它们有或没有默认值，它可能接受零个、一个、两个或三个。事实证明，实现相同想法的语法在精神上是相当相似的。

事实上，让我回到 VS Code。让我建议我们重新开始这段代码，去掉我们关于加隆、西可和纳特的概念，做一些更通用的事情，只是为了我们能看到这种语法。

假设我定义一个函数如下。定义一个函数，我们叫它 `f`。这个函数不会接受特定数量的参数，而是可变的。所以我将使用这里的语法，`*args`，这表明这个函数确实是可变参数的。它接受一些可变数量的位置参数（positional arguments）。位置性是指它们通常从左到右排列。但我还不知道我想要支持多少个。

假设我还想支持一些关键字参数（keyword arguments），也就是说，可以被它们自己的名字可选地、单独地调用的命名参数。那么，这里的语法约定是使用两个星号 `**`，然后是 `kwargs`。我可以把 `args` 或 `kwargs` 叫做任何我想要的名字。但是你在 Python 自己的文档中经常会看到的约定是，当你有这样的占位符，代表一些数量的参数和一些数量的关键字参数时，世界倾向于使用 `args` 和 `kwargs`。

好吧，在这个函数内部，让我们暂时做一些超级简单的事情。让我打印出字面上的 `"Positional:"`，只是为了在我理解这里发生的事情时提醒我自己位置参数是什么。让我简单地打印出那些 `args`。这不是你通常会做的事情。你通常不会只是接收这些参数并打印它们，无论有多少。我现在只是为了诊断目的这样做，向你展示语法是如何工作的。

现在，让我在我的文件底部——这次我不会费心使用 `main` 函数，这样我们可以只关注这个函数 `f`。让我只用三个参数调用 `f`。我将使用和之前一样的参数。但我还没有费心给它们命名，比如加隆、西可、纳特之类的。

那么我有什么呢？一个无论如何都会调用这个函数 `f` 的程序，但它首先在文件顶部定义了 `f`。它接受一些数量的位置参数，一些数量的命名参数。暂时，我只打印出位置参数。

让我在我的终端窗口运行 `python unpack.py` 并按 Enter。你会看到传入的位置参数显然是这个——一个序列 `(100, 50, 25)`。但是注意这个。

如果我清空我的终端窗口，然后传入其他东西，比如 5，第四个参数。之前，如果我试图改变我传递给 `total` 函数的参数数量（它只被定义为接受三个），我会得到一个 `TypeError`，某种视觉指示表明，“不，你不能传入比函数定义中实际存在的更多或更少的参数。”

但是现在看。如果我运行 `python unpack.py`，这次传入 100, 50, 25 和 5，第四个参数，所有这四个都顺利通过了。我甚至可以去掉所有这些，只剩一个，例如现在，清屏后重新运行我的程序。现在，我将只看到一个参数 `(100,)`。即使这里有一个逗号后面什么都没有，这实际上是看到元组（tuple）时的语法，实际上，逗号只是表明这确实是一个序列，但其中只有一个元素。

好吧，让我们也更好奇一点。让我倒回到我们开始只有那三个值的地方。这次，让我打印出我的命名参数（named arguments），可以这么说，它们不是 `args` 而是 `kwargs`。再次强调，在这种语法中，位置参数 `args` 在前。命名参数 `kwargs` 在后。这是 Python 规定的。

所以现在，让我不只是传入这些数字。让我实际传入命名参数。所以让我现在做一些更具体的事情，比如 `galleons=100`, `sickles=50`, `knuts=25`。我不会费心用 `total` 做任何数学运算。我现在只是想探索一下这个接受可变数量参数的功能。

现在的好处是，如果我运行 `python unpack.py` 并按 Enter，没问题。`kwargs` 自动变成了一个字典，包含了所有传递给我函数的命名参数。

也就是说，在设计你自己的函数时，如果你想支持不止一个参数，也许不止两个、三个或四个，也许是可变数量的参数，确实，你可以同时支持可变数量的位置参数（只是 `value, value, value`）或任意数量的命名参数（你实际写出参数名 `=` 值，然后可能是一个逗号和更多同样的东西）。

所以现在，事实证明我们以前在我们迄今为止使用的一些函数中见过这个。我们不一定看到它被称为 `args` 或 `kwargs`。但我们至少在实践中见过一个这样的例子。

回想一下我们的老朋友 `print`，我们已经用了好几周了。当我们很久以前第一次查看 `print` 的文档时，它看起来有点像这样。`print` 的第一个参数是 `*objects`。当时我对那个变量名开头的星号 `*` 只是挥了挥手带过。但后来我们有 `sep` 代表分隔符，其默认值是空格。我们有 `end`，其默认值是换行符。然后还有一些我们当时挥手带过、我现在也再次挥手带过的其他命名参数。

但是你现在或许可以从我们今天对这些星号（单星号或双星号）的强调中推断出，你知道吗？这就是 Python 文档中表明 `print` 接受可变数量参数的约定。

所以如果我们去看 Python 自己的作者实现的 `print` 函数的实际实现，它很可能看起来像这样：`def print(*objects, sep=' ', end='\n', ...)`。第一个参数是 `*objects`，从而表明 `print` 接受可变数量的参数。下一个可能是 `sep=' '` （无论是用双引号还是像文档中那样用单引号）。下一个可能是 `end='\n'`。然后是一些我们没有看过的其他命名参数。

然后，也许在 Python 作者实现的 `print` 函数内部，可能有一个像 `for object in objects:` 这样的 `for` 循环，允许他们迭代那些可变数量的对象中的每一个，并打印每一个。这就是为什么在过去的程序中，你和我能够只用 `print()`，括号里什么都没有。或者你和我能够打印出像 `"Hello, world"` 这样的东西，括号里只有一个字符串。或者你和我能够做一个字符串 `"Hello,"`，然后是另一个字符串 `"world"`，从而传入两个参数，甚至更多。

所以我们早就拥有了使用可变参数函数（variadic functions）的能力，你可以传入可变数量的参数。你现在通过这个 `args` 和 `kwargs` 语法——但再次强调，它们不必被称为那个名字——拥有了使用那个单星号或双星号来实现你自己那种函数的能力。我刚才自己的 `f` 函数没有做任何特别有趣的事情。但它暗示了如果你将来有用例，需要接受零个、一个或多个任一类型的参数，你该如何做。

现在对这些类型的参数有任何问题吗？

**提问：** 如果你打印 `kwargs` 而参数像是一个列表，会发生什么？

**回答：** 啊。那么如果你像打印列表那样打印参数会发生什么？我想我们看到了。如果我回滚我的历史记录到我有那个 `f` 函数的时候。我称它为 `f` 只是为了非常通用，这样我们就可以玩弄语法。这是我当时的代码：

```python
def f(*args, **kwargs):
    print("Positional:", args)
    print("Named:", kwargs)

f(100, 50, 25)
```

我传入了 `100, 50, 25`。它们被自动存储在 `args` 中。当我运行它时，你可以实际看到那个值的序列，通过运行 `python unpack.py`。这就是那个序列 `(100, 50, 25)`，都在一个单一变量的形式中。我打印它只是为了诊断目的。这不是一个真正有用或漂亮的程序。但它暗示了我们如何访问整个值序列。

**提问：** 关于这种方法的其他问题？我们可以把 `kwargs` 从一个函数传递给另一个函数吗？

**回答：** 当然可以。你可以将它们中的任何一个传递给另一个函数，如果你想包装另一个函数，提供一些额外的功能，但仍然将所有支持的参数原样传递给底层的函数，你可能想这样做。

## **十、 函数式编程相关特性 (`map`, `filter`)**

好的。接下来如何？事实证明，我们可以添加到你的工具箱中的另外几个工具与 Python 支持的编程模型类型有关。

我们很久以前开始时，真正专注于 Python 中的过程式编程（procedural programming）。我们从上到下、从左到右编写代码，定义一些函数，或者如果你愿意称之为过程（procedures），定义变量，并根据需要产生副作用和赋值。

但我们后来最终引入或真正揭示了 Python 在很大程度上也是面向对象的（object-oriented）。我们一直使用的很多变量、很多类型实际上都是对象，来自特定类的对象。那些类是某种模板、蓝图，通过它们你可以封装数据和功能。

好吧，我们一路上也看到了一些 Python 在某种程度上也支持的第三种编程范式（paradigm）的迹象，即函数式编程（functional programming）。在这种范式中，函数更加强大，因为它们倾向于没有副作用（side effects），没有打印或全局状态的改变。相反，它们是完全自包含的，并且可能接受输入并返回值。这通常是我们在开始排序时看到的一种范式，特别是当我们使用像 `sort` 函数或 `lambda` 函数，很久以前我们将想要用来排序列表的函数作为参数传递进去时。

好吧，事实证明 Python 还有其他让人联想到函数式编程的功能，并且确实是仍然以稍微不同的方式解决问题的强大方法。

让我提出这个建议。让我建议我在 VS Code 中快速编写一个新程序，关闭我们的 `unpack.py`，这次创建一个名为 `yell.py` 的程序。假设手头的目标是实现一个程序，允许用户传入输入，然后它通过将所有内容强制转换为大写来“喊出”（yell）响应。对戴耳机的朋友们抱歉，我会调节音量。

所以让我运行 `code yell.py`。在 `yell.py` 中，让我们实现一个真正只做那件事的程序。让我们在这里上面定义一个 `main` 函数。让我们暂时假设这个 `yell` 函数已经存在，并且 `yell("This is CS50")`，正确地大写，而不是全大写。

现在，让我们用 `def yell(phrase):` 来实现这个 `yell` 函数。它暂时接受一个单词或短语。我在这里称它为 `phrase`。我将直接打印出 `phrase.upper()`。所以 `phrase.upper()` 会将整个内容强制转换为大写。像往常一样，在下面如果 `__name__ == "__main__":`，那么像往常一样调用 `main`。

让我们运行一下这个。但大部分情况下，它应该相当直接。当我运行 `python yell.py` 时，"THIS IS CS50" 被喊出在屏幕上。

好的，不错。但 `yell` 只期望单个短语，这不太好。如果我能像 `print` 那样，传入一个短语，或两个，或三个，或者更普遍地是多个单词，但是作为单独的单词本身，那不是很好吗？

所以让我稍微调整一下，将 `yell` 改为接受的不是 `phrase`，而是比如说一个单词列表（list of words）。这样最终，我可以像这样调用 `yell`：`yell(["This", "is", "CS50"])`。我现在不打算费心使用类型提示或注解。但我只假设 `yell` 现在被定义为接受一个像这里定义的单词列表。

但现在我想把它们都强制转换成小写。（注：原文意图应为大写）所以我不太想做像这样简单的事情。比如 `for word in words:`，我可以，例如，打印那个给定的单词 `print(word, end="")`，也许现在行尾什么也不加。但我想如果我这样做，`python yell.py`，不，这不对。我没有把任何东西强制转换成大写。所以让我们修复这个。

好吧，让我们做以下事情。让我像这样累积大写的单词。让我创建一个名为 `uppercased` 的变量，并使用方括号 `[]` 或我们更冗长的 `list()` 语法将其初始化为空列表。现在，让我迭代 `words` 中的每个单词。对于每一个，让我们进入我们的 `uppercased` 列表，向其 `append` 当前单词的大写版本 `word.upper()`。这是创建名为 `uppercased` 的新列表的一种方式，它只是不断地向该列表 `append`, `append`, `append` 循环中每个当前单词的大写版本。

现在，让我只打印出 `uppercased` 列表。这不太对。让我们看看这里会发生什么。`python yell.py`，好的。这不太对，因为我认为我不想要那些引号或那些方括号。我看到了什么？我实际上是在打印一个列表。但是，但是，但是，这里我们一些解包语法现在就有用了。我不必改变我解决这个问题的方法。我可以只通过添加单个星号 `*` 来解包 `uppercased`。现在，让我重新运行 `python yell.py`。现在，它实际上只是英文了。"THIS IS CS50"。没有 Python 语法的残留物，比如引号、逗号和方括号。我现在已经解包了 "This", "is", "CS50" 作为三个独立的参数传递给 `print`。所以现在看来，这个解包技术似乎很有用。

好吧，我现在需要用这种方式通过一个值列表来调用 `yell`，这有点不幸。这根本不是常态。或者至少，它远不如像 `print` 函数那样用户友好，我可以传入零个、一个、两个、三个或任意数量的参数。为什么你的 `yell` 函数让我只传入一个列表？

嗯，我们可以做得更好。让我们采用一些我们学到的新约定。让我们去掉列表，通过移除方括号。让我们只给 `yell` 传递三个参数：`yell("This", "is", "CS50")`。

现在，我不想做类似改变 `words` 的定义来接受 `word1, word2` 的事情。那无法扩展，也无法处理不同数量的单词。但我们现在有了一种技术。我们可以说 `*args`，这将允许 `yell` 函数接受任意数量的参数。为了更具体，让我们不要笼统地称它为 `args`。让我们给它起一个更具自解释性的名字，比如 `*words`。这只是意味着我有可变数量的单词被传入。

现在，我想，我做了一个边际改进。让我再次运行这个，`python yell.py`。"THIS IS CS50" 是全大写的。但这只是稍微好了一点。因为现在我可以像我长期对待 `print` 那样对待 `yell`，传入你想要的任意数量的东西，`print` 会处理它。现在，我的 `yell` 函数似乎同样强大。更好的是，它还将所有内容强制转换为大写。

好吧，事实证明 Python 自带一个名为 `map` 的函数，其存在的目的是允许你将某个函数映射（map），也就是应用（apply），到某个序列（如列表）的每个元素上。

例如，如果我们想将传入的 `words` 列表中的每个单词 "This", "is", "CS50" 强制转换为大写，那么，我们本质上是想将 `upper` 函数映射到每个值上。所以使用 Python 中的 `map` 可以做到这一点。

让我回到 VS Code。让我现在建议我按如下方式重新实现这个。我去掉所有这三行代码，特别是去掉那个循环。让我仍然声明一个名为 `uppercased` 的变量。但让我把它设置为这个新函数 `map` 的返回值。`Map` 在这里接受两个参数。在这种情况下，第一个参数是我想要映射到值序列上的函数的名称。那么，我想对传入的每个单词应用哪个函数呢？好吧，事实证明，感谢我现在对面向对象编程的了解，我知道在 `str` 类中有一个名为 `upper` 的函数。我们通常通过使用字符串变量名 `.upper()` 来调用它。但如果你阅读 `str` 类的文档，你会看到该函数确实被描述为 `str.upper`。我没有在 `str.upper` 的末尾使用圆括号。因为我现在不想调用它。我想把这个函数传递给 `map` 函数，这样 `map` 就可以以某种方式添加那些括号，可以这么说，并在所有这些单词中的每一个上调用它。

这就是 `map` 所做的，相当强大，并且确实是函数式编程的一个实例。我将另一个函数传递给这个 `map` 函数。不是调用它。我只是通过某种引用传递它。`map` 将为我做的是迭代每个单词，在每个单词上调用 `str.upper`，并返回给我一个全新的列表，其中包含所有这些结果，放在一个列表中。它完全避免了我需要使用那个列表更手动地来做这件事。我仍然将使用 `*uppercased` 打印整个内容。这样，如果我得到一个包含三个大写单词的列表，我将解包它们并全部打印出来。

所以让我们再次运行这个。`python yell.py` Enter。瞧，它仍然有效。但代码现在比以前更紧凑了。

## **十一、 列表推导式 (List Comprehensions)**

事实证明，还有另一种方法可以解决这个问题，这种方法甚至更 Pythonic，或者至少相当普遍。那就是使用一种称为列表推导式（list comprehension）的特性。这是一个有点大的短语。但它指的是在 Python 中，你可以非常容易地动态构建一个列表，而无需使用循环，无需调用 `append` 和 `append`，而是在一个，可以说是优雅的单行代码中完成所有事情。

那么我该如何使用列表推导式的概念呢？

好吧，让我这样做。在 VS Code 的 `yell.py` 中，让我按如下方式改变我的方法。与其使用 `map`（这在这种方式下完全没问题且正确），不如让我向你展示这另一种方式。

列表推导式是创建像这样 `[]` 的列表的机会。但在那些方括号内部编写一个 Python 表达式，实际上会使用你编写的一些逻辑为你动态生成一个全新的列表。我可能在这里采取的方法是这个。

如果我想在这个列表中存储 `words` 列表中每个单词的大写版本，我可以这样做：`[word.upper() for word in words]`。

现在，这有点拗口。但我敢说 Python 程序员喜欢这种能力，能够动态定义一个列表，里面包含任意数量的值，而这些值通常，至少像我们做的那样，需要用循环和反复调用 `append` 来构造。但这通常需要两行、三行、四行或更多行。我这里高亮显示的列表推导式现在是创建完全相同东西的另一种方式——一个列表，里面是一堆大写的单词。是哪些单词？对于传入 `yell` 的 `words` 列表中的每个 `word`，其大写版本最终会出现在这个列表中。

关于这里的语法有什么问题吗？这确实需要一点时间来适应。因为你左边有这个值，这里的函数调用。你在方括号内有这个循环。但如果你习惯了从左到右阅读这种方式的代码，这就意味着：给我 `words` 列表中每个 `word` 的大写版本。

**提问：** 你好。你也可以做条件判断吗，比如 `if else`，或者组合 `if`, `elif`, `else`？

**回答：** 确实可以。让我回到那个问题，我们会看到一个有条件地做事情的机会。但现在，我只是将列表中的每个单词都大写。好问题。

**提问：** 其他问题？是的。这是函数式编程吗？或者我的意思是，这个特定的东西，我们使用 `word.upper() for word in words`？

**回答：** 不一定。我会说这更像是 Python 的一个特性。

**提问者：** 好的。

**回答：** 是的。`map` 是其中一个非常具体的体现。我们使用 `lambda` 并将其作为 `key` 属性传递给 `sort` 函数、`sorted` 函数，是很久以前的一个例子。我们马上会看到另一个。

## **十二、 `filter` 函数 (与列表推导式结合条件)**

所以我们甚至可以使用这些列表推导式来过滤我们结果列表中的值，决定哪些包含哪些不包含。

事实上，在 VS Code 这里，让我关闭 `yell.py` 并关闭我的终端窗口。让我在这里创建一个新程序，其目的可能是获取与之前相同的学生列表，但使用其较短的版本，并只过滤出格兰芬多（Gryffindor）的所有学生。

所以让我创建一个名为 `gryffindors.py` 的文件。我将从之前复制粘贴我的学生列表，至少是赫敏（Hermione）、哈利（Harry）、罗恩（Ron）和德拉科（Draco），从开头这里，这样我可以专注于一个碰巧不是来自斯莱特林（Slytherin）的学生。

我现在要做的是，如果我想只过滤出格兰芬多的学生，让我这样做。让我创建另一个名为 `gryffindors` 的变量，它将等于下面的列表。这将是一行有点长的代码。所以我将主动地将我的方括号移到两行上。我现在将创建一个列表推导式。我想这样做。我想让这个名为 `gryffindors` 的新列表包含每个学生的名字（`student["name"]`），对于 `students` 列表中的每个 `student`。但是，但是，但是，`if student["house"] == "Gryffindor"`。

所以这在精神上几乎与我刚才做的完全相同，即根据传递给我的 `yell` 函数的每个单词创建一个列表推导式。但在这里，我是有条件地这样做。所以我借鉴了我们对循环的关注的灵感，借鉴了我们对条件语句的关注的一些灵感，将它们组合到这个相同的方括号表示法中。这样，`gryffindors` 最终是零个或多个学生的名字。而被包含的名字是迭代每个学生的结果，并且最终结果中只包含那些学院恰好是格兰芬多的学生。

所以当我用 `python gryffindors.py` 运行这个并按 Enter 时，你会看到，嗯，实际上什么也没发生。嗯，那是因为我没有完成程序。让我实际用这个来完成程序。对于 `gryffindors` 复数中的每个 `gryffindor`——更好的是，为了让我提前做所有这些工作显得合理，让我用我们熟悉的 `sorted` 函数对所有这些名字进行排序。现在让我们打印出每个 `gryffindor`。

所以现在注意，如果熟悉书籍和电影，你会知道这四个学生中只有三个实际上在格兰芬多。如果我运行 `python gryffindors.py`，我们看到了 Harry, Hermione, 和 Ron，但现在也按排序顺序排列了。

所以这只是我们使用不仅是列表推导式，而且是包含条件的列表推导式来解决这个特定问题的一种方法。

但还有其他方法可以解决同样的问题。我们回到了 Python 的一些函数式特性。除了像 `map` 这样的函数，还有一个叫做 `filter` 的函数，可以用来达到同样的效果，但使用的是更函数式的方法，如果你愿意这么说的话。

让我回到 VS Code。用同样的例子，让我这样做。让我保留上面原始的列表不变，包括德拉科，他实际上不是格兰芬多的。让我暂时定义一个名为 `is_gryffindor` 的函数，它接受像学生 `s` 这样的值作为输入。然后，让我们这样做。让我们说 `if s["house"] == "Gryffindor":`，那么返回 `True`。否则，返回 `False`。

现在，我们以前见过像这样有点不必要冗长的条件语句。如果我上面已经在问一个布尔问题，我不需要一个条件语句。所以我可以像我们过去做的那样，实际精简这个，只返回 `student["house"] == "Gryffindor"` 的结果？要么它等于并且结果是 `True`，要么不等于并且结果是 `False`。我不需要显式地返回 `True` 或 `False`。我可以只返回那个布尔表达式的值。

现在让我们这样做。我将像之前一样创建一个名为 `gryffindors` 的变量，一个包含我所有格兰芬多学生的列表，这次它等于调用 `filter` 的结果。`Filter` 在这里至少接受两个参数，其中一个是调用的函数的名称 `is_gryffindor`。我将把这个函数应用到这个序列 `students` 的每个元素上。所以精神上类似于 `map`，我传入一个将应用于序列中每个元素的函数。但是 `map` 为序列中的每个元素返回一个值。这就是我们如何将所有单词强制转换为大写。但如果我想有条件地将一个学生包含在我最终的 `gryffindors` 列表中，我可以使用 `filter` 来代替。

`Filter` 期望它的第一个函数不是像 `str.upper` 那样的东西，而是一个返回 `True` 或 `False` 的函数。告诉我是否应该将当前学生包含在最终列表中。而被问的问题是，他们是否住在格兰芬多？我们正在检查字典的 `house` 键来获取答案。

所以，最终，我想我们会得到非常相似的东西。对于 `gryffindors` 中的每个 `gryffindor`，让我们打印出当前学生的 `gryffindor["name"]`。它暂时不会被排序。但是当我运行这个版本 `python gryffindors.py` 并按 Enter 时，我们又回到了正轨。它是未排序的。但我们有 Hermione, Harry, 和 Ron，但没有 Draco。

如果你还记得几周前，如果我们想要对一个字典列表进行排序，我们仍然可以做到。我可以对复数 `gryffindors` 调用 `sorted`。我可以传入一个 `key`。那个 `key` 可以有一个匿名函数，也就是 `lambda` 函数，它接受一个学生作为输入，称之为 `s`，然后返回 `s["name"]` 的值，如果我的目标确实是按学生自己的名字排序。

如果我现在运行 `python gryffindors.py`，我会看到同样的学生列表。但这次，它是排序的。

所以这里我们看到了解决这个特定格兰芬多学生问题的两种方法。我们可以要么使用像列表推导式这样的东西，并在那个列表推导式内部做一些过滤，像我做的那样包含一个 `if` 条件。或者我们可以采取更函数式的方法，只使用这个 `filter` 函数，将我想要为我做这些决定的函数传递给它，然后只包含那些返回 `True` 的学生。

现在对这两种方法中的任何一种有任何问题吗？

**提问：** 是的。我只是有一个问题，如果我们像上一个版本那样编写代码，所有东西都塞在一行里，那么如果我们检查代码的风格，会不会有问题，因为它可读性较差？

**回答：** 那么像 `black` 这样的格式化程序会对其中一些代码的风格有问题吗？

**提问者：** 上一个版本，所有东西都塞在一行里。[声音交错]

**回答：** 哦，好问题。像 `Black` 这样的工具会对这段代码有问题吗？好吧，让我倒回到那个版本，它使用了那个稍微长一点的列表推导式，如果我们回退得足够远，给我多几次撤销，它最终看起来是这样的：
```python
gryffindors = [student["name"] for student in students if student["house"] == "Gryffindor"]
```
让我运行 `black gryffindors.py`。你会看到它实际上——它稍微重新格式化了。但我自己主动修复了这个问题。如果我当初这样做，并且只写在一行上，但我知道 `Black` 可能不喜欢那样，它会为我修复它。所以我只是在编写代码之前主动修复了它。

**提问：** 关于 `gryffindors.py` 和这种使用列表推导式或 `filter` 的方法，还有最后一个问题的时间？是的。使用 `filter` 时，与其调用函数 `is_gryffindor`，你能在 `filter` 内部直接使用它吗？

**回答：** 你能使用函数 `is_gryffindor` 吗？

**提问者：** 我的意思是，如果你能在 [听不清] 内部写 `return house == Gryffindor`。

**回答：** 是的，确实。事实上，回想一下我们确实在很久以前使用过这些 `lambda` 函数，当我们想传入一个快速而临时的匿名函数，让 `sorted` 按字典的不同键进行过滤时。我们可以在这里这样做。我实际上可以提取这个 `is_gryffindor` 函数的精髓。我可以将我的 `filter` 调用中的这个函数名更改为另一个 `lambda` 函数，传入像 `s` 这样的参数，并返回完全相同的结果：`lambda s: s["house"] == "Gryffindor"`。我现在可以完全删除我的 `is_gryffindor` 函数。现在，当我运行 `python gryffindors.py` 时，我仍然得到相同的答案。而且我没有费心定义一个函数只是为了在一个且仅在一个地方使用它。

## **十三、 字典推导式 (Dictionary Comprehensions)**

好吧，让我建议也为你的工具箱装备另一个工具，即字典推导式（dictionary comprehensions）。

诚然，语法开始变得更加奇怪。但是当你对所有这些原语和其他东西越来越熟悉时，这些只是你可以选择性地，但也许是强大地用来解决未来问题的工具。

通过字典推导式，我们能够动态地创建一个带有键和一些值的字典，而无需使用老式的方法，即创建一个空字典，创建一个 `for` 循环，迭代该循环，并向字典中插入越来越多的键和值。我们可以一次性完成所有操作。

事实上，让我回到 VS Code。让我现在建议我这样做。让我先用老式的方法来做，如下所示。

让我简化一下，完全去掉学院，这样我们现在可以只关注一个学生名字的列表。我将运行 `students = ["Hermione", "Harry", "Ron"]`，只保留格兰芬多的这三个学生。

我现在将像我们过去做的那样，主动给自己一个空列表 `gryffindors = []`，这样我就有东西可以累积这个问题的答案。现在，我将做类似这样的事情。`for student in students:`，这样我可以迭代他们中的每一个。让我们用 `gryffindors` 列表向其 `append` 一个字典：`{"name": student, "house": "Gryffindor"}`。我知道这三个学生在格兰芬多。所以假设手头的问题是，我想构建一个只包含格兰芬多学生的字典列表。这有点像是上一个版本的倒退，在上一个版本中我已经有了名字和学院。现在，只假设问题是我有他们所有的名字，但我还没有学生字典本身。所以我正在重建我之前认为是理所当然的相同结构。

现在，让我们只是为了讨论起见，打印出这些 `gryffindors`，这样我们就可以看到我们构建了什么。如果我在我的提示符中运行 `python gryffindors.py`，我看到了有点神秘的语法。但再次注意我们的小提示。我在末尾有一个方括号，在开头也有一个方括号。这像往常一样表明这是一个列表。然后我有一堆花括号，里面有一堆带引号的键。按照惯例，在字典上使用 `print` 时，它们恰好是单引号。但这只是一个视觉指示符，表明那是我的键。它的第一个值是 Hermione。第二个键是 `house`。它的值是 Gryffindor。然后有一个逗号，它将一个 `dict` 对象与下一个分隔开。如果我们看过去 Harry 和 Gryffindor，还有第二个逗号，它将 Harry 和 Gryffindor 与 Ron 和 Gryffindor 分隔开。

简而言之，这里是一些代码，我相当手动地用一个 `for` 循环和一个最初为空的列表构建了与之前相同的数据结构，只是少了 Draco，只有格兰芬多的学生。

但是这里，再次地，通过字典推导式，或者实际上首先是列表推导式，我们可以更简洁地做到这一点吗？

让我清空我的终端窗口。让我们去掉这个最初为空的列表和这个 `append`, `append`, `append` 的 `for` 循环。让我们只这样做。一个 `gryffindors` 变量将等于以下列表推导式：`[{ "name": student, "house": "Gryffindor" } for student in students]`。

在那个列表内部，我想要一个结构为某人名字和他们名字的字典。某人的学院，暂时只有格兰芬多。就这样。但我想要这些花括号中的 `dict` 对象中的一个，对于 `students` 中的每个 `student`。

所以这里也是，在我的带有方括号的列表推导式内部，我想要一个由花括号表示的字典对象。我希望每个字典都有两个键——分别是 `name` 和 `house`，它们的值分别是来自前面这里的学生名字和仅有的 Gryffindor。我想从哪些学生创建那些 `dict` 对象呢？嗯，`for student in students`。所以再次，左边是我最终列表中想要的东西。右边我有一个循环，这次没有条件。我希望所有这些学生都在格兰芬多作为他们的学院。

现在，让我们再次打印这个，`python gryffindors.py` 并按 Enter。现在，我们得到了完全相同的输出。所以不是三行，只是一行。乍一看有点神秘难读。但是一旦熟悉了列表推导式和这种语法，它只是解决同样问题的另一种方法。

如果我想改变这个并简化呢？如果我不想要一个字典列表，我现在有的是这个。再次强调，根据方括号，我有一个包含三个 `dict` 对象的列表。如果我只想要一个更大的字典，里面是像 `Hermione: Gryffindor`, `Harry: Gryffindor`, `Ron: Gryffindor` 这样的键值对呢？我不需要列表。我不需要每个学生有单独的对象。我只想用一个大字典，其中键是学生的名字，值是他们的学院。我暂时假设在这个世界里没有人会有相同的名字。

好吧，我可以这样做。让我去掉这里的这个，不是创建一个列表推导式，而是再次创建这个被称为字典推导式的东西。这里的视觉指示符或区别在于，最外层不是方括号，这次将是花括号 `{}`。

所以在这些花括号内部，我希望每个键是什么？我希望每个键是学生的名字 (`student`)。我希望每个值暂时是 `"Gryffindor"`。我想为 `students` 中的每个 `student` 这样做：`{student: "Gryffindor" for student in students}`。

现在，事情变得非常有趣了。这是 Python 在某些观点看来从左到右非常可读的另一种体现。绝对需要练习和熟悉。但这正在创建一个名为 `gryffindors` 的变量，根据这些花括号，它将是一个字典。每个键将是某个学生的名字。每个值将是 Gryffindor。是哪些学生的哪些名字？嗯，这个字典推导式将根据 `students` 列表逐个构建。

所以当我现在打印这个时，语法会看起来有点不同，因为它不是字典对象的列表。它只是一个更大的字典对象本身。但是现在打印 `gryffindors` 给了我 `{'Hermione': 'Gryffindor', 'Harry': 'Gryffindor', 'Ron': 'Gryffindor'}`。

现在对我们所谓的字典推导式还有任何问题吗？这里有什么问题吗？

[暂停]

没有？

## **十四、 `enumerate` 函数**

好吧，让我们从 Python 的工具箱中引入另一个函数，然后是最后一个特性和点缀。然后你就可以上路了。

好吧，让我们回想一下这个。回想一下很久以前，我们只有一个简单的学生列表，就像我们这里的 Hermione, Harry, 和 Ron。例如，很久以前，我们想打印出，比如说，他们从一到三的排名。

不幸的是，当你做类似 `for student in students:` 的事情时，你可以很容易地打印出学生的名字。当然，如果我执行 `python gryffindors.py`，我按同样的顺序得到 Hermione, Harry, Ron。但我看不到任何数字排名。我看不到数字一、二或三。

所以我也许可以用另一种类型的 `for` 循环来做这个。与其这样，为什么不试试这个？也许我可以做 `for i in range(len(students)):`——我们以前做过类似的事情。然后我可以打印 `i`，我可以通过索引到列表的位置 `i` 来打印学生的名字：`print(i, students[i])`。

好吧，这看起来怎么样？如果我运行 `python gryffindors.py`，很接近了。但他们不是程序员。他们不一定认为自己是零索引的。赫敏可能想排第一，而不是第零。那么我们该如何修复这个呢？好吧。只是一点算术。我当然可以打印 `i + 1`，然后是学生的名字。所以如果我清空我的终端窗口并再次运行 `python gryffindors.py`，现在我们有了这个枚举，1, 2, 3，对应每个学生。

但事实证明，Python 实际上一直以来都有另一个内置函数，你现在可能会觉得有用。那就是 `enumerate`。`Enumerate` 允许你更简单地解决这类问题，通过迭代某个序列，但不仅一次获取每个值，而且同时获取值和它的索引。它一次给你两个答案。

所以如果我现在回到 VS Code 并采用这种方法，我不需要做这个复杂的 `range` 和 `len`，然后到处都是 `i`。我可以更简洁地这样做。我可以写 `for i, student in enumerate(students):`。`enumerate` 返回一个枚举，如果你愿意这么称呼它。现在，我可以像之前一样打印 `i + 1`。我可以打印 `student`。所以我不需要用括号 `i` 表示法索引列表。我不需要调用 `range`。我不需要调用 `len`。再次强调，`enumerate` 接受一个像这些 `students` 这样的值序列，它允许我获取当前索引 0, 1, 2 和当前值 Hermione, Harry, Ron。所以现在，只是进一步精简了事情。

事实上，这就是我们这里的主题。我们能否解决与我们几周来一直在解决的相同问题，但通过使用更多这个工具箱来精简事情？

## **十五、 生成器 (Generators)、迭代器 (Iterators)、`yield` 关键字**

让我们为你的工具箱装备最后一个工具，即在 Python 中从函数生成（generate）值的能力。

这不是我们以前必然遇到的问题。但事实证明，如果你正在编写一个读取或生成大量数据的函数，你的函数、你的程序、你的计算机很可能耗尽内存。你的程序可能无法再继续运行。

但事实证明，这个问题有一个解决方案，你可能会把它放在你的后备口袋里，特别是如果在学完这门课程后，你开始处理相当多的数字并分析更多的数据。

事实上，让我们回到 VS Code。让我们创建一个程序，在这个时候可能很及时，特别是取决于你的时区，你可能会感觉越来越困。但在美国，当你难以入睡时，通过在脑海中数羊来催眠是很常见的。通常，正如卡通片中所描绘的那样，你可能会在你的脑海中看到一只羊跳过栅栏，然后是两只，然后是三只羊，然后是四只。然后，最终，你大概会因为数这些羊而变得如此无聊，以至于你真的睡着了。

所以在 VS Code 这里，让我们创建一个名为 `sleep.py` 的程序，它允许我打印出一些数量的羊，就好像我在我的脑海中数它们一样。通过这个程序，让我们这样做。让我们提示用户输入一个变量 `n`，将其设置为 `input("What's n? ")` 返回值的整数转换。询问用户他们想尝试数多少只羊？

然后，让我们做一个熟悉的 `for` 循环。我们将像往常一样从零开始计数。所以我们首先会有零只羊，然后一只羊，然后两只羊，依此类推，`for i in range(n):`。打印出。我将在这里粘贴一个代表羊的表情符号（🐑）乘以 `i`。所以第一次迭代我会看到零只羊。第二次迭代你会看到一只，然后两只，然后是 `n` 最终指定的任意数量减一。

让我进入我的终端窗口运行 `python sleep.py`。我应该确实看到，在我输入，比如说，3 作为 `n` 的值之后，零只羊，然后一只羊，然后两只羊，等等。如果我让我的终端窗口更大一些，我们当然可以做更多，例如输入 10。你会看到随着时间的推移，我们得到越来越多的羊，大概在我的脑海中想象起来也越来越乏味。

所以现在让我们实践一下我们一直以来在程序设计方面所宣扬的，看看我们是否以及何时会真正遇到问题。

让我现在在这里把所有这些都放到一个 `main` 函数中，像往常一样在上面定义 `main`。让我缩进所有这些代码。然后，让我像往常一样有条件地这样做，如果 `__name__ == "__main__":`，那么调用 `main`。让我们确保我还没有破坏任何东西，即使在功能上这应该几乎是相同的。如果我输入 3，我仍然在屏幕上看到零只，然后一只，然后两只羊。

但是我们当然一直有为自己创建辅助函数（helper functions）的习惯。也就是说，以一种允许我们将某些功能（比如生成一定数量的羊）抽象到单独函数中的方式来分解我们的代码。这样，一来，它们确实被抽象了。我们不再需要考虑它们是如何实现的。我们甚至可以在项目和库中重用它们。但我们也养成了现在用单元测试来测试这些函数的习惯。所以我可能不应该把所有的逻辑都放在 `main` 里。让我们把其中一些分解出来。

如果我能，比如说，只调用一个 `sheep` 函数，通过取这行代码。与其只在这里打印它，不如让我们打印出一个名为 `sheep` 的新函数的返回值，该函数告诉函数要打印多少只羊，在这种情况下是 `i`：`print(sheep(i))`。

让我们像往常一样下去创建另一个名为 `sheep` 的函数。`sheep` 函数现在将接受一个参数 `n`，指定你想要返回多少只羊。这样我们就可以像用单元测试那样测试它，虽然我们不会在这里做，让我不要通过副作用来打印羊的数量。而是让我返回一个羊表情符号乘以 `n`：`return "🐑" * n`，这样用户就能得到一个包含适当数量羊的完整字符串来打印。

所以这里在功能上，我认为我们没有改变任何太根本的东西。`python sleep.py` 输入 3 仍然给我们零只，然后一只，然后两只羊。但现在，我们至少有了一个专注于 `sheep` 函数实现的框架。

但是现在它有点不优雅，仍然由 `main` 函数来做这个迭代。我们很久以前在第零周就看到过，定义一个实际处理返回我们想要的整个字符串过程的函数，而不是一次只返回一行羊，那不是很好吗？

嗯，我想我们可以这样做。为什么我不按如下方式更改 `sheep` 呢？让我先在这里创建一个最初为空的羊群 `flock = []`，使用一个空列表。然后 `for i in range(n):`，让我们向那个 `flock` 中 `append`，例如，一只羊乘以 `i`：`flock.append("🐑" * i)`，这样我就不断地向这个列表中添加零只羊，然后一只羊，然后两只羊，然后三只，等等。然后，最终，我将一次性返回整个 `flock`。所以这将返回所有那些羊字符串的等价物，以便，啊，`main` 可以处理它们的打印。

所以回到 `main` 这里，让我们这样做。对于 `sheep(n)`（它再次返回给我所有羊的列表，整个羊群）中的每只羊，我称它为 `s`，因为 sheep 单复数同形，让我们只是一次打印一只羊 `s`：`for s in sheep(n): print(s)`。

所以，到目前为止，我想一切都好。让我运行 `python sleep.py` 并按 Enter。`What's n?` 3。这似乎仍然工作得很好。

但让我更大胆一点，看看不仅仅是屏幕上的 3 只羊，而是也许 10 行羊。那似乎也工作得很好。让我更大胆一点，输入也许 100 只羊。公平地说，它开始看起来很难看，但它们都打印得很快。让我再试一次，也许屏幕上有 1000 只羊。它们飞快地过去了。仍然很乱。但它们都在那里。我们可以把它们都数出来。不仅仅是 1000 只，而是 10,000 只羊怎么样？嗯，那似乎也没问题。它花费的时间大概是原来的 10 倍。这就是你看到屏幕闪烁的原因。所有的羊仍在打印。但是，但是，但是，打印的数据量很大。如果我再坚持一会儿，希望我们能看到所有 10,000 只羊都出现。

[视频此处会加速]

哦天哪。这羊可真多。好了。好的。现在我所有的羊都打印完了。所以它似乎工作得很好。

好吧，让我更大胆一点，好吧，让我试试运气。这次让我试试，比如说，一百万只羊，然后按 Enter？

哈。有些东西不再工作了。

[等待]

在我们等待剧透的时候，有没有人对为什么我的程序突然停止打印羊有任何直觉？在这个版本中，我生成了这个非常大的羊群，出了什么问题？

**提问者：** 我们可能用完了内存或计算能力。

**回答 (David Malan)：** 是的。所以也许我们实际上正在挑战我的 Mac、我的 PC、我的云服务器的内存或 CPU（计算机的大脑）能力的极限，因为它只是试图生成巨大、巨大、巨大的羊列表，一百万行羊，每一行都有大量的羊。看来我的电脑在这里老实说只是在挣扎。

这现在真的很不幸。因为看起来，即使这个程序对于 1000 只羊、10000 只羊显然工作得很好，一旦你超过某个阈值，它就完全停止工作了。或者它只是花费太长时间以至于程序不再有用了。

但这似乎有点傻，因为理论上，如果我只是马上打印一只，然后马上打印两只，然后打印三只，然后四只，然后五只，我绝对应该能够打印所有这些相同的羊。似乎这个问题的本质，如果我回到我的代码，是根据我正在努力实践的最佳实践，似乎根本问题在于我通过创建这个名为 `sheep` 的辅助函数来模块化了我的代码，它的目的是完成所有羊的生成，然后一次性返回所有羊。

那不是更好吗——我现在甚至能听到我的风扇开始转动了，仅仅是试图生成这些羊——那不是更好吗，只是一次打印一只、两只、三只、四只羊？嗯，我们可以那样做。但这真的是一种倒退。那相当矛盾于过去几周学到的所有教训。一般来说，不把所有东西都放在 `main` 里是件好事。一般来说，有一个额外的函数，然后你可以用单元测试单独测试，是件好事。我们真的需要仅仅为了打印一些羊并在这里睡着而放弃所有那些最佳实践吗？

好吧，事实证明，这个问题有一个解决方案，即以 Python 中的这些生成器（generators）的形式。你可以将一个函数定义为生成器，这样它仍然可以为你的用户生成大量数据。但是你可以让它一次只返回一点点数据。你自己可以用几乎相同的方式实现代码。但你不必担心一次返回太多东西。

这些，像 Python 的所有特性一样，在官方文档中有记载。但你最终会发现，它都归结为这个关键字：`yield`。

到目前为止，当我们创建函数时，我们一直在定义使用关键字 `return` 返回值的函数（如果有的话）。事实上，如果我们回到我们的代码，这正是我一直在等待的。我一直在等待一次性返回整个羊群。不幸的是，如果你等待太久，现在我们看到了，我的程序被“杀死”（killed）了。也就是说，我的电脑对它试图使用的内存和 CPU 感到如此厌烦，以至于它直接说：“不行，你根本不准运行。” 这很不幸。现在我的程序对于大量的羊不再工作了——羊（sheeps），如果我某晚真的难以入睡，这可不好。

那么我该如何使用 `yield` 来解决这个问题呢？好吧，让我这样做。

与其在这个名为 `flock` 的大列表中构建这个庞大的羊列表，不如让我们这样做。让我按如下方式简化整个函数，我迭代 `for i in range(n):`。然后在每次迭代中，过去我可能倾向于使用 `return` 并返回类似一只羊乘以 `i` 的东西：`return "🐑" * i`。但这在这里行不通。因为如果你想要一百万只羊，并且你开始一个 `for` 循环说 `for i in range(1_000_000)`，你会意外地立即返回零只羊。然后这个函数基本上就没用了。你不应该在像这样的循环中间返回值，因为你将无法到达循环的任何后续迭代。它会迭代一次，然后砰，你返回了。

但是感谢 Python 中的另一个关键字 `yield`，你可以告诉 Python 实际上一次只从这个循环中返回一个值。所以如果我回到我的代码的这个版本。我说不是 `return` 而是 `yield`：`yield "🐑" * i`。这就像是说，一次返回一个值，一次返回一个值，一次返回一个值。`for` 循环将继续工作，我将继续从零数到一，到二，一直到接近一百万。但每次，函数只会递给你一小部分数据。它会“生成”（generate），可以这么说，只是一点点数据，而不是一次性生成所有数据。

这很好。因为我的电脑有相当数量的 RAM，肯定足够容纳一行羊。它只是没有足够的内存来容纳，显然，一百万行那么多的羊。

所以现在，如果我到我的终端窗口运行 `python sleep.py` 并按 Enter，`What's n?` 3 仍然可以工作——零只，然后一只，然后两只。让我在这里增大窗口尺寸并运行 `python sleep.py`。让我们像之前一样尝试一百万，然后按 Enter。现在我立即看到了结果。我不认为我们会等待所有这些羊都被打印出来，因为那样我们真的都会睡着了。但你现在会注意到正在发生的是，程序没有“挂起”（hanging），可以这么说。它没有等待，等待，思考，思考，并试图一次性生成整个羊群。它只是一次生成一行羊。屏幕在闪烁，因为羊太多了。这一切都归功于 `yield`。它一次生成一点点数据，而不是一次性全部生成。

现在对这个称为生成器的特性有任何问题吗？

[暂停]

完全没有问题吗？

为了增加术语，让你听过。这个同样的特性返回的是我们现在技术上称为迭代器（iterator）的东西。`Yield` 返回一个迭代器，允许你自己的代码，你在 `main` 中的 `for` 循环，一次一个地迭代这些生成的值。

**提问：** 这个 `yield` 在底层实际上是如何工作的？我的意思是，它是否使用了多线程？

**回答：** 你可以认为实现在这个意义上是异步（asynchronous）的。函数立即返回一个值，然后随后再给你另一个。在底层，真正发生的是生成器只是为你保留了状态。它不会从头到尾运行整个循环然后返回一个值。它会做一次迭代并 `yield` 一个结果。然后 Python 会为你“暂停”（suspend）这个函数，如果你愿意这么说的话，但会记住它在哪次迭代。所以下次你迭代它时，就像在 `main` 的 `for` 循环中会一次又一次发生的那样，你会一次又一次地得到另一个值。所以 `yield` 确实返回这个叫做迭代器的东西。那个迭代器可以像在循环中那样一次遍历一个元素。但是语言，Python，为你处理了所有这些，所以你不需要自己做所有底层的管道工作。

**提问：** 关于这些生成器和迭代器，还有最后一个问题的时间，当我们的羊继续飞过时？所以每次迭代，程序都会将内存返回给系统，所以程序不会崩溃？

**回答：** 正确。在每次迭代中，它只返回适合当前 `i` 值的那一个羊字符串。它没有试图返回所有一百万行。因此，它使用的内存量确实是百万分之一，尽管这有点过于简化了。

## **十六、 结论与展望**

好的。当这些羊继续飞过屏幕时，我现在要中断这个，就像你过去可能不得不用 Ctrl+C 来中断你自己代码中的无限循环一样。即使这个不是无限的，它只是非常长——Ctrl+C 会用你的键盘中断那个程序，把我的电脑控制权还给我。

好吧，我们来到了 CS50 的 Python 编程入门课程的结尾。如果说今天，尤其是今天，感觉像是一次真正的快速升级，要意识到这些真的——这些只是你工具箱中额外的、或许是可选的工具，你可以添加到过去所有学到的知识中。这样，当你离开这门课程，去学习其他课程或做你自己的项目时，你就有了更多的思维模型和更多的工具箱来解决同样的问题。

如果我们现在回想几周前，可能是在我们专注于函数和变量的时候，你第一次开始感到困难。但现在回想起来，如果你回头看那些问题和那些同样的问题集，很可能那些同样的问题现在对你来说太容易了。

条件语句是课程的下一步，我们给了你提问和获得答案的能力，从而在你的代码中有条件地做事。我们今天绕了一圈回来了。你可以看到你现在可以用那些同样类型的条件语句来做更花哨的事情，比如列表推导式和字典推导式等等。

循环，当然，几周来一直无处不在，包括今天我们构建那些同样的结构。

当然，事情可能会出错。异常和异常处理是我们不仅能捕获代码中的错误，还能引发你自己的异常的机制。这样，如果你正在为其他人编写代码奠定基础，比如以库的形式，你也可以这样做。

库，当然，是你不仅可以使用，而且现在可以自己编写的东西，无论是一个小模块还是你想与世界各地其他人分享的整个代码包。更好的是，你可以为你自己的代码、为你的库、为别人的代码编写测试。这样最终，你可以更加自信，不仅你的代码今天是对的。而且如果你明天对你的代码做了更改，你没有破坏任何东西，至少根据你的测试，如果它们继续通过的话。

文件 I/O，与此同时，是一种现在不仅将数据存储在计算机内存中（像所有这些羊一样），而且实际上将东西持久地、长期地存储到磁盘上的方式，无论是 CSV 文件还是更像二进制文件（如图像）。

通过正则表达式，你然后有了表达模式并实际验证数据或从信息中提取数据的能力。在当今世界，当如此多的人试图大规模分析和处理数据时，这是一项更有用的技术，其中一些数据从一开始可能就相当混乱。

然后，当然，最近的是面向对象编程，一个以稍微不同的视角解决同样问题的机会，一种封装和表示现实世界实体的方式，这次是在代码中。

今天，当然，是“等等”（et cetera），还有许多其他工具你可以添加，它们不一定属于任何早期那些范畴，但它们是有用的函数、数据类型和技术，同样可以放在你的后备口袋里，作为解决问题的又一种机制。

不仅仅是让每个人都睡着，我想另一种结束的方式可能是更大声一点，尝试一起编写最后一个程序，这个程序使用了我们过去见过的库，以及另一个。

我冒昧地在我的电脑上安装了一个文本转语音（text-to-speech）库。我将，也许，在 VS Code 中打开一个新文件，叫做 `say.py`。

我将首先导入我们自己的朋友，`import cowsay`。我将导入这个新库，`import pyttsx3`，Python 文本转语音库。现在，根据我预先阅读的它的文档，我将在这里为自己创建一个变量，`engine = pyttsx3.init()` 来初始化那个文本转语音库。

然后我将问用户，嗯，我想听到什么被说出来？我可能会做类似这样的事情。一个名为 `this` 的变量等于 `input("What's this? ")` 的返回值。这将是我的简单问题。这次我将保留它作为字符串。

我们已经看到了如何使用 `cowsay`。我们可以做 `cowsay.cow(this)`。事实证明，这个新库可以允许我使用它自己的引擎也来说 `this`：`engine.say(this)`。但最终，我将不得不运行 `engine.runAndWait()`，以防它是要说的长短语或句子。

但就这样了。仅仅八行代码，我不仅显然会让一头牛出现在屏幕上来结束我们现在的课程，而且还会有一些合成文本。

最终，我们希望通过这门课程，你不仅学会了 Python，你不仅学会了编程，而且你真正学会了如何解决问题，最终学会了如何自学新语言。有趣的是，我自己也是几年前才学会 Python 的。即使我当然通过了一些正式的文档和在线资源，我主要学到我现在知道的，甚至包括我今天为了讲课不得不重新学习的东西，都是通过问很多问题，无论是问 Google，还是问比我更精通这门语言的朋友。

所以，拥有那种直觉，拥有那种词汇量来向他人提问，来搜索问题的答案，你现在绝对在 Python 和编程方面有了足够的基础，可以走出去独立自主了。所以你当然可以——并且欢迎和鼓励你继续学习 Python 和编程方面的其他课程。但更好的是，尽快找到一个你个人感兴趣的、使用 Python 或其他语言的项目。因为至少从我自己的经验来看，我倾向于通过实际应用这些技能来学得最好，我希望你也可能如此。不是课堂上的问题，而是真正现实世界中的问题。

说了这么多，请允许我看看我的全屏终端窗口。运行 `python say.py`，最后一次祈祷我没有犯任何错误或 bug。开始了。`python say.py` 提示我，`What's this?`。我们就在这里结束吧。

**计算机（合成声音）：** This was CS50.


---
# 要点回顾

**CS50P 第 9 讲 - Et Cetera (补充内容)**

**一、 引言与回顾**
- 本讲座聚焦于 Python 中一些未在前几周核心主题（函数、变量、条件、循环、异常、库、单元测试、文件IO、正则表达式、面向对象编程）中深入探讨、但同样有用的补充特性和概念（"Et Cetera"）。
- 目标是展示 Python 的更多功能，并激发进一步自学的兴趣。
- 强调 Python 官方文档 (`docs.python.org`) 的重要性。

**二、 `set` (集合)**
- 概念：一种无序且不包含重复元素的数据结构，类似于数学中的集合。
- 用途：非常适合自动去除重复项。
- 示例：从包含学生姓名和学院的字典列表中，提取所有唯一的学院名称。
    - 对比方法1 (使用列表)：创建一个空列表，遍历学生列表，检查学院是否已在列表中，若不在则添加。需要手动去重。
    - 对比方法2 (使用集合)：创建一个空集合 (`houses = set()`)，遍历学生列表，直接使用 `.add()` 方法将学院添加到集合中。集合会自动处理重复项，代码更简洁。
- 集合操作：
    - 创建空集合：`set()`
    - 添加元素：`.add(element)`
    - 检查成员：使用 `in` 关键字 (例如 `if "Gryffindor" in houses:`)

**三、 `global` 关键字与变量作用域**
- 概念：在函数外部定义的变量通常具有“全局”作用域（严格来说是模块作用域）。
- 读取全局变量：函数内部可以直接读取（访问）全局变量的值。
- 修改全局变量的问题：
    - 默认情况下，在函数内部尝试修改全局变量（例如使用 `+=`）会导致 `UnboundLocalError`。Python 默认将赋值操作视为创建局部变量。
- 解决方案：在函数内部使用 `global` 关键字声明变量，明确告知 Python 意图修改的是全局变量。
    - 语法：`global variable_name`
- 更好的替代方案 (面向对象)：
    - 使用类 (Class) 来封装相关的数据（如账户余额 `balance`）和操作（如 `deposit`, `withdraw` 方法）。
    - 实例变量 (`self.variable`) 可以在类的所有方法中访问和修改，避免了 `global` 关键字的需要，提高了代码的封装性和可维护性。
    - 强调：通常应尽量少用全局变量，优先考虑类封装或函数参数传递。

**四、 常量 (Constants)**
- 概念：指初始化后其值不应再改变的变量。
- Python 的方式：Python 语言本身不强制执行常量性，而是依赖 *约定*。
- 约定：使用全大写字母的变量名 (例如 `MEOWS = 3`) 来向其他开发者或未来的自己 *表明* 这个变量应该被视为常量，不应修改。
- 示例：
    - 模块级常量：在文件顶部定义 `MEOWS = 3`，然后在代码中使用 `range(MEOWS)`，比硬编码数字 `3` 更清晰、易维护。
    - 类级常量：在类定义内部、方法外部定义全大写变量 (例如 `class Cat: MEOWS = 3`)，通过类名访问 (`Cat.MEOWS`)。

**五、 类型提示 (Type Hints) 与 `mypy`**
- 背景：Python 是动态类型语言（类型在运行时确定），灵活但可能隐藏类型相关的错误。
- 概念：允许开发者为变量、函数参数和返回值添加类型标注，以表明期望的类型。
- 语法示例：
    - 变量：`variable: type = value` (例如 `number: int = 5`)
    - 函数参数：`def func(param: type): ...` (例如 `def meow(n: int): ...`)
    - 函数返回值：`def func(...) -> return_type: ...` (例如 `def greet() -> str: ...`)
    - 无返回值：`-> None`
- 作用：
    - 类型提示本身在运行时通常不被 Python 强制执行。
    - 主要用于提高代码可读性、可维护性，并供静态类型检查工具使用。
- 工具 (`mypy`)：
    - `mypy` 是一个流行的静态类型检查器。
    - 运行 `mypy your_script.py` 可以在 *运行代码前* 分析类型提示，发现潜在的类型不匹配错误（例如，将字符串传递给期望整数的函数）。
    - 有助于早期发现和修复 bug，进行防御性编程。

**六、 文档字符串 (Docstrings)**
- 概念：一种标准化的、用于为 Python 模块、类、函数或方法编写文档的方法。
- 语法：使用三引号 (`"""Docstring content"""` 或 `'''Docstring content'''`) 紧跟在定义之后的第一行。
- 内容：通常包括对代码功能的简要总结、详细说明、参数描述、返回值描述、可能抛出的异常等。
- 格式约定 (例如 reStructuredText 风格)：
    - `:param name: description` (参数描述)
    - `:type name: type` (参数类型)
    - `:return: description` (返回值描述)
    - `:rtype: type` (返回值类型)
    - `:raises ExceptionType: condition` (抛出的异常)
- 作用：
    - 提高代码可读性。
    - 被多种工具（如 IDE、文档生成器 Sphinx）用来自动生成帮助信息和项目文档。

**七、 `argparse` 模块**
- 问题：手动处理命令行参数 (`sys.argv`) 很快会变得复杂，特别是需要支持标志 (flags)、选项、不同顺序、类型转换和帮助信息时。
- 解决方案：`argparse` 是 Python 内置的库，用于轻松创建用户友好的命令行接口。
- 使用流程：
    1.  `import argparse`
    2.  创建解析器对象：`parser = argparse.ArgumentParser(description="...")`
    3.  添加参数定义：`parser.add_argument("-n", "--number", help="...", type=int, default=1)`
        - 可以定义短标志 (`-n`)、长标志 (`--number`)、帮助文本 (`help`)、自动类型转换 (`type`)、默认值 (`default`) 等。
    4.  解析命令行参数：`args = parser.parse_args()` (自动读取 `sys.argv`)
    5.  访问参数值：通过 `args` 对象的属性访问 (例如 `args.n` 或 `args.number`)。
- 优点：自动化处理参数解析、帮助信息生成 (`-h`/`--help`)、类型检查、默认值、错误处理，大大简化命令行程序开发。

**八、 解包 (Unpacking)**
- 概念：将可迭代对象（如列表、元组）的元素分配给多个变量，或将它们作为独立的参数传递给函数。
- 变量赋值解包：`first, last = name.split()`
- 函数参数解包 (`*` - 位置参数)：
    - 将列表或元组的元素作为独立的位置参数传递给函数。
    - 语法：`function(*iterable)` (例如 `total(*[100, 50, 25])` 等同于 `total(100, 50, 25)`)
- 函数参数解包 (`**` - 关键字参数)：
    - 将字典的键值对作为独立的关键字参数传递给函数。
    - 字典的键必须与函数的参数名匹配。
    - 语法：`function(**dictionary)` (例如 `total(**{"galleons": 100, "sickles": 50, "knuts": 25})` 等同于 `total(galleons=100, sickles=50, knuts=25)`)

**九、 函数定义中的 `*args` 和 `**kwargs`**
- 目的：定义能接受可变数量参数的函数 (Variadic functions)。
- `*args`：将函数调用中所有多余的 *位置* 参数收集到一个元组 (tuple) 中（变量名 `args` 是约定，可自定义）。
    - 示例：`def func(a, b, *args): ...`
- `**kwargs`：将函数调用中所有多余的 *关键字* 参数收集到一个字典 (dict) 中（变量名 `kwargs` 是约定）。
    - 示例：`def func(a, b, **kwargs): ...`
- 结合使用：`def func(*args, **kwargs): ...` 可以接受任意数量的位置和关键字参数。`print` 函数就是这种机制的例子。
- 用途：创建高度灵活的函数、包装函数（将接收到的参数原样传递给内部调用的另一个函数）。

**十、 函数式编程相关特性 (`map`, `filter`)**
- 背景：Python 支持多种编程范式，包括过程式、面向对象和一定程度的函数式编程。
- `map(function, iterable)`：
    - 将 `function` 应用于 `iterable` 中的每一个元素。
    - 返回一个 map 对象（迭代器），通常用 `list()` 转换为列表。
    - 示例：`list(map(str.upper, ["hello", "world"]))` 结果为 `['HELLO', 'WORLD']`。
- `filter(function, iterable)`：
    - 使用 `function` 测试 `iterable` 中的每个元素。
    - 返回一个 filter 对象（迭代器），包含所有 `function` 返回 `True` 的元素。
    - `function` 必须返回布尔值。
    - 示例：`list(filter(lambda x: x > 0, [-1, 0, 1, 2]))` 结果为 `[1, 2]`。

**十一、 列表推导式 (List Comprehensions)**
- 概念：一种简洁、Pythonic 的语法，用于根据现有可迭代对象创建新列表。
- 语法：
    - 基本：`[expression for item in iterable]`
    - 带条件：`[expression for item in iterable if condition]`
- 示例：
    - `[x*x for x in range(5)]` 结果为 `[0, 1, 4, 9, 16]`。
    - `[name for name in names if name.startswith("A")]` 筛选出以 "A" 开头的名字。
- 优点：通常比使用 `map`, `filter` 或手动循环加 `append` 更紧凑、可读性（习惯后）更高。

**十二、 字典推导式 (Dictionary Comprehensions)**
- 概念：类似列表推导式，但用于简洁地创建字典。
- 语法：`{key_expression: value_expression for item in iterable if condition}`
- 示例：`{x: x*x for x in range(5)}` 结果为 `{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}`。

**十三、 `enumerate` 函数**
- 问题：在迭代时同时需要元素的索引和值。
- 解决方案：`enumerate(iterable, start=0)` 返回一个产生 `(index, value)` 对的迭代器。
- 语法：`for index, value in enumerate(my_list): print(f"{index+1}: {value}")` (实现 1-based 索引输出)。
- 优点：比手动维护索引计数器或使用 `range(len(...))` 更简洁、更 Pythonic。

**十四、 生成器 (Generators)、迭代器 (Iterators)、`yield` 关键字**
- 问题：当函数需要产生非常大量的数据（例如一个包含数百万项的列表）时，一次性在内存中创建整个数据结构可能会耗尽内存导致程序崩溃。
- 概念 (生成器)：一种特殊的函数，它不一次性返回所有结果，而是返回一个 *迭代器*，该迭代器可以一次 *产生 (yield)* 一个值。
- `yield` 关键字：在函数中使用 `yield` 代替 `return` 来返回值。每次 `yield` 执行后，函数的状态会被保存，下次迭代时从暂停处继续执行。
- 迭代器 (Iterator)：一个对象，表示一个数据流，可以逐个访问其元素。生成器是创建迭代器的一种简便方式。
- 示例 (数羊)：
    - 低效方法：创建一个包含 N 行羊字符串的巨大列表并返回。
    - 生成器方法：`def sheep_generator(n): for i in range(n): yield "🐑" * i`。这个函数在被迭代时（如 `for s in sheep_generator(1000000): print(s)`），每次循环只生成并 `yield` 一行羊，极大节省内存。
- 优点：内存效率极高，可以处理理论上无限的数据流，按需生成数据。

**十五、 结论与展望**
- 本讲涵盖的都是工具箱中的额外工具，补充了之前学习的基础知识。
- 强调了学习编程是一个持续的过程，早期难点现在可能已变得简单。
- 核心能力是解决问题和自学能力（利用文档、搜索、提问）。
- 鼓励将所学知识应用到个人感兴趣的项目中，这是最好的学习方式。
- 最终演示：结合 `cowsay` 和 `pyttsx3` (文本转语音库) 的小程序。
- 传达信息：学生现在已有足够的基础去探索更广阔的编程世界。


# 「哈佛CS50P-Python编程导论」第3讲-异常

- 视频链接：[CS50P - Lecture 3 - Exceptions](https://www.youtube.com/watch?v=LW7g1169v7w&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=5)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---

### 内容介绍

本篇内容整理自哈佛大学CS50P Python编程入门课程的第三讲，主题为“异常”（Exceptions）。在编程实践中，无论是初学者还是经验丰富的开发者，都无法完全避免程序在运行时出现各种预料之外的问题。本讲座旨在系统性地介绍Python中处理这些运行时错误的核心机制——异常处理。

讲座首先区分了必须由程序员在运行前修复的语法错误（SyntaxError）与可在程序运行时捕获并处理的运行时错误，重点讲解了常见的ValueError（值错误）和NameError（名称错误）及其发生场景。随后，详细介绍了Python提供的`try...except`基本结构，以及用于完善错误处理逻辑的`else`子句和`pass`语句。讲师通过一个逐步演进的实例——从用户获取有效整数输入，演示了如何结合循环与异常处理来构建更健壮、用户友好的代码。最后，讲座还探讨了如何将相关逻辑封装成可复用的函数，并引入函数参数以增强其通用性。


### 内容纲要

```
CS50P Lecture 3: 异常 (Exceptions)
├── 1. 异常简介
│   └── 定义：程序运行时发生的问题或错误
├── 2. 常见错误类型
│   ├── 语法错误 (SyntaxError)
│   │   ├── 特点：代码不符合语法规则，阻止程序运行
│   │   └── 示例：`print("hello` (缺少引号)
│   └── 运行时错误 (Runtime Errors)
│       ├── 值错误 (ValueError)
│       │   ├── 定义：函数接收到类型正确但值不合适的参数
│       │   └── 示例：`int('cat')`
│       └── 名称错误 (NameError)
│           ├── 定义：使用未定义的变量
│           └── 示例：在赋值失败后尝试访问变量
├── 3. 异常处理机制
│   ├── try...except
│   │   ├── 作用：尝试执行可能出错的代码，并在出错时处理
│   │   └── 关键：应捕获特定类型的异常 (如 `except ValueError:`)
│   ├── else 子句
│   │   └── 作用：当 `try` 块未发生异常时执行
│   └── pass 语句
│       └── 作用：在 `except` 块中捕获异常但选择不执行任何操作
├── 4. 结合循环实现健壮的用户输入
│   ├── 问题：简单输入在出错时不够健壮
│   └── 方案：使用 `while True` 循环结合 `try-except`
│       └── 逻辑：循环提示 -> 尝试转换 -> 成功则 `break`/`return` -> 失败则 `except` 处理后继续循环
├── 5. 通过函数封装与改进
│   ├── 抽象化：将获取整数的逻辑封装到 `get_int()` 函数
│   ├── 代码组织：使用 `main()` 函数作为程序入口
│   └── 函数参数化
│       └── 改进：为 `get_int()` 添加 `prompt` 参数，提高复用性
└── 6. 总结
    ├── 错误不可避免性
    ├── 处理异常的重要性与工具 (`try`, `except`, `else`, `pass`)
    └── 提及 `raise` (主动抛出异常)
```


## CS50P - 第 3 讲：异常 (Exceptions)

### 1. 异常简介

好的，这里是CS50的Python编程入门课程，我是David Malan。这是我们关于“异常”（Exceptions）的一周。在Python以及其他编程语言中，异常指的是你代码中出现的问题。实际上，当你的程序中出现“异常”情况时，这通常不是一件好事，而是意味着某些环节出了问题，理想情况下你需要设法解决它。那么，具体有哪些可能出错的情况呢？

### 2. 常见错误类型

#### 语法错误 (SyntaxError)

我现在打开VS Code，在终端窗口运行 `code hello.py` 命令，这会为我打开一个名为 `hello.py` 的新标签页，我可以在里面编写代码。让我们来写一段非常简单的代码，向世界问好。输入 `print('hello, world` ... 哦，我忘了关闭那个引号。这是一个你自己可能已经犯过，或者将来肯定会犯的错误，而且它有点隐蔽，你可能不会立刻注意到少了一个字符。好吧，让我满怀希望地回到终端窗口，运行 `python hello.py` 并回车。这就是我的第一个错误！天哪，我只写了一行代码，屏幕上却显示了更多行的错误信息。但关键在于最底下的这句：`SyntaxError`。语法错误指的是你输入的代码本身存在问题。你的语法，就像英语和其他人类语言有其语法规则一样，我的代码也有，而这里的语法不完全正确，有些地方不对劲，我没有完全遵循规则。它还为我详细说明了：`unterminated string literal`（未终止的字符串字面量）。这个说法有点晦涩难懂，但“未终止”（unterminated）通常意味着我开始做某事但没有结束它。“字符串”（string）当然是我们之前讨论过的文本序列，在Python中是 `str`。“字面量”（literal）通常指你确实是逐字输入的内容，它不是变量，而是像引号括起来的内容，比如这里的 `'hello world`。所以，这里的解决方法自然是去终止那个字符串，加上结束的引号。如果我现在回到终端窗口，重新运行 `python hello.py`，现在我就成功地向世界问好了。

关于语法错误的关键点在于，解决它们完全是你的责任。语法错误是你必须从一开始就回到代码中去修复的问题。你不能指望它会自动解决，也不能期望代码的其他部分会为你捕获它。语法错误必须被修复。

#### 运行时错误 (Runtime Errors)

但是，Python中还有很多其他类型的错误，可以被描述为“运行时错误”（runtime errors），它们发生在你的代码运行时。而你确实有责任编写一些额外的防御性代码来检测这些错误的发生，因为你无法预知，例如，用户会在你的程序中输入什么内容。因此，你最好做好防御准备，以适应他们输入的内容，甚至是错误输入的内容。

#### 值错误 (ValueError)

让我们回到VS Code，我建议我们来看一个全新的文件。我将关闭 `hello.py`，然后编写 `code number.py`。让我们来用Python处理一些数字。在打开这个新标签页 `number.py` 后，我要做的第一件事是编写一个相对简单的程序，它可能会提示用户输入一个整数，比如x，然后仅仅打印出x的值。所以我们从非常简单开始，但同样，从简单开始，我们能更清楚地看到我可能做错了什么。

好，我要定义一个名为x的变量，它将被赋予 `input('What's x? ')` 函数返回值的... 等等，如果我想从用户那里获取一个 `int`（整数），我需要主动做些事情。我需要使用Python中的 `int()` 函数将输入实际转换为整数。所以现在，我将 `input` 的返回值作为参数传递给 `int`，并将结果（最终是一个整数，而不是看起来像整数的字符串）存储在x中。好了，现在让我简单地打印出结果。我要打印 `f'x is {x}'`。我不想直接打印'x is x'，而是想插入x的实际值，所以最简单的方法可能是用花括号 `{}` 将其包围。如果我使用这些花括号，并且希望Python插入该变量的值（即在花括号之间替换x的实际内容），我需要使用格式化字符串（f-string），方法是在整个字符串前加上一个 `f`。

完成这些之后，让我们看看会发生什么。在我的终端窗口中，运行 `python number.py`，回车。到目前为止一切顺利，程序提示我输入x。让我输入一个数字，比如50。好的，这似乎可行，程序看起来是正确的。真的是这样吗？即使刚才没有出错，这个程序中还有什么可能出错？如果我一次又一次地运行它，在我的程序运行期间，还有什么可能出错？特别是如果与程序交互的不是我，而是其他用户呢？这里有谁知道答案吗？什么可能出错？这个程序在哪些方面实际上并不完全正确，尽管乍一看似乎如此？

**问：** （听众尝试回答，声音不清晰）
**答：** 我没太听清，但我想我听到的是，如果用户输入的实际上不是一个整数，我就不能盲目地将其转换为 `int`。如果没有曲解你的意思，我想我或许应该采取一些防御措施。让我看看我是否能模拟出可能出错的具体问题。

让我再次运行 `python number.py`。让我试试另一个数字。实际上，在测试代码时，通常最好测试“边界情况”（corner cases），也许是一些不像50、49或51那么普通的数字。让我们选择一些可能更有趣的数字，哪怕只是在数学上，比如0。好的，0似乎也能工作，我的代码仍然打印出x是0。还有什么其他的边界情况需要考虑？嗯，让我试试一个负数，这在性质上也与50很不同。负1，好的，这也行。好吧，让我再试一次。我试了正数、负数、零，现在让我试试像“cat”这样的东西。字面上就是输入c-a-t，一个甚至看起来都不像数字的字符串。现在让我们看看当我按下回车时会发生什么。

好了，现在我们遇到了另一种错误。这不是 `SyntaxError`，因为我没有犯拼写错误，没有忘记任何语法部分。我现在遇到的，是一个关于我的“值”（value）的错误，而且是一个我甚至没有预料到的值——是用户（在这个例子中是我自己）在我编写代码很久之后才输入的。那么这个 `ValueError` 指的是什么呢？让我们看看解释：`ValueError: invalid literal for int() with base 10: 'cat'`（对于基数为10的int()而言，无效的字面量 'cat'）。这也有点绕口。不幸的是，在Python和许多编程语言中，错误消息通常是为相当有经验的程序员编写的。当然，当你第一次学习编程时，你可能对编程语言本身就不太熟悉，更不用说错误消息了。但让我们试着从中获取一些信息。“invalid literal”（无效字面量），再次强调，字面量就是输入的内容。“for int()”，`int` 正是我用来将用户输入转换为相应整数的函数。“base 10”（基数10）指的是十进制系统，这是Python使用的默认进制。看起来，归根结底，Python真正不喜欢的是我将 `'cat'` 这个字符串传递给了 `int` 函数。

那么，我该如何着手解决这个问题呢？我可以在程序中添加说明，也许可以加一行 `print` 语句，更明确地告诉用户“请确保输入一个整数”或“请不要输入cat”或“请不要输入字符串”。当然，用户可能仍然不遵守，他们可能不阅读说明，所以这可能也不是一个有效的策略。我们真正想要做的是，在编写代码时就考虑到错误处理。我们想要编写的代码行，不仅能完成我们关心的任务，还能处理可能意外发生的错误。总的来说，进行防御性编程时，要假设用户不会注意，或者更糟，他们是恶意的，试图让你的程序崩溃。所以我们希望尽可能多地处理错误。

#### 名称错误 (NameError)

(在讨论将`print`移出`try`块的场景下)
现在我将把第3行（打印语句）移到我代码的底部。我不再需要缩进它，我只是在文件末尾执行它。不幸的是，这样做虽然通过最小化 `try` 块中可能引发异常的代码量（现在只尝试做可能引发 `ValueError` 的最少量必要工作）做了一件好事，但我担心我引入了一个新的错误。好吧，让我们看看现在哪里不正确了。让我再次运行 `python number.py`，回车。让我先用50正确地运行一次，一切似乎都好。但同样，让我们试试那些边界情况：0、负数，或者在这种情况下，输入 'cat'。让我再次输入 'cat'，回车。

现在我遇到了 `NameError`。这是我代码中引入的又一种错误类型。这个 `NameError` 是什么意思呢？就像 `ValueError` 指的是某个变量的值或某人输入的值不正确一样，`NameError` 通常指你的代码本身的问题，比如你对一个变量名做了不该做的事情。这可能是为什么呢？让我们回到代码这里思考一下。`NameError` 是我在下面看到的错误，它告诉我 `name 'x' is not defined`（名称 'x' 未定义）。注意，如果我再看仔细点，它提到了第6行。所以我知道问题出在我第6行的代码上。而那行代码刚才还能工作，并且我在第2行定义了x。但让我问问大家，为什么x在第6行实际上不存在？为什么它没有被定义，尽管我很确定我打算在第2行定义它？

**问：** （听众）也许是变量的作用域（scope）只在 `try` 块内部？

**答：** 很好的术语。“作用域”指的是变量存在的代码部分。但这在Python中也不完全正确。在C、C++和Java中这可能是对的，那些语言中缩进或花括号通常定义了变量的作用域。但在这里，总的来说，而且刚才也确实成功过，x一旦在第2行被定义就应该存在，因为记得我刚才打印出了 'x is 50'。

**问：** （另一听众）那是因为它是局部变量（local variable）吗？意思是它在作用域之外没有定义，就像大家提到的？它在 `try` 中提示输入，但在外部是未定义的？

**答：** 仍然是很好的直觉和术语。确实有局部变量的概念，它们通常存在于函数内部，还有全局变量（global variables），它们通常存在于整个文件中。但在这种情况下，这也不是根本原因。这里发生的事情归结为运算顺序。让我们回到代码，回想一下我们讨论赋值运算符（单个等号 ` = `）时，它总是将右边的值复制到左边。但请思考一下，问题是在哪个环节发生的？`input()` 函数可能工作正常，因为我们已经用了很多次来获取用户输入，它总是返回一个字符串（在Python中是 `str`）。但什么可能出错呢？如果我将那个字符串传递给 `int()` 函数作为其参数，很可能是 `int()` 函数出错了。实际上，如果你回想一下之前我们遇到 `ValueError` 的时候，确实是 `int()` 函数不喜欢 `'cat'` 这个输入。这一切都说明，我代码中现在高亮显示的、等号右边的这部分，才是产生问题的代码，是它产生了 `ValueError`。在这种情况下，我们捕获了 `ValueError`，但是因为 `ValueError` 发生在等号的右边，没有值被复制到左边。错误中断了整个赋值过程。所以，尽管我们在第2行看到了 `x = ...`，但由于 `ValueError` 发生得太早，那一行等号左边的部分最终没有被执行到。因此，当我们最终执行到第6行时，尽管看起来我本应在第2行定义了x，并且如果一切顺利的话我确实会定义x，但我们没有进入到值从右到左被复制的那一步，因为 `ValueError` 先发生了。所以这段代码现在就是不正确的。

### 3. 异常处理机制

#### `try` 和 `except`

那么，在Python中我们该如何做到这一点呢？事实证明，无论你是想捕获 `ValueError` 还是其他类型的错误（尽管不包括 `SyntaxError`），Python实际上有一个名为 `try` 的关键字，它的命名很贴切。如果你想在Python中“尝试”做某事，你可以直接使用这个关键字，并且你可以检查是否有异常的、错误的事情发生。因此，结合使用 `try` 和另一个关键字 `except`，我就可以尝试做某件事，除非（except）出了问题，我才能转而做其他事情。

让我们思考一下，我该如何尝试将用户的输入转换为整数，除非（except）出了问题？让我回到我的代码这里，我建议现在像下面这样修改这个例子。让我先在我代码的第一行上面写上 `try:`，告诉Python尝试执行下面的操作。然后我将现有的代码行（第2、3行）都缩进相同的空格数，这里是4个空格。接着，我在下面添加新的一行，明确写上 `except ValueError:`。注意，我大写了V和大写了E，这些符号是大小写敏感的。现在，在这个冒号之后，就有机会告诉Python，在发生异常情况时，即用户的输入实际上不是一个数字时，我想要做什么。我将简单地说一句，比如 `print('x is not an integer')`。我至少要告诉用户大致的问题所在。

注意另一个细节：缩进很重要。因为我在第1行写了 `try`，并且缩进了第2行和第3行，所以这两行代码是我要“尝试”执行的。除非（except）我遇到了 `ValueError`，那么因为第5行被缩进了，它才会在发生那些错误时被执行。

现在让我回到终端窗口，运行 `python number.py`，回车。让我们再次输入50。仍然能工作。当然，这是因为我尝试了并且成功了。让我再试一次，但这次用单词 'cat'，或者任何不是十进制数字的东西。现在你会看到更清晰的输出：'x is not an integer'。我没有看到之前那个吓人的错误信息，作为用户，我完全不知道该如何处理。现在，作为程序员的你，已经预料到可能会发生异常情况，并且实际为用户处理了错误，给出了一个合适的错误消息。

让我在这里暂停一下，看看现在对于我们刚刚通过引入 `try` 和 `except` 来处理这个 `ValueError` 是否有任何问题？

**问：** `ValueError` 是唯一能捕获的错误类型，还是有其他类型？
**答：** 还有其他错误，我们今天会看到其中的一些。老实说，还有很多很多，如果你继续编程，特别是在Python中编程，未来几周、几个月、几年里你会遇到很多。但处理它们的技术大体上是相同的。

**问：** 使用 `except` 块，你需要知道错误的类型，对吧？比如这里你知道是 `ValueError`。但如果你无法预见到这种特定类型的错误怎么办？
**答：** 非常好的问题。我现在非常精确地“捕获”了我明确知道可能会发生的错误。我不知道它何时会发生，因为这取决于用户，但我知道 `int()` 函数可能会抛出哪种错误。Python中有一种方法，你可以说 `except` 如果任何事情出错，你可以直接省略 `ValueError`，捕获所有错误。这样做的问题在于，它有时会隐藏你代码中的其他bug，因为你不一定知道到底哪里出了错。如果你不确定哪里出了错，你怎么可能正确地处理它呢？所以，这样做是糟糕的实践，换句话说，这样做很“懒惰”——仅仅说“捕获所有错误，我来处理”。因此，更好的做法是弄清楚可能发生哪些类型的错误，并像我现在这样明确地提及它们。话虽如此，如果你阅读Python的官方文档（你最终不可避免地会这样做），它在主动告诉你哪些类型的错误可能以这种方式被“引发”（raise）方面做得并不好。所以这有点自相矛盾的建议：你应该这样做（明确捕获），但并不总是很明显你应该检查什么。不过，通过实践你会越来越擅长。一些时候，文档确实会说明可能出错的地方。

#### `else` 子句

那么我该如何解决像（之前NameError的）这样的问题呢？事实证明，Python支持的 `try` 和 `except` 语法还有另一个特性，那就是它也支持关键字 `else`。我们之前见过 `else`，回想一下我们讨论条件语句的时候，我们看到了 `if`、`elif` 和 `else`，`else` 有点像一种“包罗万象”的选项，用于在其他条件都不相关时执行操作。这里的 `try...except` 特性中的 `else` 也有类似的直觉。你可以这样做：你可以 `try`（尝试）执行下面的操作，就像我刚才做的；`except`（除非）如果发生这个错误；但是，如果什么错误都没发生，`else`（那么）就继续做这件事。

这是我现在解决同一个问题的一种方法。现在，无论如何，Python都会尝试执行第2行。如果出了问题，它会执行第3行和第4行来处理那个 `ValueError`。然而，如果你 `try`（尝试）并且这段代码成功了，那么就没有异常需要处理，所以你接下来将执行这里的 `else` 块中的代码（第5、6行）。这可能有点令人困惑，因为我们现在既在条件语句 (`if...elif...else`) 中使用 `else`，也在 `try...except` 块中使用 `else`。但这没关系，这是语言的一部分，是其特性之一。

所以，如果我现在在终端窗口重新运行这段代码 `python number.py`，先输入正确的内容，比如50，我看到 'x is 50'。所以，第1行被执行，我们尝试做下面的事情；第2行被执行，因为转换成功进行，数字50从右到左被复制到x中；异常没有发生，所以我们忽略第3行和第4行；我们直接跳转到第5行和第6行，打印出结果。相比之下，让我们最后再做一次：`python number.py`，输入 'cat' 或其他任何单词，回车。现在我们看不到x是什么，而是看到 'x is not an integer'，这是在我的 `except` 子句中处理的。

好了，让我在这里暂停一下，因为这里有很多新语法。看看这里是否还有关于 `try`、`except`、`else`、`NameError` 或 `ValueError` 的任何问题？

**问：** （听众，对之前的NameError提问）你能重复一下 `NameError` 的问题吗？
**答：** 是的，是的。让我们回退几行代码，在我用 `else` 修复这个问题之前。刚才我们有这样的代码（演示没有`else`的版本），我得到了一个 `NameError`。运行 `python number.py`，输入 'cat'，看起来像这样：`NameError: name 'x' is not defined`，并且根据这个Python输出，问题在第6行。好吧，让我们现在推导一下。试着用不同的方法思考。在第6行，我看到一个错误说名称x未定义。好的，Python已经告诉我x在那一点上不存在。那么这怎么可能呢？x应该在哪里定义？按理说，x应该在上面的第2行定义。那么什么可能出错呢？如果用户输入了看起来不像数字的东西，比如单词 'cat'，将 'cat'（`input` 的返回值）作为参数传递给 `int` 函数来将单词转换为整数是毫无意义的。你根本无法将 'cat' 转换为整数。所以 `int` 函数在那个点上引发了 `ValueError`。而这个错误被这里的代码（`except`块）处理了。但请注意，这个第6行没有缩进，它与我代码的其余部分左对齐，这意味着无论如何第6行都会执行。无论我输入的是50还是 'cat'，它都会执行。但是，如果我输入了 'cat'，再次强调，x从未获得一个值，所以它在第6行是未定义的。因此，当我最终引入 `else` 语句时，它确保了这些部分是互斥的：我只有在上面的 `try` 尝试并成功之后，才会执行 `else` 部分。

#### `pass` 语句

假设你发现你的程序有点“吵闹”，不断地告诉用户 'x is not an integer', 'x is not an integer', 'x is not an integer' 有点烦人。如果你想让事情更温和一些，只是用同样的提示语再次提示用户：'What's x?', 'What's x?', 'What's x?' 一遍又一遍呢？你也可以这样做。事实证明，如果你想在Python中处理一个异常，但是你想“跳过”（pass on）对其做任何事情——也就是说，你想捕获它，但本质上想忽略它，你不想打印任何东西，不想退出程序，你只想默默地忽略它。就像你在一个满是人的房间里发言，轮到你说话时，你只是说“过（pass）”。他们仍然点到你了，但你没有做或说更多。

我们可以在代码中添加这个关键字。让我回到我的程序这里，与其一遍又一遍地打印 'x is not an integer'，我可以这样做：我可以 `pass`（跳过）进一步处理错误。我仍然在捕获它，所以用户不会看到任何提及 `ValueError` 的吓人消息。我的代码捕获了它，但我选择“跳过”对其发表任何评论。我将留在循环中，继续提示和重新提示用户。

所以现在的效果看起来有点像这样：运行 `python number.py`，输入 'cat'，（程序再次提示）'What's x?'。输入 'dog'，（再次提示）'What's x?'。输入 'bird'，（再次提示）。所以这只是，也许，对用户更友好一点，因为你只是在提醒用户你想要什么。也许更糟？也许告诉用户你为什么一遍又一遍地提示他们会更有帮助？这并不明显，所以两种方式都可能。但再次强调，这只是处理这些错误的另一种机制。我们使用 `except` 关键字来捕获特定的错误，但我们不必对其做更多处理，我们可以仅仅 `pass`（跳过）进一步的操作。

让我在这里暂停一下，看看现在对于 `try`、`except`、`else` 或 `pass` 是否有任何问题？

**问：** 好的，嗯，不，我只是有点好奇，关于你之前用 `get_int` 函数进行缩进时的想法... 因为我注意到，很明显，通过整个逻辑和对整个函数的分解，你知道 `while True` 做这个...但我只是有点好奇，想更详细地了解代码的缩进。

**答：** 是的，缩进是刻意为之的，符合逻辑。有些语言不要求如此严格的缩进，你可以使用花括号或其他符号来明确哪些部分与哪些相关联。总的来说，在Python中，任何时候你写一行代码，并且它下面的行以某种方式缩进，这意味着那些行与第一行以某种方式相关联。并且推测起来，那些缩进的行只有在第一行告诉计算机要执行它们时才应该被执行。具体来说，这意味着什么呢？在第6行这里，我们定义了一个名为 `get_int` 的函数，它不接受任何参数，冒号。之后所有至少缩进4个空格的内容都是该函数的一部分。为什么？这只是Python语言的设计。坦率地说，我认为设计者们厌倦了在像C、C++和Java这样的语言中看到非常丑陋的代码，这些语言不一定强制执行这种程度的缩进。所以现在它被内置到了语言中（我的时间顺序可能有点偏差，但在Python之前有很多语言在缩进方面比它更宽松）。缩进是有意义的。在第7行也注意，因为 `while True` 缩进了4个空格，这仅仅意味着它是 `get_int` 函数的一部分。但是注意，在 `while True` 语句下面，这里有8个、12个、8个、12个空格（我只是快速数了一下点），这意味着我刚刚高亮显示的所有行都在那个 `while` 循环内部。`while True` 意味着要潜在地一遍又一遍地执行第8行到第11行。最后，在第8行，因为我们有 `try` 并且下面缩进了第9行，这仅仅意味着你应该“尝试”的是第9行的内容。类似地，在第10行下面，我们缩进了第11行。你只应该在发生 `ValueError` 异常时才 `pass`。所以缩进仅仅表示什么与什么相关联。一旦你适应了这一点，你会发现它很有帮助——仅缩进本身就有助于解释你程序的逻辑。并且它有一个极好的副作用，那就是对于你自己第二天早上、对于你的同事、家人、朋友、老师来说，你的代码因此变得更易读。它不再是一大堆混乱的文本。

**问：** 谢谢。两个问题。问题一，一旦你说了 `pass`，调用者还能通过系统变量或其他方式了解到这个错误吗？问题二，（之前的）问题集0提到了包括 `isnumeric` 在内的一些字符串方法。在这里通过 `isnumeric` 来做有什么不同吗？

**答：** 好问题。关于第一个问题，如果我以这种方式处理错误，调用者将不会知道任何关于它的信息。这就是我处理它的目的——以便 `main` 或其他调用者不知道技术上出了任何问题。关于第二个问题，`isnumeric` 是你可以调用的另一个函数，它可以检查一个字符串并确定“这实际上是一个数字吗？”。我可以使用类似那样的机制。我可以使用条件语句：如果这个看起来像数字，那么就把它传递给 `int` 函数并将其转换为整数。那完全没问题。我通常会说，Pythonic（符合Python风格）的方式，通常（无论是好是坏）是去尝试事情，希望它们能工作，但如果不行，就处理异常。所以其他语言更倾向于检查：`if...if...if...elif...else`，使用所有这些条件语句。Python则更倾向于这种心态：试试看，但要确保你处理了错误。所以我们现在做的（`try...except`）是Pythonic的方式。不过，你的方式，先用条件语句检查它是否是数字，也是完全合理的，如果你想那样做的话。

### 4. 结合循环实现健壮的用户输入

好吧，让我建议我们进一步完善一下这个。并且思考一下我们如何能稍微改进这个例子。在我拒绝了用户未能提供整数的输入后，仅仅退出程序，这有点不友好，对吧？如果我能一次又一次地提示或重新提示用户，直到用户配合并给出我想要的东西，比如一个数字，那会更用户友好。那么，在聊天中，你们能告诉我，如果你想一遍又一遍地做某事，直到用户配合并给出你想要的东西（比如一个数字）为止，你可以使用Python的哪个特性？是的，循环（loop）。循环是重复发生的事情。也许我们可以使用同样的机制，一个循环，来提示用户输入x，如果他们不给数字，就再提示一次，如果还不给，就再提示一次，一次又一次。我们不必这么快就退出程序。

所以，我建议这样做：我建议在这里通过特意这样做来改进这段代码。让我在代码的最顶端引入一个无限循环：`while True:`。回想一下，`while` 关键字引入了一个循环、一个周期，它的行为是这样的：它会问一个布尔表达式的问题，该表达式需要评估为 `True` 或 `False`。那么，如果我想让这个东西（至少最初）永远循环下去，我们就说 `while True`，因为 `True` 就是 `True`。这产生的效果是，无论如何都会永远做某事，除非我们提前 `break`（跳出）。

现在，我要这样做：我将把我的 `try...except` 代码块移动到这个循环下面，并进行缩进，这样我就在尝试获取x。如果我遇到 `ValueError`，我就打印 'x is not an integer'。但这次，如果用户尝试并成功地给出了一个数字，我想要做什么呢？嗯，我可以这样做：我可以在这里（`else`块中）直接 `break`（跳出）我的代码。然后在这里下面，我现在可以使用之前那行相同的代码：一个f-string，内容是 `f'x is {x}'`。

那么这里发生了什么？我认为这段代码，因为我添加了循环，将具有这样的效果：它会尝试至少一次，也许第二次，也许第三次，也许500次，直到用户最终给我我想要的东西，也就是一个整数。一旦他们这样做了，一旦没有 `ValueError` 发生，那么我就 `break` 跳出循环，然后第9行如我所愿地执行。

好吧，让我尝试执行这个版本：`python number.py`，回车。'What's x?' 让我先输入简单的情况，50。'x is 50'。从这个程序的控制流（我的逻辑流程）来看，刚刚发生了什么？嗯，我首先发现自己处在第1行的循环中，希望我能跳出这个循环。然后我在第2行和第3行做了什么？我尝试从用户那里获取输入并将其转换为 `int`。这次我是个好人，输入了50，它看起来像并且确实是一个数字。所以 `int` 函数很好地转换了它，并将其从右到左存储在x中。`except ValueError`... 没有 `ValueError`，因为如果我输入了一个数字，就没有异常情况发生，这是我程序的正常、良好执行。那么发生了什么？我在 `else` 子句中 `break` 跳出了循环。所以再次强调，`else` 子句是与 `try` 相关联的，而不是与 `except`。一旦我跳出了循环，我当然就只是打印出x是什么。

好吧，让我们试试可能发生的另一种情况：`python number.py`，回车。'What's x?' 让我们试试 'cat' 或其他任何单词，回车。啊，这现在是一个新特性了。我被告知我做错了什么：'x is not an integer'。所以我得到了一些有用的用户反馈。但请注意，我又被提示 'What's x?'。好吧，让我试试输入 'dog'。'x is not an integer'。'What's x?' 让我试试 'bird'，回车。'x is not an integer'。'What's x?' 不用多说，这现在会永远发生，如果我处于无限循环中，直到我尝试并成功为止，那时我才会 `break` 跳出。所以让我们再试一次，50，回车。现在我跳出了循环，并且打印出了x的实际值。

好了，让我在这里暂停一下，看看是否有任何问题。逻辑几乎是一样的，但现在的不同之处在于我处于一个循环中，并且我正在使用Python中的关键字 `break` 来在我准备好时（一旦用户配合了）故意跳出循环。

**问：** 我们真的需要 `break` 吗？我们不能只是打印吗？或者是什么阻止我们仅仅打印？

**答：** 好问题。那么让我试试。我不能只打印吗？让我们看看如果我这样做会发生什么。让我把结尾的这行 `print` 移到我的循环内部，从而缩短程序（通常这是件好事）。运行 `python number.py`，回车。让我输入50。好的，'x is 50'。'What's x?' 嗯，好吧，也许是49。'x is 49'。嗯，好吧，也许是48。不幸的是，我想你...你在笑，你看到了。我永远不会跳出循环。也许这是个特性？也许你希望你的程序就是这样？但我不想，我希望这个游戏最终能停止。所以我需要以那种方式 `break` 跳出。

但我可以稍微不同地做。(回到使用 break 的版本)

**问：** 我可以在 `else` 之外的其他地方使用 `break` 吗？例如，在 `try` 内部的另一个 `print` 语句之后？当你用 `else` 打印时，可以把 `print` 和 `break` 放在一起吗？

**答：** 你可以在循环内部使用 `break` 来跳出循环。你也可以在条件语句（如 `if`、`elif` 或 `else`）内部使用它。你也可以在 `try...except...else` 语句内部这样做。任何时候你处在一个你想跳出的循环中，你都可以使用这个关键字 `break`。我只是在异常的上下文中使用它，但它并不局限于此。让我给你看看，它甚至不必在 `else` 里。如果我想的话，我实际上可以这样做：我可以去掉我的 `else`，然后回到第3行，添加另一行缩进的代码（第4行），然后在这里 `break`。

现在，为什么这在逻辑上是可行的呢？考虑一下我现在尝试做什么。我尝试执行第3行，将用户的输入转换为 `int`，并且我尝试将结果从右到左存储在x中。如果出了问题，我们已经看到的代码会立即跳转到第5行和第6行来处理异常。但是，如果什么都没出错，我的代码按理说应该继续逐行执行。所以我技术上、逻辑上可以把 `break` 放在这里。看看我运行这个版本时会发生什么：`python number.py`，输入50，回车。它成功了，我现在跳出了循环。

哪种方式更好？老实说，我认为在这个阶段两种方式都可以。这个程序相对较短，即使我现在尝试做两件事，其中之一（`break`）不会失败——你要么跳出要么不跳出，没有来自用户的数据会影响它——我们严格来说并不需要把那两行代码（获取输入和 `break`）都放在 `try` 里。但这只有两行，所以我认为没关系。如果你回想我们过去不仅讨论代码的正确性（代码是否按预期工作），还讨论设计，我认为你可以从两方面论证。如果你更喜欢这种（`break`在`try`里）的可读性以及它没有 `else` 的事实，那很好。但是，如果你更喜欢最小化你尝试执行的代码行数以防万一出错，那么 `else` 也是一个合理的方法。

### 5. 通过函数封装与改进

#### `get_int` 函数

那么，允许我建议我们进一步完善这个。我认为我们现在已经到了它相当正确的地步。但是假设我现在发现自己今天、明天都需要频繁地从用户那里获取数字。正如我们所见，如果能发明一个我自己的函数 `get_int` 来从用户那里获取整数，无论是今天、明天还是以后都会很方便。而且，嘿，也许我甚至可以把那个函数分享给其他人，如果他们想编写获取用户整数的程序。那么我该如何着手做这件事呢？

好吧，我建议这样做：让我去掉 `print` 那行，但保留我循环的大部分内容。让我定义一个名为 `get_int` 的函数，它暂时不接受任何参数。我将把我之前写的所有代码都缩进到 `get_int` 下面。所以现在我有一个名为 `get_int` 的函数，它尝试做以下事情：尝试从用户那里获取一个整数；如果出了问题并且有 `ValueError`，就用 'x is not an integer' 向他们“喊话”；否则（`else`），就 `break` (注：此处应直接return)。但在这里，我想要的不仅仅是 `break`。现在我是在一个函数里，回想我们关于返回值的讨论。如果你在发明自己的函数，其目的不仅仅是在屏幕上打印东西（像副作用那样），而是要交回一个值，像我们讨论函数时提到的那样，在那个便利贴上把值递回给你，那么你需要显式地 `return x`。

我现在如何使用这个函数呢？一旦我们开始创建自己的函数，定义我们自己的 `main` 函数通常会很方便，这是我们程序的主要部分。我将保持简单：我现在要写 `x = get_int()`，然后在下一行，我将执行之前那个 `print`：`f'x is {x}'`。在我程序的最后，回想一下，我将调用 `main()`，这样无论如何，在所有东西都定义好之后，我都会调用我的 `main` 函数。

好吧，让我们看看这个怎么运作。运行 `python number.py`，回车。输入50，它似乎像以前一样工作。让我们再运行一次，这次输入 'cat'。'x is not an integer'，然后我被提示。输入 'dog'，我被提示。输入 'bird'，我被提示。好吧好吧好吧，50。这是一个整数，所以它被打印出来了。

这里值得注意什么？嗯，我体现了几个好的特性。其一，我有点“抽象”掉了获取整数这个概念。即使我刚才只是为了暂时隐藏那个函数而人为地敲了很多回车——它需要在那儿，但我们此时不必看到它——注意，现在整个程序实际上归结为仅仅这三行代码了。为什么？因为我已经将从用户那里获取整数的整个过程抽象到了我自己这个名为 `get_int` 的新函数中。

但我能改进它吗？让我撤销所有那些空行，把代码拉上来，这样我们可以在屏幕上看到更多内容。我能精简一下 `get_int` 的实现吗？我声称它是正确的，它处理了错误并且返回了x。但我并不严格需要写这么长的代码。我还能做什么？好吧，我建议，如果你在（之前的 `else` 块里）做的所有事情就是 `break`，然后紧接着（根据缩进）你在下一行执行 `return x`，那你为什么在浪费大家的时间呢？一旦你知道你准备好返回值了，你可以直接 `return x`。所以在我的 `else` 中，我可以跳出并返回一个值。(注：如前所述，直接 `return x` 即可，无需 `break`)。所以这里也是，`return` 用于从函数返回值，`break` 用于跳出循环。但事实证明，`return` 在某种程度上比 `break` 更“强”：它不仅会将你跳出循环，还会为你返回一个值。所以它可以说是一举两得。

但我能让它更紧凑吗？如果我的目标只是精简代码，即使它已经正确了？有没有人能想到进一步的改进，无论你以前是否用Python编程过？我能进一步缩短这个实现吗？哪怕只是为了减少因为行数更少而犯错的可能性，并且让它因为更短而更容易阅读？有任何精简 `get_int` 实现的建议吗？

**问：** （听众）你可以直接在 `try` 函数（语句）里返回值。当你尝试时，获取输入x，然后返回x。

**答：** 很好，我们可以直接在更高一点的地方 `return x`。让我纠正一下大家的说法，在我们进行中：它不是一个 `try` 函数，技术上讲它是一个 `try` 语句。函数通常有一个括号和另一个括号。在这种情况下，它只是一个语句。但我们确实可以这样做。我技术上不需要 `else`。如果我真的想，我可以在第9行之后这样做：我可以在这里 `return x`。或者，回想我们关于不必要地定义变量的讨论，有时比如，为什么在这里定义一个变量，如果你马上就要在这里使用它，然后就再也不用了？所以我们可以避免这里的新行，我甚至可以避免显式地定义x。我可以就这样说：我可以 `return int(input('What's x? '))`。我可以一次性完成所有事情。

现在，哪种更好？我不知道。我的意思是，这又是理性的人可能会有不同意见的地方。我认为，一方面，我们正在精简代码，使用更少的行数，更容易阅读，我犯错的概率更低。另一方面，它可能理解起来稍微复杂一点，我从哪里返回可能不那么明显。所以我认为两种方式都可以找到论据。归根结底，重要的是你有意识地做了这件事，你做出了决定要用这种方式或那种方式，并且你能在心里为它辩护——而不是你的答案是“它能工作，所以我没改它”。要有好的理由，想出好的理由，这会随着经验和实践而来。

#### 函数参数 (Function Arguments)

让我建议我们对此程序做一些最后的改进，这实际上只是进一步精简，以改进这个 `get_int` 函数的实现。我建议我们不要“硬编码”（hard code），也就是说，手动到处输入 'x'。让我们让这个 `get_int` 函数更具可重用性一些。现在注意，我只是有点依赖“君子协定”，就是说，`main` 定义了一个名为x的变量，而 `get_int` 正在请求一个名为x的变量。但如果调用者（`main`）不必知道被调用者（`get_int`）给它的变量起什么名字，反之亦然，那就更好了。（调用函数意味着使用它，调用者是使用它的函数，被调用者是正被调用的函数）。如果我不只是寄希望于x在两处都相同，那就更好了。

所以我建议这样做：我建议我们实际上给 `get_int` 添加一个参数，像这样：`get_int("What's x?")`。也就是说，如果 `main` 想要使用 `get_int` 函数，那么 `main` 可能应该告诉 `get_int` 函数要向用户显示什么提示。就像 `input()` 函数，回想一下Python自带的那个，取决于你传入一个提示符，用户在被人类请求输入时会看到那个提示。

那么我在这里如何让它工作呢？我可以到我 `get_int` 的定义那里，然后说，好吧，`get_int` 现在将接受一个名为 `prompt` 的参数。我可以给它起任何我想要的名字，但 `prompt` 在英语中非常自明，意思是“你希望用户看到的消息”。现在，在下面我实际使用 `input` 的地方，我不必自以为是地说 'What's x?'，因为万一程序（调用者）想请求y或z或其他变量呢？我可以仅仅将调用者提供的任何 `prompt` 传递给 `input`。

所以现在我正在编写更可重用的代码。它仍然以完全相同的方式工作，我并没有改变功能本身，但现在它更动态了一点，因为现在 `get_int` 不必知道或关心正在请求哪个变量、正在请求什么，它只需要知道应该向用户显示什么提示。

所以，如果我现在在下面再次运行这个程序 `python number.py`，回车，'What's x?'，输入50，仍然能工作。让我们再运行一次，输入 'cat'，它仍然能工作。如果我输入 'cat', 'dog', 'bird' 或其他任何东西，它会一直用那个相同的提示来提示我，从而使得这段代码更加可用。

### 6. 总结

事实证明，你甚至可以使用Python的 `raise` 关键字自己引发异常，但更多内容我们下次再说。所以在未来的日子、几周、几个月里，当你用Python编写更多代码时，你会发现错误是不可避免的。有时是语法错误，你必须修复它们，否则你甚至无法运行你的程序。但也可能是 `NameError`，例如你打算定义但不知何故没有定义的变量；`ValueError`，也许是用户不合作，提供了你没预料到的东西；或者一大堆其他可能的错误或异常。但现在，希望你知道了如何处理这些错误，并以你喜欢的任何方式来响应它们。

这就是我们对异常的探讨。我们下次再见。



---

## 要点回顾

**CS50P - Lecture 3: 异常 (Exceptions)**

**1. 异常简介**
- 异常（Exceptions）在Python及其他编程语言中指代码中出现的问题或错误。
- 程序中出现“异常”通常意味着发生了预期之外的坏事，需要处理。

**2. 常见错误类型**
- **语法错误 (SyntaxError)**
    - 定义：代码不符合Python的语法规则，类似于人类语言中的语法错误。
    - 示例：`print("hello, world` (缺少右引号)。
    - 特点：导致程序无法运行，必须由程序员在运行前修复。不能通过`try...except`来处理。
    - 错误信息示例：`SyntaxError: unterminated string literal` (未终止的字符串字面量)。
- **运行时错误 (Runtime Errors)**
    - 定义：在程序执行期间发生的错误，通常与数据值或操作有关。
    - 特点：可以通过编写防御性代码来检测和处理。
    - **值错误 (ValueError)**
        - 定义：当一个操作或函数接收到一个类型正确但值不合适的参数时引发。
        - 示例：尝试将非数字字符串（如 "cat"）传递给 `int()` 函数进行转换。
        - 代码示例：`x = int(input("What's x? "))`，用户输入 "cat"。
        - 错误信息示例：`ValueError: invalid literal for int() with base 10: 'cat'` (对于基数为10的int()而言，无效的字面量 'cat')。
        - 成因：用户输入了无法转换为预期类型（如整数）的数据。
    - **名称错误 (NameError)**
        - 定义：尝试使用一个未被定义的变量名时引发。
        - 示例：如果在 `try` 块中赋值失败（因为发生了异常），而在 `try` 块外部或 `else` 块外部尝试访问该变量。
        - 错误信息示例：`NameError: name 'x' is not defined` (名称 'x' 未定义)。
        - 成因：变量在使用前未成功赋值（可能因为之前的异常中断了赋值过程）。

**3. 异常处理机制**
- **`try` 和 `except`**
    - 目的：尝试执行可能会出错的代码块，并在发生特定错误时执行备用代码块。
    - 结构：
        ```python
        try:
            # 尝试执行的代码 (可能引发异常)
        except ErrorType:
            # 如果try块中发生 ErrorType 异常，则执行这里的代码
        ```
    - 示例：捕获 `ValueError`
        ```python
        try:
            x = int(input("What's x? "))
            print(f"x is {x}")
        except ValueError:
            print("x is not an integer")
        ```
    - 最佳实践：
        - `except` 后应指定具体的异常类型（如 `ValueError`），避免捕获所有异常（`except:`），因为这可能隐藏其他未预料的错误。
        - `try` 块应只包含*最少*的、*确实可能*引发所捕获异常的代码行。
- **`else` 子句**
    - 目的：在 `try` 块*没有*引发任何异常时执行代码。
    - 结构：
        ```python
        try:
            # 尝试执行的代码
        except ErrorType:
            # 处理异常
        else:
            # 如果 try 块成功执行（无异常），则执行这里的代码
        ```
    - 用途：常用于放置那些依赖于 `try` 块成功执行的代码，如上例中的 `print(f"x is {x}")`，以避免 `NameError`。
- **`pass` 语句**
    - 目的：在 `except` 块中捕获异常后，明确表示“什么也不做”，即静默处理该异常。
    - 示例：捕获 `ValueError` 但不打印错误信息，只是让循环继续。
        ```python
        except ValueError:
            pass # 忽略错误，继续循环提示用户输入
        ```

**4. 结合循环实现健壮的用户输入**
- 问题：一次性获取输入，如果出错程序就结束或只提示一次错误，不够友好。
- 方案：使用循环（如 `while True`）反复提示用户输入，直到成功为止。
- 结合 `try...except`：
    - 在 `while True` 循环内部使用 `try` 尝试获取和转换输入。
    - 如果成功（`try` 块无异常），使用 `break` 退出循环（或直接 `return` 值，如果是在函数中）。
    - 如果发生 `ValueError`，`except` 块处理（可以打印提示，或使用 `pass` 静默处理），循环继续，再次提示用户。

**5. 通过函数封装与改进**
- **抽象化**: 将获取有效整数的逻辑封装到一个自定义函数（如 `get_int()`）中。
    - 优点：代码更模块化、可重用、主逻辑更清晰。
- **函数结构**:
    - 函数内部包含 `while True` 循环和 `try...except` 逻辑。
    - 成功获取并转换输入后，使用 `return` 将整数值返回给调用者。
- **使用 `main` 函数**: 组织程序结构，定义 `main` 函数作为程序入口，调用 `get_int` 等辅助函数。
- **传递参数**:
    - 改进 `get_int` 函数，使其接受一个提示符字符串作为参数（如 `def get_int(prompt):`）。
    - 在调用 `input()` 时使用传入的 `prompt` 参数。
    - 优点：使 `get_int` 函数更通用，不依赖于固定的提示信息或变量名（如 "What's x?"）。

**6. 总结**
- 错误在编程中不可避免。
- **SyntaxError** 需要程序员手动修复。
- **Runtime Errors** (如 `ValueError`, `NameError`) 可以通过 `try...except...else` 结构进行预见和处理。
- 结合循环 (`while`) 和 `break` 或 `return` 可以创建更健壮的输入验证。
- 函数（`def`）用于封装逻辑，提高代码复用性和可读性。
- 参数化函数（传递参数）可以增强其通用性。
- Pythonic 的方式倾向于“尝试并处理异常”（EAFP - Easier to Ask for Forgiveness than Permission），而不是在操作前进行大量检查（LBYL - Look Before You Leap）。
- 可以使用 `raise` 关键字主动引发异常（本讲座提及，未深入）。

# 「哈佛CS50P-Python编程导论」第5讲 - 单元测试

- 视频链接：[CS50P - Lecture 5 - Unit Tests](https://www.youtube.com/watch?v=tIrcxwLqzjQ&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=8)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---
### 讲座介绍

本篇内容整理自CS50P（Python编程入门）第五讲关于单元测试的视频脚本。在软件开发过程中，确保代码的正确性和健壮性至关重要。传统的依靠手动运行程序、输入不同值来验证功能的方法，不仅效率低下、容易遗漏边界情况，而且随着项目复杂度的增加，会变得难以维护。

本次讲座针对这一痛点，系统介绍了单元测试的概念及其在Python编程中的实践。内容首先从简单的计算器平方函数 (`calculator.py`) 出发，演示了从基本的手动测试，到使用Python内置的 `assert` 关键字进行断言，逐步揭示了编写有效测试所面临的挑战，如代码冗余和错误信息不够明确等问题。

随后，讲座重点引入并详细讲解了流行的第三方测试框架 `pytest`。通过实例展示了如何利用 `pytest` 的约定和自动化特性，显著简化测试代码的编写，使其更加专注于测试逻辑本身。讨论内容涵盖了 `pytest` 的基本用法、如何组织测试用例以获取更清晰的反馈、如何测试函数是否按预期抛出异常，以及如何通过重构代码（以 `hello.py` 为例）来提高其可测试性，特别是处理带有打印等副作用的函数。最后，还介绍了如何将测试代码组织在专门的目录结构中。

### 内容纲要

```
CS50P 第五讲 - 单元测试
├── 引言：为何需要单元测试
│   ├── 传统手动测试的局限性（繁琐、易错、不全面）
│   ├── 自动化测试的必要性与优势
│   └── 单元测试定义：测试程序中的最小单元（通常是函数）
├── 早期测试方法与改进 (`calculator.py` 示例)
│   ├── 手动运行与测试
│   ├── 使用 `if __name__ == "__main__":` 保护入口
│   ├── 创建第一个测试脚本 (`test_calculator.py`)
│   │   ├── 导入被测函数 (`from calculator import square`)
│   │   ├── 编写测试函数 (`test_square`) 与命名约定
│   │   ├── 使用 `if/print` 检查条件与报告错误
│   │   └── 缺点：代码冗长、通过时无反馈、可能被“幸运”情况蒙蔽
│   └── 引入 `assert` 关键字
│       ├── `assert` 的作用：断言条件为真，否则抛出 `AssertionError`
│       ├── 使用 `assert` 简化测试 (`assert square(2) == 4`)
│       ├── `AssertionError` 的缺点：信息不够友好
│       ├── 结合 `try...except AssertionError` (仍显冗长)
│       └── 增加更多测试用例（负数、零）暴露问题
├── 引入 `pytest` 框架
│   ├── 问题：手动编写测试样板代码（`main`, `try/except`等）过于繁琐
│   ├── 解决方案：使用第三方测试框架 `pytest`
│   ├── `pytest` 简介：简化测试编写与执行的工具
│   ├── 安装：`pip install pytest`
│   └── 核心优势：约定优于配置，自动化发现与运行，减少样板代码
├── 使用 `pytest` 进行测试
│   ├── 基本结构：`test_*.py` 文件，`test_*` 函数，直接使用 `assert`
│   ├── 执行测试：`pytest test_calculator.py` 或 `pytest`
│   ├── 解读输出：`.` (通过), `F` (失败), `E` (错误), 详细的失败报告
│   ├── 演示：修复 `calculator.py` 中的 bug 并重新测试通过
│   └── 问答：
│       ├── 测试用户输入 vs. 测试函数逻辑
│       ├── `check50` 与 `pytest` 的关系
│       └── 在测试中使用循环 (可行但需保持简洁)
├── 优化测试结构
│   ├── 问题：单一测试函数中，一个 `assert` 失败导致后续中断
│   ├── 解决方案：将测试按类别/场景拆分到多个 `test_*` 函数
│   │   └── 示例：`test_positive`, `test_negative`, `test_zero`
│   └── 好处：独立运行所有测试，提供更全面的失败信息
├── 测试预期的异常
│   ├── 场景：需要验证函数在接收无效输入时是否按预期抛出异常
│   ├── `pytest` 方案：使用 `pytest.raises()` 上下文管理器
│   └── 语法与示例：`with pytest.raises(TypeError): square("cat")`
├── 测试带有副作用（Side Effects）的函数 (`hello.py` 示例)
│   ├── 问题：难以测试直接 `print` 输出（副作用）的函数
│   ├── 可测试性设计原则：优先返回值，分离逻辑与副作用
│   ├── 重构 `hello.py`：
│   │   ├── `hello` 函数改为 `return` 字符串
│   │   └── 调用处 `print(hello(...))`
│   └── 好处：重构后的函数易于通过 `assert` 进行单元测试
├── 组织测试代码
│   ├── 需求：当测试增多时，需要更好的组织结构
│   ├── 方法：将测试文件放入专用目录（如 `test/`）
│   ├── 关键：在测试目录中创建空的 `__init__.py` 文件，将其标记为包
│   └── 执行：`pytest test/` (运行目录下所有测试)
└── 总结
    ├── 单元测试的重要性：提高代码质量、可靠性
    ├── `pytest` 的价值：简化测试流程
    └── 对协作和代码维护的意义
```





# CS50P 第五讲 - 单元测试

## 引言：为何需要单元测试

大家好，这里是CS50的Python编程入门课。我是David Malan。这是我们关于单元测试的一周。

到目前为止，我们已经编写了大量的代码，你可能一直在通过运行程序、传入一些样本输入，然后再次运行并传入另一些样本输入来测试你的代码，或者你可能一直在等待我们来测试你的代码。但实际上，尽早养成用自己编写的代码来测试自己代码的习惯，是一种更好的实践。

事实上，无论你是做个人项目还是在工业界工作，如今非常普遍的做法是，不仅要编写代码来解决你想解决的问题，还要编写一些额外的代码来测试你所写的代码。这就是我们今天要关注的重点：编写我们自己的测试，以便更加自信、更加确定我们试图解决的问题确实得到了正确的解决。

## 早期测试方法与改进 (`calculator.py` 示例)

那么，让我们回溯几周前我们写过的一个程序，也就是用来计算数字的程序。具体来说，我们之前在`calculator.py`这个程序里，尝试计算一个数的平方，比如 $x^2$，其中 $x$ 可能是2、3或其他数字。

让我重新打开那个文件。在我的终端窗口里运行 `code calculator.py`。让我们从当时的地方继续，定义一个 `main` 函数。在我的 `main` 函数里，我做了类似这样的事情：我说 `x = int(input("What's x? "))` 来获取用户输入的整数x。然后我立即打印出类似 `"x squared is"` 的信息，并把调用 `square(x)` 函数的结果作为第二个参数传递给 `print`。

当然，我还没有实现 `square` 函数。所以我们来定义它。往下几行，定义 `square`。它接受一个参数，当时我称之为 `n`（代表number），所以我会再次这样做，尽管技术上我可以为这个变量选择任何名称。我记得是这样做的：`return n * n`。计算平方有很多方法，比如一个数乘以它自己。我们也可以用其他语法，但这是我们最终采用的方式。最后，我调用了 `main` 来启动运行这个程序的过程。

那么，作为一次手动测试，让我们运行 `python calculator.py` 并按回车。`What's x?` 我们输入 2。输出 `"x squared is 4"`。我觉得这是正确的。为了保险起见，我们再运行一次。`python calculator.py`，这次我们为 x 输入 3。输出 `"x squared is 9"`。我也认为这是正确的。这时我可能感觉很不错，然后就把代码提交给课程，或者发布到网上供他人使用。

但我并没有真正系统地测试这段代码。它不一定完全有效。事实上，我没有真正考虑一些边界情况（corner cases）。我用了一些很明显的数字，比如2和3，但是0呢？负数呢？还有其他无数的数字呢？我们不会测试无限多的输入，因为程序永远不会停止，但我们最终应该测试一些有代表性的输入。

但在我们这样做之前，让我们养成一个习惯，确保 `main` 不总是被调用。让我们再次采用这个习惯：`if __name__ == "__main__":`，只有在这种情况下才执行 `main`。我现在主动这样做，是因为我想确保当我可能从另一个文件（把它当作库）导入我的 `square` 函数时，`main` 不会自动被调用。

现在我已经像这样修改了程序，接下来我该做什么呢？让我们编写一个完全不同的程序，其唯一的目的就是测试这个程序。我已经有了实际的计算器 `calculator.py`。我已经准备好有条件地调用 `main`，这样我就可以安全地在另一个文件中导入这个文件里的一个或多个东西。那个另一个文件应该是什么呢？按照惯例，我将创建一个名为 `test_` 开头的文件，因为我要测试的是这个计算器本身，所以让我们把这个文件叫做 `test_calculator.py`。

这将给我一个新的标签页，在里面我可以编写一个全新的程序，其目的就是专门测试那个程序，但实际上是测试那个程序的特定功能。那个程序内置了 `square` 函数。让我们专注于测试那个函数。那么，我如何在这个程序中访问那个函数呢？回想一下，我可以从另一个文件导入函数，就像它是我自己的库（所谓的模块）一样。所以我要这样做：`from calculator import square`。我可以直接导入 `square` 本身。如果只 `import calculator`，那么每次使用 `square` 时都必须加上 `calculator.` 的前缀，只导入这一个函数会更简洁一些。

现在，让我来做这个。让我定义一个名为 `test_square` 的函数。这也是一个惯例。如果你想测试一个名为 `square` 的函数，你的测试函数应该叫做 `test_square`。或者，你也可以叫 `square_test`，我这里采用 `test_square` 这个惯例。

那么我们可以做什么样的测试呢？我不讨厌我之前运行的测试，测试 $x=2$ 和 $x=3$。但是以前每次我想测试我的程序时，我都必须手动操作。这会变得很乏味。别人要测试它也不容易。如果我真的在现实世界中工作，如果我能通过一些自动化过程反复运行我自己的代码来自动测试我的程序，那就太好了。所以让我们这样做，最终把人从这个过程中解放出来。

那么我该如何测试我现在根据第一行导入的 `square` 函数呢？在我的 `test_square` 函数中，我为什么不这样做呢？如果调用 `square(2)` 的结果不等于 4 (`!= 4`)，那我们就打印一条错误消息，因为我知道在现实世界中，$2^2$ 应该等于 4，所以如果 `square(2)` 不等于 4，我的程序里就有 bug，我的函数里就有 bug。我犯了个错误。所以让我打印出类似这样的信息，这样我或其他人就能知道 `"2 squared was not 4"`。我可以打印任何内容。

接下来我应该测试什么呢？让我们做不止一个测试。比如说，如果 `square(3)` 不等于 $3^2$ 也就是 9 (`!= 9`)，那么我们就打印出 `"3 squared was not 9"`。

所以我并没有比之前做更多的测试。但我已经把这两个测试，$x=2$ 和 $x=3$，嵌入到了我自己的代码中，这样我现在就可以自动运行这些测试了。

现在，仅仅定义一个名为 `test_square` 的函数是不够的。如果我想运行这个函数，我实际上需要以某种方式调用它。我们这样做的惯例和往常一样。在这个文件中，也让我定义一个 `main` 函数。而 `main` 的唯一目的就是调用 `test_square`。现在，在这个文件的底部，和以前一样，让我采用我的惯例：`if __name__ == "__main__":`，然后调用 `main`。

所以这里很多都只是样板代码。我们以前见过这个，定义一个 `main` 函数并调用一个函数来启动某个过程，现在在文件底部添加了条件判断，以确保我只是有条件地调用 `main`，以防我从这个文件导入任何东西到别处。

好了，让我们现在来测试我的代码。让我运行 `python test_calculator.py` 并按回车。什么也没有输出。什么也没有输出。但我认为没关系。我认为没有输出是好事，因为看看我的 `test_square` 函数。如果一切看起来都很好，我什么也不打印。

让我们通过回到我的 `calculator.py` 来证明这一点，让我破坏它。让我引入一个 bug。也许我第一次就没写对。也许我的代码最初是这样的。我没想清楚，我忘了我的平方运算。所以我认为一个数的平方是 `n + n`，而不是 `n * n`，这在算术上可能是一个合理的错误。

现在让我回到我的 `test_calculator.py`，我不会改变它，但我会重新运行它：`python test_calculator.py`。我在这里祈祷好运，但徒劳无功，我会立刻看到 `"3 squared was not 9"`。

现在这是怎么回事？当你的测试失败时，我们如何找出问题所在？有点有趣的是，我完全破坏了我的 `square` 函数，但只有一个测试失败了。看起来第9行和第10行的这个测试是没问题的，因为我没有看到那个输出。但是这两行，这个测试，是失败的，因为当我使用加法时，$3^2$ 不等于 9。

所以，为了清楚起见，为什么我的函数只是部分损坏了呢？为了清楚起见，为什么我只看到一个错误而不是两个，即使 `square` 函数现在在数学上是错误的？

（学员提问，这里假设有人回答了）
**答：** 是的，就这么简单。我只是幸运地发现 $2 + 2$ 和 $2 \times 2$ 结果相同。所以这是那些边界情况之一，这就是为什么养成不仅测试一件事，而且测试几件事并确保你覆盖了所有基础是个好习惯。所以我在这里很幸运。这就解释了为什么我只看到一个错误，尽管函数本身是有缺陷的。

## 引入 `assert` 关键字

但我建议有另一种方法可以做到这一点，因为老实说，如果我从这个简单的例子推断，不仅运行两个测试，而是运行3个、4个、10个或20个测试，你可以想象，天哪，代码会变得比函数本身复杂得多。看，在 `calculator.py` 中，我们讨论的函数只有两行长。然而在 `test_calculator.py` 中，我们讨论的代码有五行长。我为测试我的代码写的代码比我实际写的原始代码还要多。所以我认为，我们在测试代码时写的代码行数越少，你和我就越有可能去做这件事，因为它字面上会少一些工作量，也减少了出错的机会。

那么我可以在这里采取什么其他方法呢？事实证明，在 Python 中，还有一个我们尚未使用过的关键字，就是这个：`assert`。

`assert` 是 Python 和其他一些语言中的一个关键字，它允许你做到这一点，就像在英语中一样，去断言某件事是真的，去大胆地声称某件事是真的。如果它是真的，什么也不会发生。屏幕上不会出现错误。但是如果你在 Python 中断言某件事，而它不是真的，也就是说，你断言的东西，一个布尔表达式，是假的，你实际上会在屏幕上看到某种错误。

所以让我们尝试一下这个新关键字，如下所示。让我回到我的代码。为了让它更简单一点，我建议像这样使用这个新关键字。让我简单地 `assert square(2) == 4`。所以我改变了我的逻辑。我不再检查不等于，我现在非常响亮地断言它应该等于 4。然后在另一行，我做另一个测试：`assert square(3) == 9`。就是这样，没有缩进的 `print`。我只是更简单地断言这两件我希望是真的事情。

让我现在，在 `calculator.py` 仍然是坏的情况下（我仍然意外地使用加号而不是乘号），运行 `python test_calculator.py`。像往常一样祈祷好运，但这次不会顺利。屏幕上似乎出现了一大堆错误。如果我向上滚动查看这个 traceback（回溯信息），我们会看到失败的那一行是：`assert square(3) == 9`。

不幸的是，当你使用 `assert` 关键字时，它不是特别用户友好。它会显示涉及的文件和行号，但它确实显示了失败的具体代码行，也就是失败的断言。现在就得靠你我来推断了，等等，为什么 `square(3)` 不等于 9？所以它不是超级用户友好，但老实说，它让我写的代码量减少了一半。只有两行，而不是之前的四行。但是请注意下面这个小小的残留信息：这是一个 `AssertionError`。

我们以前见过错误。当我们在代码中犯了其他错误时，我们见过错误。过去，我们捕捉这些错误的解决方案是什么？我们如何捕捉那些看起来像这个，即使我们以前没见过这个特定错误的错误？

（学员提问，这里假设有人回答了）
**答：** 是的，在 Python 中，我们可以使用 `try` 和 `except` 关键字来尝试做某事（乐观地），除非（except）出了问题，否则就做别的事情。所以这是向前迈出的一步，因为我至少可以捕捉到这个错误。但这可能也是向后退了一步，因为我将不得不承认，最终会编写更多的代码。

所以让我试试这个。让我回到我的代码中。与其只是盲目地断言，不如像（Tola，假设是提问者名字）建议的那样，尝试 (`try`) 进行第一个断言，除非 (`except`) 出现了像我们刚才看到的 `AssertionError`，那么就打印出更用户友好的信息来解释实际失败的原因：`"2 squared was not 4"`。

同样地，我尝试 (`try`) 断言 `square(3) == 9`，除非 (`except`) 那里有 `AssertionError`，在这种情况下，我会更用户友好地打印出 `"3 squared was not 9"`。

所以我向前迈了一步，但也向后退了一步，因为现在我有更多的代码了。但我至少以一种与我们过去看到的方式一致的方式引入了断言和异常。当出现问题时，你实际上会看到一个异常被引发（raised）。

让我现在运行这个版本的程序。`python test_calculator.py`，祈祷好运，它仍然失败了，因为我看到了输出。但我们至少回到了用户友好的输出。所以这至少在某种程度上是进步。但是，再说一次，代码比理想情况要多。

事实上，如果我们继续这样做，如果我们真的想在这里添加额外的测试用例呢？看起来我们最终可能会编写远超理想数量的代码。例如，我现在测试了 2 和 3。我可能也应该测试一些负数。那么为什么不加入，例如——让我复制粘贴这个。让我尝试断言 `square(-2)` 等于 4 (`== 4`)，这在数学上应该是正确的。如果不是，让我把提示改成 `"negative 2 squared was not 4"`。

让我再复制粘贴一次，再测试一个负数，以确保安全。让我们测试 `square(-3)`，它应该等于 9。但如果不是，让我们说 `"negative 3 squared was not 9"`。

再思考一下，还有什么好的值可以测试呢？我试了 2。我试了 3。我试了 -2。我试了 -3。我不能尝试无限多的数字。但在这些值之间至少还有一些有点不同的东西。让我们试试 0。0 也是一个有趣的情况，以防万一可能有什么问题。为什么是 0？我只是凭直觉。很可能正数通常表现相同。负数可能通常表现相同。0 可能有点异常。这不一定有什么科学依据，而是根据你自己的经验，根据你试图测试的函数，考虑潜在的边界情况是什么。我正在测试数学相关的东西，所以我想测试有代表性的值。

所以，让我再粘贴一个 `try...except` 块。让我们断言 `square(0)` 应该等于 0。如果不是，我会说一些解释性的话，比如 `"0 squared was not 0"`。

现在如果我运行这个，`python test_calculator.py`，然后按回车，现在我看到了多个错误。这很有趣。这是一个线索，因为注意到这些断言中，有些失败了，但不是全部。关于 $2^2$ 的那个显然没问题，正如我们之前注意到的。回想一下，$2^2$ 恰好等于 $2+2$。所以那个 bug 并没有真正干扰我们的测试，但好在我们测试了 3。好在我们测试了 -2 和 -3，因为所有这些测试都捕捉到了这个错误。0 的测试没有注意到，因为 $0^2$ 当然是 0，但是 $0 + 0$ 也是 0。所以我们在这里是幸运还是不幸，取决于你如何看待这个杯子是半满还是半空。我们至少通过进行多个测试以某种方式捕捉到了这个错误。

不过，如果我们不用写这么多该死的代码就好了，因为注意我做了什么。我有 `try`, `except`, `try`, `except`。我有所有这些断言。我有一个 `main` 函数。我文件底部有这个 `if` 条件。老实说，如果每次我们都必须写这么多代码来测试一个只有两行的函数，谁还会想写这样的测试代码呢？没有人会这样写测试代码，如果我们都要写更多的代码来做实际的测试。

## 引入 `pytest` 框架

所以人们已经解决了这个问题。如果你习惯于大量测试你的代码，或者想要这样做，如果我习惯于想要大量测试我的代码，如果现实世界中的其他人都有这种想要测试他们代码的习惯，为什么我们不创建一些工具让这件事更容易做呢？

事实上，有一种机制可以做到这一点，我们可以使用一个通常被称为 `pytest` 的工具。`pytest` 是一个你可以下载和安装的第三方程序，它将自动化测试你的代码，只要你编写了测试。但这个库以及其他类似库的好处在于它采用了一些约定，这样你就不必自己手动编写那么多行代码了。它们为你自动完成了一些工作。

这是一个第三方库。还有其他用于单元测试（即测试你代码的单元）的库。其中一些是 Python 自带的。我们建议今天看看 `pytest`，因为它实际上比 Python 自带的单元测试框架要简单一些。

我们所说的单元测试是什么意思？单元测试只是描述测试程序中单个单元的一种正式方式。那些单个单元是什么？它们通常是函数。所以单元测试通常是你为自己编写的函数所做的测试。

## 使用 `pytest` 进行测试

这在实践中意味着什么呢？让我回到我的 VS Code，我建议我们显著简化我的 `test_calculator.py`。我将删除所有这些测试，它们累积起来有大约 31 行代码。让我们看看是否可以使用 `pytest` 将测试提炼到其本质。

从我的同一个 `calculator.py` 程序中，我仍然导入 `square`。所以我仍然需要那行代码，以便我可以测试那个特定的函数。现在我要定义一个函数，就像我之前做的那样。我将定义一个名为 `test_square` 的函数，同样是按照惯例，`test_` 加上你想要测试的函数名，尽管不一定非得这样。

现在我要做一些断言。我要 `assert square(2) == 4`。我要 `assert square(3) == 9`。我要 `assert square(-2) == 4`。我要 `assert square(-3) == 9`。最后，暂时，我要 `assert square(0) == 0`。

所以我仍然在使用我之前介绍的 `assert` 关键字。尽管输入这些有点繁琐，但现在只有八行代码了。而且它们输入起来很容易。没有 `try` 和 `except` 以及所有这些东西。如果别的东西，别人，处理了 `try`、`except`、打印、所有实际运行这些测试的标准化工作，那不是很好吗？

这正是 `pytest` 发挥作用的地方。根据 `pytest` 的文档（可以通过 `pip install pytest` 来安装，我们过去用它安装过其他库），你可以在这里查看其所有正式用法。但幸运的是，`pytest` 在测试框架中算是相当用户友好的，它实际上允许我们直接通过对我们编写的代码运行 `pytest` 来开始。

所以如果我回到 VS Code，看看我的 `test_calculator.py`，注意，它不再有 `main` 函数了——它没有条件判断。它没有 `try`。它没有 `except`。它没有 `print`。它只有我那几个断言——`pytest` 和其他类似的库将为我自动化运行这些测试的过程，并在屏幕上告诉我是否有任何测试失败了。

让我这样做。我将暂时增大我的终端窗口的大小，以便我们可以在屏幕上看到更多内容。我将运行的不是 `python`，像我一直在做的那样。我将运行 `pytest`，再说一次，这是用于运行你代码中测试的第三方工具。我将运行 `pytest test_calculator.py`，还是那个文件。我像往常一样祈祷好运并按回车，我们会看到有东西失败了。

现在，必须承认，尽管我确实认为你会发现 `pytest` 相对容易使用，但它的输出，至少乍一看，不一定非常用户友好。那么我们看到了什么？注意我窗口最顶部是我提示符后面运行的命令。紧接着下面是一个红色的单个 `F`，意思是失败（Fail），所以不太鼓舞人心。我在这里非常努力，但失败是我这个程序的分数。

但让我们看看究竟发生了什么。如果我看看这里 "failures" 下面的摘录，你会看到 `test_square` 是失败的函数。这很合理，因为这是我写的唯一一个。你会看到这里有些晦涩的输出描述了错误是什么。你在这里看到的第一行输出是 `assert square(2) == 4`，这没问题。下面没有红色的错误消息，所以那个是好的。但是这一行代码 `assert square(3) == 9`，`pytest` 不喜欢这个断言，因为它最终不是真的。事实上，根据这行开头的红色 `E`（表示Error/Exception info），你会看到我实际上是在尝试断言 `6 == 9`。

那么，6 是从哪里来的？等等，如果我的测试涉及这个，注意 `where 6 = square(3)`，这表示因为我调用了 `square`，传入了值 3，结果它的返回值是 6。当然，数学上，6 不等于 9。所以这就是为什么这个会失败。

现在，`pytest` 不像告诉你 bug 具体在哪里或如何修复它那样用户友好。这真的只是给你一个线索，告诉你一定是哪里出了问题。你在这里看到的是一个线索，第一个测试通过了，因为那行代码下面没有红色错误，但是这个测试失败了。不知何故，你的 `square` 函数在传入 3 时返回了 6 而不是 9。所以在这一点上，你得戴上你的侦探帽，回到你实际的代码，思考在 `calculator.py` 中，我的 `square` 函数的第 7 行怎么会返回 6 而不是 9。此时，很可能你头顶上的灯泡（比喻性地）会亮起来，你会看到，我用的是加法，而不是乘法。但是 `pytest` 为我们做的是自动化了至少指出那个错误的过程。

现在如果我进去修复这个——假设灯泡亮了。我把加号改成了乘号。现在我要，清屏后，运行的不是 Python，而是 `pytest test_calculator.py`，再次祈祷好运。现在它是绿色的了。我只看到了一个点 (`.`)，这表明我的唯一一个测试通过了。我做得很好，修复那个 bug 后，我的测试现在 100% 成功了。

让我在这里暂停一下，看看是否有任何问题。

---

### 问答环节 1

**问 (学员 3):** 我的问题是，如果用户，因为我们是从用户那里获取输入，如果用户有点恶意，输入了一个字符串而不是整数，或者他输入了一个浮点数或其他数据类型呢？

**答 (David Malan):** 是的，那么如果用户像我们过去例子中看到的那样，在我们期望整数时输入了 "cat" 而不是数字呢？我们如何测试这种情况？目前，我承认我没有测试用户输入。如果我回到我的代码，注意到我的 `calculator` 程序，当然，有我们一直在反复测试的 `square` 函数。但请注意，所有的用户输入目前都被委托给了我的 `main` 函数。而且我承认，到目前为止，我没有测试我的 `main` 函数。所以可能存在那样的 bug。事实上，确实会存在，因为如果用户输入了像 "cat" 这样的字符串，而不是像 2 或 3 这样的整数，那么回想一下第 2 行实际上会引发一个 `ValueError` 异常。我们以前见过这个。所以当涉及到测试你的代码时，这实际上是在你的程序中有多个函数的一个好理由。与其把所有的逻辑都放在文件本身，与其把所有的逻辑都放在 `main` 里，实际上把你的想法分解成更小的、本身可测试的小块函数是非常好、非常有帮助的实践。我在这里是什么意思呢？`square` 是完全可测试的。为什么？因为它接受一个名为 `n` 的参数作为输入，并返回一个整数作为输出，希望是它的平方。它有明确定义的输入和明确定义的输出。因此，在你的测试程序中传递这些值是完全在你的控制之下的。现在我要说，如果你想测试当传入像字符串 "cat" 这样的东西时 `square` 是否表现正常，我们绝对可以做类似这样的事情，（稍后会展示）使用不同的语法，你可以断言一个特定的异常会被引发。所以如果我们真的要回到我们的 `square` 函数，改进它，并故意引发一个异常，我们也可以测试那个。但就目前而言，我故意只测试 `square` 函数。我没有测试特定的用户输入。但那是另一个需要解决的问题。

---

### 问答环节 2

**问 (学员 4):** 你们使用单元测试来为 CS50 check 进行代码测试吗？

**答 (David Malan):** Check50 在精神上是相似的。Check50 是我们 CS50 编写的一个工具，它本质上在评估学生代码时做着类似 `pytest` 的事情。它在精神上是相似的，但你可以把 Check50 看作是 `pytest` 的一个替代品，如果你愿意的话。但它的工作方式有点不同。但想法是一样的，`pytest` 和更广泛的单元测试是一种独立于 CS50 的技术，是你可以在自己的代码上（无论是在本课程内外）可以而且应该做的事情。

---

### 问答环节 3

**问 (学员 5):** 我的问题是，与其写四次，比如 `assert square(2) == 4`，我们能不能写成类似 `assert square([2, 3, -2, -3]) == [4, 9, 4, 9]` 这样的形式，而不是写四行？

**答 (David Malan):** 一个非常好的问题，绝对可以。现在如果我回到 `test_calculator.py`，它确实很手动。我说和打出那几行花了我一些时间，你可以想象编写某种循环来只是在一个循环中断言这个等于那个，这个等于那个，等等，使用列表或者可能是一个列表或字典或某种类似的结构。所以是的，你绝对可以通过不只是重复做同样的事情来自动化一些测试。你仍然可以使用 Python 的所有语法来做循环。

## 优化测试结构

但总的来说，你的测试应该相当简单。事实上，让我建议我们进一步改进甚至这个设计，因为目前不太理想的是，当我的函数有 bug 时，我运行所有这些测试时得到的输出。让我重新引入那个相同的 bug，把我的乘法改回加法。让我再次增大我的终端窗口大小。然后让我再次运行 `pytest test_calculator.py`。这是我的代码现在再次包含 bug 的版本。所以我会看到那个巨大的失败信息，这个失败已经显示给我了。

但这并没有它本可以提供的帮助那么大，因为我的代码里还有所有那些其他的测试。回想一下，我有多少个？一、二、三、四、五个独立的测试，而我只看到了第一个的输出。

那么，这是为什么呢？如果我们回到我的代码，你会看到第一个失败的断言，也就是 `assert square(3) == 9` 这个，其他的测试甚至没有被运行。这并不是什么大问题，因为我的代码有 bug，所以它们中的一个或多个可能无论如何都会失败，但是如果能知道哪些会失败不是更好吗？事实上，理想的做法是尽可能一次性运行尽可能多的测试，以便给你尽可能多的线索来找到你的 bug。

所以让我建议我们改进我的测试代码的设计，仍然使用 `pytest`，如下所示。与其拥有一个名为 `test_square` 的大函数来用这么多不同的输入测试整个函数本身，不如让我们把我的测试分解成不同的类别。

在这里，同样没有唯一的正确方法。但我的想法是，我或许应该分开测试正数，分开测试负数，分开测试 0。我可以想到其他方法。我可以测试偶数。我可以测试奇数，或者可能完全是其他模式，但是把这个大测试分成多个测试可能会在出问题时为我提供更多的线索。

所以让我这样做。让我把这个函数重命名为 `test_positive`，并且只在这个函数中包含前两个测试（`assert square(2) == 4` 和 `assert square(3) == 9`）。然后我在这里创建另一个函数叫做 `test_negative`。在这个函数中，我只测试 -2 和 -3（`assert square(-2) == 4` 和 `assert square(-3) == 9`）。然后在这里，我再做一个 `def test_zero`，我只在里面运行一个测试（`assert square(0) == 0`）。

所以我仍然有相同的五个断言，但我现在把它们分到了三个独立的函数中。`pytest` 和其他单元测试框架的好处在于，所有这三个测试函数都会被自动运行。即使其中一个失败了，其他的也会被尝试运行。这意味着如果一个、两个或三个失败了，我现在就有一个、两个或三个线索来帮助我找到那个错误。

所以让我再次增大我的终端窗口大小，以便我们可以在屏幕上看到更多内容。我的计算器仍然有那个 bug，使用加法而不是乘法。让我运行的不是 Python，而是再次运行 `pytest test_calculator.py`，像往常一样祈祷好运，现在，哦天哪，屏幕上有更多的错误了。但这本身更有帮助。让我们从上到下地看一遍。

所以在 FAILURES 这里，全大写，我知道当你只是想解决一个问题时看到失败（failure）不太鼓舞人心，但这就是这些框架做的事情，在 FAILURES 下面，第一个失败的函数是 `test_positive`。但在这里，我们也看到了和之前一样的线索。第一个，2，`square(2) == 4`，那个没问题。它没有任何红色错误。但是下一个失败了。所以我知道当我传入 3 时 `square` 是坏的。

下面这里呢？看起来，不幸的是，我的 `test_negative` 函数也失败了。为什么？当我传入——哦，这很有趣——现在这里，-2 甚至都不行。所以我对正 2 很幸运。但是负 2 不行。所以这是一个线索。但总共只有两个测试失败了。所以注意最底部的这个总结，两个失败（failed）和一个通过（passed）。另一个是什么？第三个是什么？`test_zero`。所以 `test_zero` 通过了。这两个失败了。这有点在逻辑上，或者说数学上，引导我找到 bug 的根源。

同样需要明确的是，如果你有很多测试，这一行的输出是很有帮助的，即使它也有点令人沮丧：失败（F）、失败（F）和点（.）表示通过。所以这里有三个测试，只是用稍微不同的图形方式描绘出来了。

让我现在倒回去，回到 `calculator.py`。让我们修复那个 bug，因为假设我已经推断出我用的是加法。我一直应该用乘法。让我现在，在再次修复 bug 之后，回到我的大终端。让我运行 `pytest test_calculator.py`，按回车，现在祈祷好运，`...` (点点点) 表示一切安好。我的测试 100% 通过了，所有三个都通过了。

所以现在我做得很好。这不一定意味着我的代码 100% 正确。但这确实意味着它通过了我当前 100% 的测试。因此，我们可能应该更努力地思考一下，也许我们应该测试更大的数字。也许我们应该测试更小的数字。也许我们应该测试字符串或其他东西。最终的责任在于你来决定你要测试什么。但在现实世界中，如果你没有捕捉到你代码中的一个 bug，而这个 bug 是你本可以通过编写一个测试来尝试那种输入而捕捉到的，你会对自己非常不满意，或者别人——也许你的老板会对你非常不满意。

让我再次暂停，看看现在关于用 `pytest` 进行单元测试是否有任何问题。

---

### 问答环节 4

**问 (学员 6):** 所以如果你想测试，就像之前有人建议的那样，用户输入以及测试你的函数，你是在同一个文件里做吗？还是为不同类型的测试创建单独的文件？

**答 (David Malan):** 非常好的问题。你绝对可以创建单独的文件来测试不同类型的东西。或者如果你没有那么多，你可以把它们都放在同一个文件里。目前，为了方便，我一直把我所有的测试都放在一个文件里，而且它们的数量也不是特别多。但我们稍后会看一个例子，允许我把它们放到一个文件夹里，甚至可以对整个文件夹的测试运行 `pytest`。所以那是可能的。

---

### 问答环节 5

**问 (学员 7):** 我有两个问题。就在刚才，你用了一个叫做——我不确定是什么——哦是的，AssertionError 的异常。那个特定的错误究竟捕捉什么？我的第二个问题是，`assert` 关键字是否对编译器特别突出，确切地告诉它们插入这特定的代码行？

**答 (David Malan):** 确实如此。我们看到的 `assert` 关键字和我们之前看到的 `AssertionError` 是相互关联的。所以当你使用 `assert` 并且断言失败时，因为你使用的任何布尔表达式不是真的，是假的，根据 Python 的定义，一个 `AssertionError` 将会被引发。所以这两者协同工作。那些错误，那些断言错误，当我的这些代码行中的任何一行失败时，仍然会被我的代码引发。然而，`pytest`，这个第三方库，正在为我自动处理捕捉那些异常的过程，以便给我这个标准的输出。所以我们今天的故事开始于我自己真正地实现单元测试。我自己写了所有的代码。我写了 `main`。我做了条件判断。我做了 `try` 和 `except`。老实说，如果你和我每次都必须写那么多代码，长期来看编写测试会变得极其痛苦，尤其是当我们的函数这么小的时候。所以 `pytest` 和像它这样的单元测试框架只是自动化了其中的很多工作。本质上，`pytest` 为你添加了 `try`、`except`、`if`、`print`，这样你就可以只专注于测试的本质，也就是这些输入和输出。

---

### 问答环节 6

**问 (学员 8):** 所以当我们输入负 x 或负 5 的平方时，那个数的平方根（应为平方值）就出来了。但是当我们输入 6.6 或 5.6，类似这样的整数（应为浮点数）时，那一行就显示错误。那里发生了什么？

**答 (David Malan):** 所以我现在故意只测试整数，很大程度上是因为我只想让 `square`（原文是pow，应为square）操作整数。这可能在 Python 的文档或我自己对那个函数的文档中有所说明。如果你传入其他东西，比如浮点数，事实证明 Python 和其他语言中的浮点数值实际上很难，如果不是不可能的话，100% 精确地表示。所以如果你试图将它与某个其他值进行比较，结果可能会有轻微的舍入误差。我只是根据你描述的情况推断，但我现在非常刻意地只用我期望的输入来测试这个函数。如果传入其他输入，它确实可能会抛出其他错误。

## 测试预期的异常

允许我建议我们考虑一下，如果 `square` 实际上没有被传入一个数字，应该发生什么。例如，如果我回到 `calculator.py`，假设我，或者也许是其他使用我 `square` 函数的人，仅仅忘记了将 `input` 的返回值从 `str` 转换成 `int`，就像通过修改这里的第 2 行那样。现在，如果我输入的似乎是 `int` 但实际上是 `str`，肯定会出问题。

例如，如果我清空我的终端，运行 `python calculator.py` 并按回车——让我们输入 "cat" 作为 x 的值——当然，这现在会引发一个 `TypeError`。为什么？`"can't multiply sequence by non-int of type 'str'"`。这是什么意思？你不能做 "cat" 乘以 "cat"，因为确实，`square` 期望 `n` 是某个数字。但这并不一定意味着 `square` 本身有 bug。但这确实意味着，如果我期望一个 `TypeError` 被引发，让我们也测试一下这个，这样我就知道这种行为确实如预期般工作。

所以让我回到 `test_calculator.py`，让我在这里添加第四个测试。不如定义 `test_str`，因为我将特意并故意传入一个 `str` 来进行测试。我精神上想要断言像把 "cat" 传给 `square` 会引发一个 `TypeError`。但我们不用 `assert` 关键字来做这个。相反，我们需要这个。

让我到这个文件的顶部，让我额外导入 `pytest` 库本身，因为事实证明那个库里有一个叫做 `raises` 的函数，它允许我表达我期望一个异常被引发。我可以像这样表达：`with pytest.raises(TypeError):` 然后在冒号之后，我期望那个 `TypeError` 在什么时候被引发呢？每当我做类似调用 `square` 并传入的不是一个数字，而是像 "cat" 这样的东西时：`square("cat")`。

所以现在如果我回到我的终端窗口，运行 `pytest test_calculator.py`，这次有四个测试，我应该看到现在所有四个都成功了。

## 测试带有副作用（Side Effects）的函数 (`hello.py` 示例)

现在让我们考虑如何测试那些不仅期望数字作为输入，而且实际上期望字符串的代码。让我用 VS Code 把我们带回到我们早期编写的那个 `hello.py` 程序的几个不同版本中的第一个，它最终看起来有点像这样。

我有一个 `main` 函数，它通过问 `"What's your name?"` 来提示用户输入一个变量的值。然后我们做了类似 `hello(name)` 的事情，把用户的名字传入一个叫做 `hello` 的函数。

回想一下那个 `hello` 函数最终是这样的。我们定义 `hello` 接受一个名为 `to` 的参数，其默认值是 `"world"`，那个函数非常简单地打印 `"hello, "`，后面跟着一个逗号，然后是任何被传入的名字。然后我们最终调用了 `main`，但从现在开始，我将总是添加这个 `if` 条件：`if __name__ == "__main__":`，那么并且只有那时我才想调用 `main`。所以这基本上是这个程序上一个版本的样子。

我们该如何测试它呢？这里再次强调，我不会在 `main` 中测试用户的输入本身。我将真正专注于这里的代码模块，也就是 `hello` 函数本身。我该如何测试 `hello` 函数呢？

不幸的是，即使我开始做类似 `code test_hello.py` 的事情——让我开始编写一个测试程序——我可以从我的 `hello` 程序导入一个叫做 `hello` 的函数。所以看到 `from hello import hello` 有点奇怪，但请注意，在这一行，我正在从名为 `hello.py` 的模块（也就是文件）导入名为 `hello` 的函数。

我该如何测试这个呢？如果我有一个像 `def test_argument` 这样的函数——让我这样做。所以如果我定义一个像 `def test_hello` 这样的函数，我能做什么？我可以调用 `hello("David")`，然后检查它是否等于，比如说，`"hello, David"`。那么，这种方法行得通吗？如果我写了一个名为 `test_hello` 的测试，它用参数 "David" 调用 `hello`，然后测试它的返回值，就像我们为我们的计算器所做的那样，这样写行得通吗？

让我稍微回到我们正在测试的 `hello` 的版本，这样你可以看到那个 `hello` 函数。这是测试。这是实际的代码。这个测试现在能工作吗？

（学员提问，这里假设有人回答了）
**答：** 我认为问题在于，在 `hello.py` 的第一个版本中，你使用的是你首次声明函数时声明的 `to` 参数，而不是使用 `name`。
**David Malan:** 这实际上不是这里的 bug。所以让我规定，在 `hello.py` 中，这段代码实际上是按预期工作的。让我手动测试一下来证明。让我运行 `python hello.py`，输入我的名字 D-A-V-I-D，我确实看到了它说 `"hello, David"`。但是，如果我改变这个程序，去掉 `name` 参数，去掉 `name` 变量，只调用 `hello()`，再次运行 `python hello.py`，这次我甚至没有被提示，因为我删除了我的 `input` 调用，但它的行为确实如我所料。它确实说了 `"hello, world"`。所以让我规定，这个当前形式的代码实际上是正确的，但我的测试不会像我希望的那样工作。我的 `hello` 函数和我的 `square` 函数之间有一个微妙的区别可以解释。为什么这个测试可能不像预期的那样工作？

（学员提问，这里假设有人回答了）
**答：** 因为它没有返回值。
**David Malan:** 是的，完全正确。回想我们早期关于函数的讨论。函数要么可以返回一个值，就像我的 `square` 函数递给你某个值的平方，要么它们可以有副作用（side effects），比如屏幕上可能发生的视觉效果，比如在屏幕上打印出一些东西。根据定义，这就是 `print` 的工作方式。注意 `hello` 函数，它很短，但它最终是使用 `print` 函数实现的，在我这里的使用方式下，它不返回值。相反，它有在屏幕上打印东西的副作用。所以，在我的测试函数中检查 `hello` 的返回值是否等于 `"hello, David"` 是不正确的，因为再说一次，`hello` 没有返回任何东西。它在打印一些东西，那个副作用，但请注意，字面上，它没有 `return` 关键字，不像我的 `square` 函数那样有。

所以这是一个机会，也许可以改变我实现实际函数的方式。事实证明，随着你的程序变得越来越复杂，越来越难以理解，如果你能避免副作用，通常是最佳实践，特别是如果你希望你的代码是可测试的。

事实上，我建议我们改变我的 `hello` 程序，让它现在像这样工作。让我修改这个函数，不再打印 `hello` 和那个名字。让我字面上 `return` 一个 f-string，这会让代码更整洁一点：`return f"hello, {to}"`。所以我这里的语法只是熟悉的 f-string 或格式化字符串。它将返回 "hello, world" 或 "hello, David" 或 "hello, " 加上作为参数传入的任何人的名字，但我现在是返回它。我没有打印它。

那么上面这里需要改变什么呢？我可以做类似这样的事情。我可以说 `output = hello(name)` 然后在我的 `main` 函数中 `print(output)`。或者我可以简化它，因为我并不真的需要那个变量。我可以改为只做这个。我仍然可以调用 `hello`，但我可以立即打印出结果：`print(hello(name))`。

这个版本的 `hello` 程序现在实际上更具可测试性。为什么？因为我们使用的这些 `assert` 语句，以及我们目前为止看到的用于测试的语句，主要是设计用来测试传入函数的参数和它们的返回值的，而不是测试副作用。所以如果你在做 ` == ` 比较，你是在寻找一个返回值，一个从函数递回来的东西。

那很好。如果我现在修改我的程序设计，不再只是打印 `hello`，而是返回我想要构建的字符串、句子、短语，我可以把它留给调用者——也就是使用这个 `hello` 函数的函数——来处理实际的打印。

这在我的代码中意味着什么呢？这意味着现在如果我的 `hello.py` 看起来是这样，并且 `hello` 确实返回一个值，在我的 `test_hello` 函数中，我就可以完全像这样测试它。

所以让我运行 `pytest test_hello.py`，像往常一样祈祷好运，瞧，一个通过了 (1 passed)。所以我通过了这个测试，因为显然 `hello("David")` 的返回值确实等于 `"hello, David"`。

让我们测试另一种情况。如果我调用 `hello` 时没有任何参数呢？让我们断言 `assert hello()` 同样等于 `"hello, world"`，那个默认值。让我现在运行 `pytest test_hello.py`。那个也完全通过了。

但是同样地，假设我犯了一些错误。假设我的代码里有 bug。把多个测试组合在一个函数里可能不是最佳实践，所以让我们更清楚地说明哪些可能通过或失败。让我们把第一个函数叫做 `test_default`。然后让我们只包含这第一行代码 (`assert hello() == "hello, world"`)。然后让我们定义另一个函数，比如 `test_argument`，来测试这另一行代码 (`assert hello("David") == "hello, David"`)。

所以现在我有两个不同的测试，每个测试都在测试一些稍微根本不同的东西。所以现在当我运行我的代码时，它仍然没有坏。如果我运行 `pytest test_hello.py`，回车，我现在通过了两个测试 (2 passed)。这和以前一样好。但是如果我确实有 bug，有两个测试而不是一个，确实可能会给我更多关于问题所在的线索。

现在关于测试返回值（当这些返回值现在是字符串而不是整数时）以及我们为什么这样做，有什么问题吗？

---

### 问答环节 7

**问 (学员 11):** 我的问题是关于函数内部的函数。我们也能测试那个吗？或者我们还没见过的递归？

**答 (David Malan):** 如果你有一个递归函数，我们在这门课里没有讨论过，是的，你绝对也可以通过完全相同的方式简单地调用它们来测试它们。递归不影响这个过程。

---

### 问答环节 8

**问 (学员 12):** 当测试我们的参数时，我们能使用像循环这样的东西吗？或者在 `assert` 内部，或者针对那些值？

**答 (David Malan):** 绝对可以。你绝对可以使用循环来测试多个值。在这种情况下，例如，我可以做这样的事情。我可以说 `for name in ["Hermione", "Harry", "Ron"]:`。然后在这个循环内部我可以断言 `assert hello(name) == f"hello, {name}"`。然后通过再次运行 `pytest test_hello.py` 来一次性运行所有这些。它仍然只是那个函数内部的一个测试，但是如果那几个字符串有一些有趣的特性使得测试它们全部很有必要，你绝对可以用那种方式自动化测试。

话虽如此，你的每个测试理想情况下都应该相当简单和小巧。为什么？因为你不想写那么多代码，那么多复杂的代码，以至于你的测试本身可能有缺陷。我们不想做的是为我们的测试编写测试，再为我们测试的测试编写测试，因为那将永无止境。所以保持测试简洁明了确实是目标，这样理智的人，包括你自己，可以一眼看过去就断言，是的，那是正确的。我们不需要为我们的测试写测试。

## 组织测试代码

还有一个特性。假设我们不只有一个测试，而是有很多不同的测试，并且我们想开始将这些测试组织到多个文件甚至一个文件夹中。`pytest` 和其他框架也支持这种模式。

事实上，让我用一个测试文件夹来测试 `hello.py`，技术上只有一个测试文件，但这可以代表在那个文件夹里有更多测试的情况。我将在我的命令行使用 `mkdir test` 创建一个名为 `test` 的新文件夹。然后在那个文件夹内，我将创建一个名为 `test_hello.py` 的文件。

同时，在这个文件内部，我将测试同样的东西。所以我会 `from hello import hello`。我会定义一个像 `test_default` 这样的函数，它简单地测试 `hello()` 没有参数时返回 `"hello, world"` 的场景。我也会有那个测试传入参数的函数。在这种情况下，我会选择一个像 `assert hello("David") == "hello, David"` 这样的参数断言。

所以在这种情况下，我只是重新创建了和之前一样的测试，但它们现在在一个名为 `test` 的文件夹里的一个文件中。`pytest` 允许我也在这里运行它们。但要这样做，我实际上需要创建另一个文件。在我的 `test` 目录下，我需要创建一个名为 `__init__.py` 的文件，即使这个文件是空的，它的作用也是告诉 Python 把那个文件夹不仅仅当作一个模块，而是当作一个包（package）。包是一个或多个组织在文件夹内的 Python 模块。这个 `__init__.py` 文件只是给 Python 一个视觉指示，表明确实应该把那个文件夹当作一个包。如果我在这个文件夹里有更多代码，我可以用这个文件做更多的事情。但就目前而言，它只是一个线索，表明它确实打算成为一个包，而不仅仅是一个模块或单独的文件。

我现在可以做的最后一点是运行 `pytest`，甚至不是针对那个特定的文件，而是针对整个测试文件夹。所以如果我运行 `pytest test`，其中 `test` 是那个文件夹的名字，`pytest` 会自动搜索那个文件夹，寻找所有可能的测试，当然这个文件里只有那两个，但是当我现在按回车运行时，我仍然会通过那些测试。我仍然会得到 100%。

## 总结

最终，我现在有了一种机制来测试我自己的代码。所以，无论你是在编写返回整数或其他东西的函数，还是编写那些可以被重写为返回值的带有副作用的函数，你现在都有了一种机制，不再只是等待像我们这样的人来测试你的代码，也不再只是手动地一次又一次地测试你的代码——这可能会变得乏味，而且你可能会因为没有包含某些可能的输入而犯错——我们现在有了一种自动化的机制来测试自己的代码，当你开始与他人协作时，这种机制将更加强大，这样你就可以编写测试来确保，如果他们对相同的代码做了更改，他们没有破坏你写的代码。

这就是本周的内容。我们下次再见。


---
# 要点回顾

**CS50P 第五讲 - 单元测试：框架与要点**

1.  **引言：为何需要单元测试**
    -   除了编写实现功能的代码，编写测试代码来验证功能是现代编程（个人项目或工业界）的普遍且重要的实践。
    -   手动运行程序并输入样本值进行测试的方式繁琐、易出错且不可靠，特别是对于边缘情况（Corner Cases）。
    -   自动化测试（编写代码来测试代码）能更系统、更可靠地确保代码的正确性。
    -   单元测试（Unit Tests）专注于测试程序中的最小可测试单元，通常是函数。

2.  **早期测试方法与改进 (`calculator.py` 示例)**
    -   **手动测试:** 通过 `python calculator.py` 运行，输入 2 和 3，检查输出是否为 4 和 9。这种方法不够全面。
    -   **准备工作:** 使用 `if __name__ == "__main__":` 保护 `main()` 函数的调用，使得文件中的函数可以被其他测试脚本安全地导入而不会自动执行 `main`。
    -   **第一个测试脚本 (`test_calculator.py`)**:
        -   创建 `test_calculator.py` 文件。
        -   使用 `from calculator import square` 导入需要测试的函数。
        -   编写测试函数，按惯例命名为 `test_` + `被测函数名` (例如 `test_square`)。
        -   在测试函数内部，使用 `if square(2) != 4:` 这样的逻辑来检查结果，并在失败时 `print` 错误信息。
        -   需要定义一个 `main` 函数来调用这些测试函数，并通过 `if __name__ == "__main__":` 来执行。
        -   **缺点**: 测试代码冗长；当测试通过时没有明确输出；某个测试用例的“幸运”通过可能掩盖问题（如 `2 + 2` 恰好等于 `2 * 2`）。
    -   **引入 `assert` 关键字**:
        -   `assert` 用于断言一个条件必须为真，否则会抛出 `AssertionError`。
        -   使用 `assert square(2) == 4` 替代 `if/print` 结构，使测试代码更简洁。
        -   **缺点**: 默认的 `AssertionError` 信息不够用户友好；如果需要捕获并处理，仍需使用 `try...except AssertionError`，再次增加代码量。

3.  **引入 `pytest` 框架**
    -   `pytest` 是一个流行的第三方测试框架，旨在简化测试的编写和执行。
    -   可以通过 `pip install pytest` 安装。
    -   `pytest` 遵循约定优于配置的原则，能自动发现并运行测试。
    -   **核心优势**: 大幅减少编写测试所需的样板代码（无需手动编写 `main`、`if __name__`, `try/except`, `print` 等）。

4.  **使用 `pytest` 进行测试**
    -   **基本结构**:
        -   测试文件命名遵循 `test_*.py` 或 `*_test.py` 约定。
        -   测试函数命名遵循 `test_*` 约定。
        -   在测试函数内部，直接使用 `assert` 语句进行断言。
        -   无需 `main` 函数或 `if __name__ == "__main__":`。
    -   **执行测试**: 在命令行运行 `pytest <测试文件名>` 或直接运行 `pytest`（会自动查找当前目录及子目录下的测试文件）。
    -   **解读输出**:
        -   `.` (点) 表示测试通过。
        -   `F` 表示测试失败 (AssertionError)。
        -   `E` 表示测试中出现预料之外的错误。
        -   失败时，`pytest` 会提供详细的错误报告，包括失败的断言、实际值与期望值等，比原生 `AssertionError` 更友好。

5.  **优化测试结构**
    -   **问题**: 将所有测试用例放在一个测试函数中，一旦某个 `assert` 失败，后续的 `assert` 就不会执行。
    -   **解决方案**: 将不同类别或场景的测试分散到多个独立的测试函数中（例如 `test_positive`, `test_negative`, `test_zero`）。
    -   **好处**:
        -   所有测试函数都会被独立执行。
        -   可以一次性看到哪些类别的测试通过，哪些失败，提供更全面的反馈。
        -   有助于更快地定位问题所在。

6.  **测试预期的异常**
    -   有时，函数的正确行为是在接收到无效输入时抛出特定的异常（例如 `TypeError`, `ValueError`）。
    -   可以使用 `pytest.raises()` 上下文管理器来测试这种情况。
    -   **语法**: `import pytest` 后，使用 `with pytest.raises(ExpectedExceptionType): function_call_that_should_raise_exception()`。
    -   这可以确保函数在预期情况下确实抛出了正确的异常类型。

7.  **测试带有副作用（Side Effects）的函数 (`hello.py` 示例)**
    -   **问题**: 像 `print()` 这样直接在屏幕上输出（产生副作用）而不返回值的函数，很难用 `assert` 来测试其行为。例如，无法直接断言 `hello("David")` 的屏幕输出等于 `"hello, David"`。
    -   **可测试性设计原则**:
        -   尽量让函数返回结果，而不是直接执行副作用操作（如打印）。
        -   将核心逻辑（例如生成问候语字符串）与副作用（例如打印该字符串）分离。
    -   **重构示例**:
        -   修改 `hello` 函数，使其 `return f"hello, {to}"`。
        -   在调用 `hello` 的地方（如 `main` 函数）接收返回值并执行 `print` 操作：`message = hello(name); print(message)` 或直接 `print(hello(name))`。
    -   **好处**: 重构后的 `hello` 函数只负责返回字符串，变得容易用 `assert hello("David") == "hello, David"` 进行单元测试。

8.  **组织测试代码**
    -   可以将测试文件统一放在一个目录中（例如 `tests/` 或 `test/`）。
    -   在该测试目录下需要创建一个空的 `__init__.py` 文件，这会将该目录标记为一个 Python 包（package），`pytest` 能更好地发现其中的测试。
    -   可以在项目根目录运行 `pytest tests/` 或 `pytest test/` 来执行该目录下的所有测试。

9.  **总结**
    -   单元测试是确保代码质量、及早发现和修复 Bug 的重要手段。
    -   `pytest` 框架通过自动化和简化，使得编写和维护单元测试更加容易和高效。
    -   设计可测试的代码（例如分离逻辑与副作用）是编写有效单元测试的前提。
    -   编写单元测试有助于提高开发信心，尤其是在代码变更或团队协作时。
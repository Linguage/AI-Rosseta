
# 「哈佛CS50P-Python编程导论」第2讲-循环

- 视频链接：[CS50P - Lecture 2 - Loops](https://www.youtube.com/watch?v=-7xg8pGcP6w&list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V&index=4)
- 官方频道：[CS50](https://www.youtube.com/@cs50)
- 课程官网：[https://cs50.harvard.edu/python/2022/](https://cs50.harvard.edu/python/2022/) 提供有详细的学习资料，包括课程视频、讲稿、程序代码等。
- 注意：本文内容由视频脚本生成，仅供辅助参考，具体的学习应以官方内容为准。
---

### 内容介绍

欢迎阅读 CS50 Python 编程入门课程第二讲的讲座实录。本次讲座聚焦于编程中的一个核心概念——循环。循环允许我们高效地执行重复性任务，是编写简洁、强大代码的关键工具。讲座将从一个简单的打印任务（`cat.py`）出发，直观展示重复代码带来的问题，由此引出学习循环的必要性。

您将了解到 Python 中两种主要的循环结构：`while` 循环和 `for` 循环。讲座会详细解释它们的工作原理，包括如何设置循环条件、使用计数器控制循环次数，以及 `while True` 搭配 `break` 进行输入验证的常见模式。此外，还将探讨 `for` 循环与 Python 内置 `range()` 函数的结合使用，以及如何遍历列表（list）这一重要数据结构。

为了处理更复杂的数据关系，讲座会引入字典（dictionary）以及更高级的字典列表结构，并演示如何使用循环有效地处理这些结构中的数据，以霍格沃茨学生信息（`hogwarts.py`）为例。讲座还会介绍如何将循环逻辑封装到自定义函数中，以实现代码的抽象和重用。最后，通过模拟打印游戏《超级马里奥兄弟》中的图案（`mario.py`），您将学习嵌套循环的概念及其在处理二维问题时的应用。

### 内容纲要

```
CS50P 第2讲 - 循环 (Loops)
├── 1. 引言与循环的必要性
│   ├── 动机案例 (cat.py)：重复打印的问题
│   └── 引入循环概念：解决代码冗余与维护性问题
├── 2. `while` 循环
│   ├── 基本语法与布尔条件
│   ├── 使用计数器实现固定次数循环
│   │   ├── 递减计数 (i = 3, while i != 0, i = i - 1)
│   │   ├── 递增计数 (i = 1, while i <= 3, i = i + 1)
│   │   ├── 从0开始计数 (i = 0, while i < 3, i = i + 1) - 常用惯例
│   │   └── 计数器更新简写 (+=, -=)
│   ├── 无限循环风险与中断 (Ctrl+C)
│   └── 流程图演示
├── 3. `for` 循环与列表 (Lists)
│   ├── 列表 (List) 数据类型介绍 ([...])
│   ├── `for` 循环基本语法：遍历序列
│   │   ├── 遍历显式列表 (for i in [0, 1, 2])
│   │   └── 使用 `range()` 函数生成序列 (range(3)) - 改进设计
│   ├── 忽略循环变量 (for _ in range(...)) - Pythonic 惯例
│   └── Pythonic 技巧：字符串乘法实现重复打印 ("meow\n" * 3)
├── 4. 循环与用户输入验证
│   ├── 挑战：确保用户输入符合要求（如正整数）
│   └── 常用模式：`while True` 结合 `if` 和 `break` 实现持续提示与验证
├── 5. 结合函数进行抽象 (Abstraction with Functions)
│   ├── 将重复逻辑封装成函数 (get_number, meow)
│   ├── 使用 `def` 定义函数与参数
│   ├── 使用 `return` 从函数返回值
│   ├── `main` 函数组织代码结构
│   └── 抽象的好处：可重用性、可读性、可维护性
├── 6. 列表迭代与 `len()` 函数
│   ├── 案例：霍格沃茨学生列表 (hogwarts.py)
│   ├── 列表索引访问元素 (students[0])
│   ├── 直接遍历列表元素 (for student in students) - 首选方式
│   ├── `len()` 函数获取列表长度
│   └── 通过索引遍历列表 (for i in range(len(students))) - 获取索引和值
├── 7. 字典 (Dictionaries)
│   ├── 字典 (dict) 数据类型介绍 ({key: value}) - 键值对
│   ├── 案例 (hogwarts.py v1)：学生名作为键，学院作为值
│   ├── 通过键访问值 (students["Hermione"])
│   └── 遍历字典：默认遍历键 (for student in students)，访问对应值 (students[student])
├── 8. 字典列表 (Lists of Dictionaries)
│   ├── 场景：表示具有多个属性的复杂对象
│   ├── 结构：列表的每个元素是一个字典 ([{...}, {...}])
│   ├── 案例 (hogwarts.py v2)：每个学生字典包含 name, house, patronus
│   ├── 特殊值 `None`：表示值的缺失
│   └── 遍历字典列表：外层循环遍历列表，内层访问字典元素 (student["name"])
├── 9. 嵌套循环 (Nested Loops)
│   ├── 概念：一个循环内部包含另一个循环
│   ├── 应用：处理二维结构（如网格、图案）
│   ├── 案例：打印马里奥砖块 (mario.py)
│   │   ├── 打印单列 (print_column)
│   │   ├── 打印单行 (print_row)
│   │   └── 打印方块 (print_square) - 使用嵌套循环或结合抽象
│   ├── 内外循环逻辑：外循环控制行，内循环控制列
│   ├── `print()` 的 `end=""` 参数控制换行
│   └── 抽象与优化：使用函数 (print_row) 或字符串乘法简化内层循环
└── 10. 总结
    └── 回顾循环、条件、函数、变量、数据结构等构建块的作用
```



# **CS50P 第2讲 - 循环 (Loops)**

## **1. 引言与循环的必要性**

大家好。这里是 CS50 的 Python 编程入门课程。我是 David Malan，这周我们关注的是循环（loops），这是 Python 和许多其他编程语言中一种能够重复执行某项操作的能力，形成一种循环往复。

让我们先来探讨一下，为什么我们需要这种使用循环来周期性地执行任务的能力。

我将打开 VS Code。在我的终端窗口里，让我们创建一个名为 `cat.py` 的 Python 程序，让它像猫一样喵喵叫。

在这个代码标签页里，我打算非常简单地开始实现这只猫，也许只用 `print` 函数。我们要让这只猫不是发出声音，而是在屏幕上打印三次 "meow"。

我想最简单的方法就是打印一次 "meow"，再打印一次 "meow"，最后再打印一次 "meow"。

```python
print("meow")
print("meow")
print("meow")
```

现在，让我到终端窗口，运行 `python cat.py`，回车，然后屏幕上就显示了 "meow, meow, meow"。

好的，所以这个程序能工作。如果我的目标是让猫叫三次，这个程序确实实现了。

为了帮助我们理解计算机内部发生了什么，我建议我们看看这个流程图。和之前一样，流程图从这个椭圆形开始，表示从这里开始读。然后通过箭头指向一个 "meow"，再一个 "meow"，再一个 "meow"，然后停止。

这完全正确，而且老实说，它非常简单，但我敢说，我的代码仍然存在缺陷。为什么我的代码可以说设计得不好呢？

答案某种程度上会涉及到循环，但让我们看看能否确定代码在哪些方面确实设计得有些糟糕。

有什么想法吗？Alex？

**观众提问：** 嗯，我的意思是，重复同一个动作三次甚至更多次不是一个好习惯。

**DAVID MALAN：** 是的，我只是在重复自己。老实说，如果只是三次，问题可能不大。如果我们回头看我的代码，仅仅打印三次 "meow" 真的那么糟糕吗？

不完全是，但让我们考虑一下这种情况的逻辑延伸。假设我想让它叫四次、五次、五十次或五百次。你真的认为，即使你以前从未编程过，解决这个问题的办法真的是复制粘贴50次吗？

大概不是。我们可能可以做得更好。而且，除了代码变得难看，有这么多行相同的代码之外，想象一下如果你想修改代码。也许我改变主意了，不想做一只猫，想做一只狗。那么现在它必须多次说 "woof"。

现在我不得不在50个不同的地方进行修改。是的，我可以用查找和替换，但拜托，我们现在是程序员了，肯定有比仅仅重复自己更好的方法。

所以我打赌，如果我们更仔细地思考如何构建这个程序，我们可以做得更好。如果我们稍微扩展一下我们的词汇量，我们就能做到。事实证明，在 Python 和其他语言中，也有一个叫做 `while` 的关键字。

## **2. `while` 循环**

`while` 是我们表达所谓循环（loop）的一种方式，它是一段会一遍又一遍地执行的代码块——0次、1次、2次、50次，我们想要的任意次数。但 `while` 把如何表达重复执行的细节留给了我们。

所以，让我回到 VS Code，我建议这样做。`while` 是一个允许我反复询问问题的结构。每当我们看到问题时，它都以布尔表达式的形式出现，即答案为真或假的问题。

我该怎么做呢？我怎么能打印三次 "meow" 并三次询问一个答案为真或假的问题？

嗯，也许我可以数数？就像在手指上数数一样。如果我想从三开始倒数，我想叫三次，我可以竖起三根手指然后叫一声。然后我可以放下一根手指再叫一声。再放下一根手指再叫一声。再放下一根手指。也许我每次叫的时候可以问的问题是：我还有手指竖着吗？我还有手指竖着吗？我还有手指竖着吗？如果答案是肯定的，就继续。如果答案是否定的，就停止。

那么，我怎么把它转换成代码呢？一旦我们添加了这个 `while` 关键字——我想我们已经有了所有的构建块，我建议这样做。

我建议给自己一个变量。我叫它 `i`，代表整数（integer），但我可以叫它任何我想要的名字，我将把它初始化为3。然后我将使用 Python 的这个新特性 `while`，并且我将问一个问题，其答案必须是真或假。我会说，`while i != 0`。

所以我问的问题是，当 `i` 不等于 0 时，执行以下操作。注意行尾的冒号。注意我的缩进。就像函数和条件语句一样，你缩进那些你只想作为另一部分来执行的行。

当 $i \neq 0$ 时我想做什么？嗯，我想我只想叫一声 "meow"。

```python
i = 3
while i != 0:
    print("meow")
```

但仅仅写这些代码是不够的。如果我现在非常危险地运行 `python cat.py` 并敲回车，屏幕上可能会发生什么？无论你以前是否编过程。为什么这可能是一件非常糟糕的事情？它不会破坏东西，但可能会让我的电脑失去控制。有什么想法吗？是的，Timo？

**观众提问：** 嗨。我认为它会继续打印 "meow"，因为 `i` 总是等于 3，并且 `while` 条件总是为真。

**DAVID MALAN：** 是的，完全正确。如果我在第1行将 `i` 初始化为3——也就是将其设置为等于3，然后在第2行问问题，当 $i \neq 0$ 时，答案将是真的，它不等于0，它显然等于3，所以打印 "meow"。而 `while` 循环的工作方式是 Python 解释器不断地来回执行。它从第1行到第2行，然后到第3行，然后它回到第2行再次询问问题。如果答案仍然是真的，它就到第3行。然后它回到第2行。如果答案仍然是真的，它回到第3行。正如 Timo 所说，如果你从不改变 `i` 的值，它总是3，你就会陷入字面意义上的无限循环，这是一个意外的无限循环。

所以我们必须更聪明一点。我不会敲回车，因为我不想让我的电脑失去控制，永远打印 "meow"。幸运的是，如果你真的遇到了这种情况，发现自己陷入了意外的无限循环，`Ctrl+C`（用于取消或中断）将是你的好帮手。如果你似乎失去了控制，你不需要重启或关闭电脑。你只需在终端窗口按 `Ctrl+C`，这很可能会解决问题。

好的，那么每次叫完之后我该做什么呢？我想我应该在这里做类似这样的事情。让我更新 `i`，使其等于当前值减1。

```python
i = 3
while i != 0:
    print("meow")
    i = i - 1
```

所以，如果在每次迭代中，我将 `i` 更新为比原来少1，少1，少1，它最终应该会达到0，此时第2行问题的答案将变为假。

让我们看看这是否有效。我将到我的终端窗口运行 `python cat.py`，我确实得到了三次 "meow"。为什么？因为我已经用软件把它连接成了一台机器，可以这么说。我将 `i` 设置为3，然后我不断地问这个问题。但我不断地转动齿轮，我不断地改变变量的值，以确保它最终确实在递减——也就是每次减1，直到我们最终达到0。

现在，对于那些更倾向于图形化思考的人，让我展示一个我们常用的流程图。这只是对同一件事的图形化表示。注意发生了什么。我首先启动程序，然后我将 `i` 初始化为3，然后我问第一个问题。同样，菱形总是代表问题。答案将是真或假。$i \neq 0$ 吗？嗯，是的，它等于3。所以如果我沿着 True 的线走，我叫一声 "meow"。然后我沿着这个箭头走，我更新 `i` 等于 $i - 1$。在这个故事的这个点上，`i` 大概在数学上等于2。我沿着箭头走。这就是循环。这就是为什么图形化地看这个可能很好，因为你可以 буквально看到来回的循环。

现在我再问这个问题。$2 \neq 0$ 吗？嗯，它不等于0，它是2，所以我们再叫一声 "meow"。我们将 `i` 从2改为1。嗯，$1 \neq 0$ 吗？嗯，显然1不是0，所以我们再叫一声 "meow"。我们再次递减 `i`。`i` 现在是0。$0 \neq 0$ 吗？不，它等于0，所以答案是 False，我们停止。

所以，也许比我们之前看到的任何流程图都更能让你真正看到程序内部发生了什么结构。你不必养成制作这些图表或创建这些图表的习惯，但作为对计算机内部正在发生的事情的初步了解，这确实是一种可视化的方式。

让我提议，像往常一样，解决这个问题有很多不同的方法。假设你只是喜欢用不同的方式思考。也许你不喜欢从3开始倒数到0。为什么？也许你的大脑就是那样工作的，你更喜欢向上数而不是向下数。完全没问题。

让我修改我的代码，将 `i` 设置为1而不是3。然后在这里，让我改变我的逻辑。与其检查不等于0，比如你可能不喜欢用“不等于”来思考，因为它有点令人困惑，而且可能确实如此，让我们只检查 `i` 是否小于或等于3。

```python
i = 1
while i <= 3:
    print("meow")
    # 需要修改这里
```

所以我们会更明确一些。我们将从1数到3，每次打印 "meow"，但我需要修改第4行。让我们看看是否有人能帮我修改第4行。我该如何修改第4行，以使其与从1向上数到并包括3的逻辑保持一致？

**观众提问：** 我觉得每次喵喵叫之后，`i` 应该加 1。

**DAVID MALAN：** 是的，完全正确。在这种情况下，我们想要加1而不是减1。事实上，如果你仔细想想，这（指如果还是减1）可能会导致非常糟糕的结局。如果你从1开始计数，并不断减1，减1，减1，我想我们会发现自己遇到了同样的问题，那就是我们永远不会停止，因为我们会变得越来越负，而不是达到数字3。所以我认为你是对的，我需要把这改成 `i = i + 1`。

```python
i = 1
while i <= 3:
    print("meow")
    i = i + 1
```

现在注意，为了清晰起见，等号仍然是我们的赋值运算符，从右到左执行。逻辑上，这可能让你觉得奇怪。`i` 怎么能等于它自己加1呢？嗯，直到你从右到左执行这段代码之前它不会。你给 `i` 加1或减1，然后你更新左边 `i` 的值。赋值操作将右边的值复制到左边。

那么，我还能怎么做呢？我会说，大多数程序员，更广泛地说是计算机科学家，倾向于从0开始计数。这是一种惯例，实际上即使在 Python 和其他语言中也有其优点，一般来说，从0开始计数比像我们在现实世界中从1开始计数要好。

让我们现在就采用这个惯例。让我将 `i` 设置为0，我现在需要做一个改动。注意，如果我不改变我的逻辑，这个程序就出错了。这只猫有个 bug。如果我按原样运行它，它现在会叫四次。但这里最简单的修复方法是将我的不等式改为小于，而不是小于或等于。

```python
i = 0
while i < 3:
    print("meow")
    i = i + 1
```

现在我从0开始，但我只数到但不包括3。尽管在我们目前看到的所有方法中，这可能看起来最不熟悉，我们大多数人可能会从1、2、然后3开始，但现在养成这个习惯是好的：从0开始，一直数到但不包括你最终关心的值，在这里是3。

好吧，让我把事情精简一下。这不仅会修复我的计数问题，它现在按预期叫了3次，还有一种更简洁的方式来表达 `$i = i + 1$`，这是因为它在代码中非常常用。你可以直接说 `$i += 1$`，就这样。你不需要把所有东西都放在右边。这是一种特殊的语法，表达的是完全相同的意思，即增加 `i` 的值，但它使用的击键次数更少。它只是打字起来更舒服一点，读起来更快一点，这只是一种惯例。那些用 C、C++、Java、JavaScript 编程过的人可能见过 `++` 或 `--`。抱歉，Python 没有这个，所以你不能用。这已经是你能得到的最简洁的代码行了。

好的。让我在这里暂停一下，看看关于这些 `while` 循环的实现是否有任何问题。

**观众提问：** 我们可以使用像 for 循环那样的东西吗？它在开始时就初始化了一个特定的 i 值，然后根据你放入其中的特定条件运行，并在过程中递增它？

**DAVID MALAN：** 简短的回答是，不，你不能做你所描述的那种 for 循环，但我们很快会看到另一种类型的 for 循环。但我们稍后再谈那个。关于这里使用 `while` 的循环还有其他问题吗？

**观众提问：** 我对那个流程图有个问题。

**DAVID MALAN：** 好的。

**观众提问：** 图中有特定的符号代表特定类型的语句——它们是专门用于那种语句的吗？

**DAVID MALAN：** 是的。我特意使用了特定类型的符号，特定的形状，其中椭圆形是表示开始和结束的惯例。我用矩形表示任何代码语句，比如赋值或打印等等。我用菱形表示你可能问的问题，也就是我们见过的条件。如果你是为自己画图，只是为了理解你的代码并把它写下来，你当然不需要使用这些正式的符号，但我试图与一些最佳实践保持一致。

事实上，让我回到同一张图，因为这是我们图的第一个版本，但我们后来修改了几次代码。回想一下，这是我们问的问题是 `$i \neq 0$` 的版本，让我现在修改一下这段代码来表示我们做的下一个版本，回想一下，它改变了我们的逻辑，从1开始计数，它改变了我们的问题来检查 `$i \le 3$`，但除了计数（现在是加而不是减）之外，其他一切都相同。然后我们通过从0计数到但不包括3，进一步改进了它。我们通过使用稍微简洁的语法仅递增1来精简了这段代码。

到这一点，这些流程图对我们的用处可能会越来越小，因为一旦你理解了概念，并且希望图片能帮助将概念形象化，那么完全专注于代码，只有在你需要理解比你习惯的更复杂的东西时才去思考甚至画出类似的东西，这当然是可以的。

## **3. `for` 循环与列表 (Lists)**

如果可以的话，让我建议我们过渡到另一种实现循环的方法，使用另一个关键字，即 `for` 循环。这是一个在其他语言中也存在的词，但不一定具有其他语言可能赋予它的那么多特性。但是存在一种不同类型的循环——不是 `while` 循环，而是 `for` 循环。

`for` 循环将允许我们以稍微不同的方式表达自己，但为了做到这一点，我建议最简单的方法是介绍 Python 中的另一个概念，那就是列表（list）。在这里，也并非双关，我们正在往 Python 支持的数据类型列表里添加新成员。我们已经见过 `str`（字符串）、`int`（整数）、`float`（浮点数）、`bool`（布尔表达式）。Python 还有列表（lists），这是另一种数据类型，但奇妙的是，这个可能非常熟悉。现实世界中的事物列表在 Python 中也是一个列表。这是一种将多个值保存在同一个地方、同一个变量中的方法。

这是什么意思呢？好吧，让我建议我们回到 VS Code，让我重新开始我的代码，完全不使用 `while` 循环，而是使用这个新的关键字 `for`。

`for` 循环的工作方式是它允许你遍历一个项目列表。这看起来会是怎样呢？它可能看起来像这样——对于 `i` 在以下项目列表 `0, 1, 2` 中。这是我的起点，在这个循环的每次迭代中——也就是在这个循环一次又一次的每次执行中，我想打印出 "meow"。

```python
for i in [0, 1, 2]:
    print("meow")
```

我得承认，即使这里有一些新语法，我已经有点喜欢这段代码的样子了，因为它比 `while` 循环更短。`while` 循环刚才有多行，而且完全由我来决定 `i` 是什么。我必须检查一个条件，我必须增加或减少 `i`。相对来说，我做了很多工作来让那个东西转起来，让那个循环进行下去。从某种意义上说，它非常机械化。你可以在脑海中想象齿轮转动，所有这些变量都在变化，这些问题都在被问。

`for` 循环简化了所有这些，它只是说，如果你想要一个像 `i` 这样的变量，一个数字，并且你事先知道你希望这个循环执行多少次——三次，那么就明确地指定你希望 `i` 取哪些值。在这个循环中，`i` 会被 Python 自动初始化为0，然后打印 "meow"。然后 Python 会自动更新 `i` 等于1，然后打印 "meow"。然后 Python 会自动更新 `i` 为2，然后打印 "meow"。因为列表中的值就是这些，Python 会停止，总共只会叫三次。

列表是什么？这个程序中的列表就是那个 `0, 1, 2`，注意是方括号。那些不是圆括号，是代表列表的方括号。这就是你作为程序员在视觉上如何知道——以及 Python 作为语言如何知道你打算让它成为一个列表。

所以让我运行 `python cat.py`，它的效果是一样的。但它只有两行。一旦你熟悉了那个结构，它就相当可读了。但是，回到我一直强调的观点，正确性不一定等同于好的设计，这个程序在什么意义上可能设计得不好呢？

它似乎能工作。它叫了三次，但这为什么可能不是解决这个问题的最佳方式呢？即使你以前从未编过程，再次强调，考虑边界情况，可能发生或不发生的事情。考虑那些真正考验这段代码质量的极端情况。

**观众提问：** 好的。我认为是因为我们说了 0, 1, 2 三次。然后如果你想要一百万次，你就得说 1, 2, 3...

**DAVID MALAN：** 是的，完全正确。这就是我所说的思考极端情况的意思。如果你想自己判断你的代码是否好，或者别人的代码是否好，乍一看可能还行，但要考虑极端情况。如果不是三件事，而是一百万件事呢？我的意思是，你真的会写出从0到一百万或者从0到999,999吗？大概不会，你不会在屏幕上写那么多数字，肯定有更好的方法。

所以让我们从一开始就用更好的方法，而不是为糟糕的做法埋下伏笔。我们可以改进设计来解决这个问题的一个方法是，不要手动指定值的列表，而是使用一个函数，一个 Python 自带的、别人写的函数，来给你想要的列表。在 Python 中最简单的方法是使用一个叫做 `range` 的函数，它返回一个值的范围。

它期望至少接收一个参数作为输入，这个数字将是你想要返回的值的数量。这些值将从0开始，到1，到2，依此类推，但它们会达到但不包括你指定的数字。所以通过指定 `range(3)`，你基本上得到了1、2、3个值。默认情况下，这些值是0、1和2，就是这样。

```python
for i in range(3):
    print("meow")
```

但这之所以绝妙，是因为现在，正如 Hope 所说，如果我确实想叫一百万次——我的意思是，那可是一只愤怒的猫，我现在可以通过只输入一百万来实现。我不需要真的输入 0, 逗号, 1, 逗号, 2, 逗号, 3, 逗号, 4, 一直写到 999,999，我只需要这样做。所以从长远来看，这肯定是一种更好的方法。

这确实是我们可以做的一个改进，仍然使用 `for` 循环，但现在使用了这个 `range` 函数。

为了向你展示一些 Pythonic（符合 Python 风格）的东西——这不是绝对必要的，但通常会这样做，这里还有一个我们可以做的小改进，即使我们只是叫三次。请注意，尽管我定义了一个变量 `i`，但我从未使用它。逻辑上它有点必要，因为 Python 大概需要用某种东西来计数。它必须知道它在遍历什么。但是在 Python 中有这样一个惯例，如果你需要一个变量，仅仅是因为编程特性需要它来进行某种计数或自动更新，但你，作为人类，并不关心它的值，一个 Pythonic 的改进是把那个变量命名为单个下划线 `_`。

```python
for _ in range(3):
    print("meow")
```

这仅仅是因为它不是必需的，它不会改变程序的正确性，但它向以后的自己、向看你代码的同事或老师发出信号，表明是的，这是一个变量，但你不关心它的名字，因为你稍后不会用它，它只是为了使用这个特性（在这里是循环）所必需的。所以只是一个微小的改进或改变。

但为了真正让你对 Python 的可能性感到好奇，让我们更进一步。如果我们真的想变得 Pythonic，这个，如果你以前编过程，可以说会让你大吃一惊。如果我想让猫叫三次，我实际上可以这样做：

```python
print("meow" * 3)
```

你得是个技术宅才会觉得这很酷，但这确实有点酷。所以你可以直接打印你想要的东西，乘以你想要的次数，你就会得到完全相同的结果。

现在我好像犯了个错误。让我们看看这会做什么。它并不像这段代码对你——对你们中的一些人，对我——看起来那么漂亮。让我运行 `python cat.py`，回车。好吧，这像是一只非常饿的猫或者别的什么。它叫得非常快。

但我敢打赌我能修复它。让我们现在回顾一下我们讨论过的一些基本构建块。问题很明显是 "meowmeowmeow" 被重复了三次，但它不像我想要的那么漂亮。我希望它是分行的 "meow", "meow", "meow"。在仍然使用这个乘法运算符的情况下，可能的解决方案是什么？回想一下。我们用加号 `+` 来连接字符串。显然你可以用乘法 `*` 来连接字符串，但可以一次又一次地重复连接。我怎样才能在不回到我的 `for` 循环或 `while` 循环，并且仍然以这种方式使用乘法的情况下，清理一下这个输出呢？

**观众提问：** 我们可以使用转义序列，也就是反斜杠 n (`\n`)。

**DAVID MALAN：** 太棒了。是的。回想一下 `\n`，这是你作为程序员在代码中表示新行的方式。我想，如果我采纳你的建议，在我的引号内放一个 `\n`，这样在每个 M-E-O-W 的末尾都有一个新行。

```python
print("meow\n" * 3)
```

让我们看看效果如何。让我清屏并运行 `python cat.py`。好的，很接近了。我喜欢这个。让我再请教另一个人。我唯一不喜欢的地方——我知道我现在非常挑剔——是它确实是分行的 "meow", "meow", "meow"，但最后有一个额外的空行，这在美学上让我不太满意。

**观众提问：** 我认为我们可以让 `end` 等于空字符串，而不是默认的 `\n`。

**DAVID MALAN：** 是的。这里也一样，我们过去几周看到的所有这些东西都融合到了一起。回想一下，`print` 函数允许你控制行尾是什么。默认情况下，它本身就是 `\n`。这就是为什么在这次 `print` 的最后，光标又被移到了下一行。好吧，我们只需要覆盖掉那个默认行为。所以，让我进入我的代码，把它改成 `end=""`，这样它就不再是默认的 `\n`，而是什么都没有。那应该能消除掉那个额外的空行，希望如此。

```python
print("meow\n" * 3, end="")
```

所以让我最后一次运行这个，`python cat.py`，回车，好了。所以现在，至少就编程而言，我能把它浓缩成一行短代码并一次性表达出来，这挺酷的。

公平地说，它的可读性稍差。比如现在我有了 `\n`，有了 `* 3`，有了 `end=""`。所以你不必非得这样做。我之前的用 `for` 循环的方法，完全没问题。我之前的用 `while` 循环的方法，也完全没问题，在某种意义上，设计得非常完美。但这只是另一种方法，但如果你或你的老师、你的同事、你的朋友会难以阅读你自己的代码，那这就不是一件好事了。但这是 Python 的一个特性，某些语言实际上没有。

## **4. 循环与用户输入验证**

好吧，让我提议，如果我们不仅仅是只叫三次，而是叫一个可变次数，事情会变得更有趣。让我们问用户这只猫应该叫多少次。

让我清屏，然后弄清楚，我该如何从用户那里得到一个数字？这里的关键是，如果我想让用户给我一个数字，我不是在做数学运算，我是在让猫叫，因此，用户必须给我一个正值。用户必须给我一个正值。那我怎么坚持这一点呢？

嗯，如果我只是这样做：`n = int(input("What's n? "))`。

我想检查一下——我可以写 `if n < 0:` ——比如如果它是负数，嗯，我可以这样做。那就再问一次：`n = int(input("What's n? "))`。

好吧，如果用户还是不给我一个正数呢？如果他们非常固执，不注意，输入了两个负数呢？嗯，如果 `$n < 0$`，好吧，我们再做一次。`n = ...`

这没完没了。你不能无限次地检查，它是负数吗，它是负数吗，还是它是负数吗？程序永远写不完。所以我想我们可以用循环做得更好。

我建议这样做。在 Python 中，当你想要获得符合你特定期望（比如全是正数，或全是负数，或类似情况）的用户输入时，一个非常常见的范式是，你直接写 `while True:`。你故意地，有点危险但非常符合惯例地，引发一个无限循环。

什么是无限循环？就是一个永远进行下去的循环。我们已经看到这在数学上是如何意外发生的。当你写 `while True:` 时，它绝对会发生。为什么？因为 `True` 这个问题的答案总是 `True`。所以这是一种故意引发默认会永远进行下去的循环的方式。因此，当得到我们想要的数字时，我们需要一种方法来跳出这个循环。

然而，在这个原本是无限循环的内部，惯例是问你关心的问题，比如通过提示用户输入来给我一个整数：`n = int(input("What's n? "))`。然后只问你的问题。

所以如果 `$n < 0$`，我想我们希望 Python 继续提示用户。也就是说，我们希望代码留在循环内，重新调用 `input` 函数，并希望用户这次给我们一个更好的答案。如果这次它还是小于0，那么我们就直接用 Python 的关键字 `continue`，它的意思就是——继续留在这个循环里。否则（`else`），如果它不小于0，我们就用 Python 的另一个关键字 `break` 完全跳出循环。`break` 会让你跳出最近开始的循环，在这个例子里，如果 `n` 不小于0，就会跳出 `while` 循环。

```python
# 之前的尝试 - continue/else/break
while True:
    n = int(input("What's n? "))
    if n < 0:
        continue
    else:
        break
# 现在 n 是非负数
```

这能工作，它能让我们从用户那里得到一个大于等于0的值，但我认为我们可以进一步精简它，以免去写 `if` 和 `else` 的麻烦。为什么我们不直接说，如果 `$n > 0$`，就跳出循环呢？

```python
# 改进后的模式 - 直接 break
while True:
    n = int(input("What's n? "))
    if n > 0:
        break
# 现在 n 是正数
```

事实上，如果我们甚至允许用户输入0，这个程序也没那么有趣。所以让我们等到他们给我们一个大于0的整数，然后跳出这个循环。

我现在可以在下面做什么呢？

```python
while True:
    n = int(input("What's n? "))
    if n > 0:
        break

for _ in range(n):
    print("meow")
```

老实说，我这里不需要 `i`，所以让我回到之前的原则。让我把它改成下划线 `_`，只是为了更 Pythonic 一点，如果你愿意这么说的话。

所以发生了什么？第1到4行（指 `while` 循环部分）故意实现了一个无限循环，默认情况下它会永远进行下去。但在那个循环内部，在第2行从用户那里获得一个整数后，我接着检查，它是否大于0？或者是0？或者是负数？这些对于喵喵叫的猫来说都没意义。我希望猫至少叫一次。所以如果它大于0，就 `break`。这个 `break` 语句，即使它缩进了两次，效果是跳出最近开始的 `while` 循环。所以一旦用户给你一个正值，我们就到了第6行（指 `for` 循环），此时我们会因为第6和第7行的代码而叫那么多次。

所以如果我现在运行 `python cat.py`，回车，那么，n 是多少？让我们从我们开始的3开始，meow, meow, meow。这次，让我临时增大我的终端窗口大小。让我运行 `python cat.py`，让我做10次，现在屏幕上出现了10次 meow。

这里的要点不仅仅是我们可以叫10次或重复做某件事，而是这在 Python 中是一个非常常见的范式，当你想要重复做某件事，但只有在用户实际给出了你关心的值时才停止。

## **5. 结合函数进行抽象 (Abstraction with Functions)**

现在让我建议我们实践一下我们一直宣扬的，特别是关于编写自己的函数。既然我在做所有这些喵喵叫的事情，如果能有一个 Python 发明者没有预见到的 `meow` 函数，那可能会很好。所以让我这样做。

让我实际删除所有这些代码，然后这样做。让我像以前一样定义一个 `main` 函数，然后我只盲目地调用 `meow(3)`。`meow` 还不存在，但当它存在时，那就太好了。

```python
def main():
    meow(3)

# 需要定义 meow 函数

main()
```

所以现在让我去定义 `meow`。我的 `meow` 函数应该接受一个名为 `n`（或者任何我想要的名字）的参数作为输入，这部分现在很简单了。你怎么叫 `n` 次呢？嗯，`for _ in range(n):`，然后就打印 "meow"。和之前的代码一样，这里没什么新东西，我只是把那个逻辑放进了一个 `meow` 函数里，它会有打印 "meow" 这个副作用。

```python
def main():
    meow(3)

def meow(n):
    for _ in range(n):
        print("meow")

main()
```

现在，像以前一样，让我到下面确保我调用了 `main`。如果我现在运行这段代码，`python cat.py`，meow, meow, meow。它总是会做三次，因为我硬编码了3。

好吧，让我们在这里做一个改进。让我现在也许这样做。让我向用户询问一个数字。

```python
def main():
    number = get_number()
    meow(number)

# 需要定义 get_number 和 meow 函数

main()
```

所以，像这样说，`number = get_number()`。好的。不幸的是，Python 中没有一个叫做 `get_number` 的函数能从用户那里得到一个正数，但我可以发明一个。所以 `def get_number():`。然后在这个函数内部，让我这样做。`while True:`，从用户那里获取一个数字，将其转换为整数，问他们 "What's n?"。然后如果 `n` 是我想要的，它是一个大于0的值，一个正数，这次我不一定想要 `break`，虽然我可以。我反而想要 `return` 这个值，所以我实际上可以这样做：

```python
def get_number():
    while True:
        n = int(input("What's n? "))
        if n > 0:
            return n
```

这也是 Python 的一个特性。这种能力不仅能跳出代码块，还能在代码中返回值。实际返回一个值让你能够最终明确地返回一个值，这样你的函数就不仅仅必然有副作用，它实际上会像 `input`、`int`、`float` 函数那样，将一个实际的值交还给用户。

现在要清楚，我不是非得在这里 `return n`。我仍然可以像过去那样用这样的代码 `break` 跳出循环，但那样的话，在循环之后，我仍然必须 `return`。

```python
def get_number():
    while True:
        n = int(input("What's n? "))
        if n > 0:
            break
    return n
```

所以这里发生的是，如果你使用 `break` 来跳出循环，但你需要从函数返回一个值，你仍然必须现在明确地使用 `return` 关键字，要么像我之前那样在循环内部使用，要么像现在这样在循环外部但在函数内部使用。

我现在要做的最后一件事是改变我们之前硬编码的那个3，使其实际上是我们从用户那里得到的变量的值，这样现在在下面，如果我运行 `python cat.py`，回车，What's n? 我可以输入3，我得到我的三次 meow，或者如果我只想要一次，我现在得到一次 meow。

```python
def main():
    number = get_number()
    meow(number)

def get_number():
    while True:
        n = int(input("What's n? "))
        if n > 0:
            return n # 或者 break 后 return n

def meow(n):
    for _ in range(n):
        print("meow")

main()
```

好的。那么，如果我们现在有了这种在循环中一遍又一遍做事的能力，让我们看看我们是否能解决一些其他问题，通过这些问题来周期性地表达自己，但也得到一些有趣的答案。

## **6. 列表迭代与 `len()` 函数**

让我建议，例如，我们更仔细地看看这些列表。事实证明，在 Python 中，以及在一般的程序中，拥有一个值的列表是很有用的，因为我们将能够处理越来越多的数据，越来越大的数据集。

所以让我建议我们回到 VS Code，让我们做一些可能对某些人来说有点熟悉的事情，霍格沃茨的世界。让我编写一个名为 `hogwarts.py` 的文件，看看我们是否能在这里列出霍格沃茨的学生名单。

我有一个名为 `hogwarts.py` 的新标签页。我建议在这个程序中，我只定义一个我事先知道名字的学生列表。所以现在我不获取用户输入。我从一开始就知道我要考虑的三个学生是这些。我们的变量将被称为 `students`。它将等于，像我过去做的那样，一个方括号，意思是，嘿，这是一个列表。这些值将是引号里的 "Hermione"，因为是字符串；引号里的 "Harry"，因为是字符串；然后是引号里的 "Ron"，因为也是字符串。

```python
students = ["Hermione", "Harry", "Ron"]
```

这是一个长度为3的列表。它在精神上类似于我之前长度为3的列表，但那个列表包含3个整数：0, 1, 2。现在我有一个包含三个字符串的列表。

目前这还不是很有用，但让我做点什么作为对自己的检查。让我打印出这些学生中的每一个。等等，我该如何打印列表的内容呢？

嗯，过去，当我们打印一个变量时，我们只是打印出变量的名字。但我不想一次性打印出所有的 Hermione、Harry 和 Ron。也许我想先打印 Hermione，然后是 Harry，然后是 Ron。所以我需要一种方法来更精确地表达我想要从这个列表中获取哪个值。

在 Python 中，你这样做的方式是使用方括号的另一种方式。如果你有一个变量——在这种情况下，叫做 `students`，并且你想进入那个变量内部并获取一个特定的值——也就是说，你想索引（index into）到列表中，你使用这种方式的方括号，在方括号内使用数字。

这就是我们看到以0开始思考和计数而不是以1开始是有用的地方。Python 中的这些列表，我们可以说，是零索引（zero-indexed）的。列表中的第一项位于位置0，Python 列表中的第二项位于位置1，第三项位于位置2。所以你在心算时总是会差1，但如果你以前从未编过程，随着时间的推移你会习惯的。

所以让我打印出所有三个学生。让我打印 `students[0]`，然后是 `students[1]`。最后，让我打印 `students[2]`，这是我的第三行也是最后一行。

```python
students = ["Hermione", "Harry", "Ron"]

print(students[0])
print(students[1])
print(students[2])
```

当然，如果我运行这段代码，它可能会做你猜到的事情。如果我运行 `python hogwarts.py`，屏幕上分别是 Hermione, Harry, 和 Ron，每人一行。

但肯定有更好的方法，特别是我事先不知道谁会出现在这个列表中，如果明年霍格沃茨有新学生，我们可以使用循环来自动完成，而不必手动输入0，然后1，然后2。

这是 Python 的另一个特性。你可以使用 `for` 循环不仅仅是从0数到1到2，你可以用 Python 来迭代任何东西。不仅仅是数字，还有字符串。所以我实际上可以这样做。

```python
students = ["Hermione", "Harry", "Ron"]

for student in students:
    print(student)
```

`for student in students:`，冒号，然后在下面缩进，我可以写 `print(student)`。现在不管我有3个学生还是4个或400个，这两行代码，这个循环，都会为我逐一打印所有这些学生。

所以如果我现在运行 `python hogwarts.py`，是同样的列表，但我不需要事先知道那个实际列表有多长。

现在请注意，我在这里做了一个有意识的决定。我没有把这个变量叫做下划线 `_`，因为这次我正在使用这个变量。虽然我可以这样做，但现在，不不不不，你的代码变得太晦涩了。如果你把变量命名为下划线，并且你正在使用名为下划线的变量，那你现在谁也帮不了。你现在让读者感到困惑，也让以后的自己感到困惑，你应该把你的变量命名为它们所代表的东西。所以一个非常合适的名字，尽管我肯定你能想出其他的，会是 `student`，然后在这里，你可以说你也用 `student`。如果你更喜欢简洁，在这样的循环中做一些简洁的事情并非不合理。比如 `for s in students:`，可能使用列表本身开头的相同字母，但再说一次，何必呢？Python 的目标是更具可读性。如果你有一个学生列表，那就一次迭代一个 `student`。

让我在这里暂停一下，看看现在关于我现在定义的列表，也就是这个字符串列表，或者现在使用 `for` 循环来迭代和打印每个名字，是否有任何问题。

**观众提问：** 是的。所以在这种情况下，是不是不需要初始化 `student`？或者我们可以在循环中直接声明一个变量？

**DAVID MALAN：** 好问题。你不需要手动初始化它。Python 会负责将 `student` 变量先初始化为 "Hermione"，然后是 "Harry"，然后是 "Ron"。与其他一些语言不同，你不需要自己将其初始化为某个值，它就是存在并且会工作。关于这种方式的循环和列表还有其他问题吗？

**观众提问：** 既然你描述了 `break`，那么是否有 `continue` 的概念，以便我们可以在循环中跳过特定情况？

**DAVID MALAN：** 是的。你也可以使用另一种语法 `continue`。我们还没有展示那个。目前我们只关注了 `break`。

**观众提问：** 好的。那么这个 `for` 循环可以用于哈希表或其他类型的表或数组吗？

**DAVID MALAN：** 确实可以。我们有点超前了，但 Python 中还有其他类型的数据，而且确实，你可以使用 `for` 循环来迭代它们。任何可迭代的（iterable）数据，都可以用于像这样的循环。但关于那些——我们稍后再谈。

事实上，让我在这里过渡一下，展示解决同一个问题的另一种方法，因为到目前为止，当我们使用循环时，我们确实依赖于数字，如果你更喜欢留在那个领域，那也没关系。

假设我确实想使用像 `i` 和 0, 1, 2 等数字来迭代。我建议我们可以像下面这样修改代码。如果你更喜欢思考，或者你试图实现的程序要求你使用这样的数字，你可能会这样做。`for i in`——嗯，我不想只说 `students`，因为那样 `i` 就不会是数字了。`i` 将会字面上是 "Hermione"，然后是 "Harry"，然后是 "Ron"。

我需要从0迭代到1到2。如果一个包含三个元素的列表有这些位置：0, 1, 2，我需要以某种方式创建一个从0开始到2结束的循环。之前当我想这样做时，我需要 `range`，但这（直接用列表）行不通。我不能直接说 `in range(students)`，因为 `students` 不是一个数字，它不是一个整数，所以你不能把它传递给 `range`。`range` 期望一个整数。

但这里有一个解决方案。事实证明，Python 中有一个叫做 `len`（length的缩写）的函数，L-E-N，它会告诉你列表的长度，以及以后其他东西的长度。现在我想我可以把这些构建块组合起来，用一种方式让我能够使用数字。

所以 `range` 不接受字符串列表，它接受一个数字，理想情况下，那个数字将是3，这样我就能得到一个值的范围：0, 1, 和 2。所以我认为我可以像这样嵌套我的函数。

```python
students = ["Hermione", "Harry", "Ron"]

for i in range(len(students)):
    # ...
```

如果我首先获取 `students` 列表的长度，那将是3，然后我把那个返回值作为参数传递给 `range`，那将给我一个值的范围，0，然后1，然后2。

如果我愿意，这在代码中能让我做什么呢？不仅仅是这样。我现在可以打印 `students[i]`，这就是我们现在看到的语法变得非常富有表现力的地方——新的，也许不熟悉。但是如果我能做 `[0]`，或者 `[1]`，或者 `[2]`，事实证明，我实际上可以在那里放一个变量，我可以在那些括号内表达任何数字，以便在循环中动态地打印所有这些。

```python
students = ["Hermione", "Harry", "Ron"]

for i in range(len(students)):
    print(students[i])
```

让我运行 `python hogwarts.py`，回车，有 Hermione, Harry, 和 Ron。

现在如果我只是好奇，我只是想看看，或者也许我想做一个排名，比如学校里或者格兰芬多学院的前三名学生是谁？我们已经看到，我可以一次打印多个东西。让我不仅仅打印位置 `i` 的学生，而是，让我们先打印 `i`，然后是位置 `i` 的学生。所以要打印两样东西，我们知道 `print` 可以接受两个参数，我们之前见过，它们会用空格分隔。

```python
students = ["Hermione", "Harry", "Ron"]

for i in range(len(students)):
    print(i, students[i])
```

让我重新运行这个。现在我看到，好的，Hermione 是第一名，但她排在第零位。这有点奇怪。我们不需要向使用我程序的人展示我们是从0开始计数的。我可以清理一下。我只需在上面给 `i` 加1，现在我们就看到了一个前三名的学生名单。Hermione 是第一名，Harry 是第二名，当然，Ron 是第三名。

```python
students = ["Hermione", "Harry", "Ron"]

for i in range(len(students)):
    print(i + 1, students[i])
```

所以我们也可以访问所有这些相同的值。

现在关于这些列表有什么问题吗？关于这个长度 `len`，这些范围 `range`，或者其他的？

**观众提问：** 我的问题是，关于 `for i in range`，你能再解释一次吗？

**DAVID MALAN：** 当然。让我回到过去。我们开始是这样做的：`for i in [0, 1, 2]:` 然后我们用那种方式打印了三次 "meow"。那个 `for` 循环的工作方式是，它为你创建了一个我称之为 `i` 的变量，但我可以叫它任何我想要的名字。然后它最初将 `i` 赋值为列表中的第一个东西（0）。然后它自动将 `i` 赋值为列表中的下一个东西（1）。然后它将 `i` 赋值为列表中的第三个东西（2）。每次它都执行下面所有缩进的代码。

然而，我们意识到，如果我想做一百万次这样的事情，这种方式的可扩展性不好。所以我们引入了 `range` 来代替。`range(3)` 的效果是做同样的事情。它返回给我一个值的范围——实际上是一个包含三个东西的列表（或可迭代对象），所以行为完全相同。

如果我们现在快进到这个霍格沃茨的例子，我所做的只是将这些小想法结合起来。我仍然在创建一个 `for` 循环。我仍然在创建一个名为 `i` 的变量。我想在一个值的范围内进行迭代，但是多少个值呢？嗯，如果我使用 `len` 函数，并把值的列表传递给 `len` 函数，`len` 的作用就是告诉我这个列表有多长，答案是3。所以这几乎就像我之前直接写 `range(3)` 一样，但我不想硬编码3，我想动态地计算出霍格沃茨有多少学生。所以我只是在组合，组合，组合，或者说嵌套所有这些不同的想法：`range(len(students))`。

## **7. 字典 (Dictionaries)**

如果可以的话，让我现在在霍格沃茨的例子中过渡，介绍最后一种数据类型，然后我们将用几个最后的程序把所有东西结合起来。

事实证明，在 Python 中，不仅仅有字符串，不仅仅有整数，不仅仅有浮点值，不仅仅有布尔值，不仅仅有列表，还有所谓的字典（dictionaries 或 dicts）。字典是一种允许你将一个值与另一个值关联起来的数据结构。字面上就像人类世界中的字典一样。

如果你打开一本字典，无论是英语还是任何其他人类语言，字典里面有什么？嗯，是一堆单词和定义。然而，一个计算机科学家和一个程序员会更通用地将它们描述为键（keys）和值（values），某个东西与另一个东西相关联。

这就是字典的全部含义。它允许你将某个东西与另一个东西关联起来。注意，这已经比列表更强大、更有趣了。列表只是一组多个值。但字典可以说是二维的。就像一本人类的字典，一本书一样，它将某个东西与另一个东西关联起来，比如单词和它们的定义。

这在实践中到底意味着什么呢？假设我们想记录霍格沃茨里谁在哪个学院。嗯，我可以用列表来做。让我回到 VS Code，让我暂时——但用一种我最终不会喜欢的方式——创建另一个名为 `houses` 的变量，将其设置为等于 "Gryffindor"，对应赫敏的学院；"Gryffindor"，对应哈利的学院；"Gryffindor"，对应罗恩的学院。让我们把德拉科也加进去。所以我们现在有四个而不是三个学生，只是为了有点变化，他在斯莱特林。

```python
# 不推荐的方式：平行列表
students = ["Hermione", "Harry", "Ron", "Draco"]
houses = ["Gryffindor", "Gryffindor", "Gryffindor", "Slytherin"]
```

所以现在我们有两个列表。我们可以私下约定，`students` 变量中的第一个人住在 `houses` 中的第一个值所代表的学院。`students` 中的第二个人住在第二个学院。`students` 中的第三个人住在第三个学院。我们可以这样做。

但老实说，当我们有很多学生，很多学院时，这种方式很快就会崩溃。如果我们想记录比这更多的东西呢？如果我们想记录每个学生的学院和守护神（patronus），就是他们用魔法召唤出的那个形象呢？那么我们就需要第三个列表——如果我们只是靠君子协定，使用多个列表，让所有东西在逻辑上对齐，这很快就会变得混乱。当你的代码变得更复杂时，这通常不会有好结果。

但我确实想实现这个想法。我想把某个东西和某个东西关联起来。一个学生和一个学院，一个学生和一个学院，一个学生和一个学院，等等，那我该如何着手呢？

好吧，让我回到我的代码，我建议我们使用 Python 字典来做这件事。这是我们将看到的最后一个真正的新语法。

这是新的语法。我们将使用花括号 `{}` 来表示字典，而不是方括号。我们之前在 f-string 的上下文中见过花括号，那完全不相关。有时键盘上的键不够用了，语言的作者需要开始以不同的方式重用符号，这就是即将发生的事情。我们正在以不同的方式使用花括号。

现在，让我创建一个名为 `students` 的变量。让我把它设置成等于一个开花括号和一个闭花括号。这目前是一个空字典。

字典是这样工作的。它允许你将某个东西与另一个东西关联起来，你可以这样做：`"Hermione"`，引号括起来，冒号，然后是它的值。你想把什么和 Hermione 关联起来？嗯，"Gryffindor"。我想把 Harry 和什么关联起来？嗯，我想把他和 "Gryffindor" 关联起来。我想把 Ron 和什么关联起来？嗯，我想把他和 "Gryffindor" 关联起来。

```python
# 字典示例 - 键是学生名
students = {
    "Hermione": "Gryffindor",
    "Harry": "Gryffindor",
    "Ron": "Gryffindor"
    # ...
}
```

嗯，这实际上会很快变得非常难看。一旦我们加入 Draco 和 Slytherin，我的代码会变得太长，开始换行。所以这纯粹是为了美观。在 Python 和其他语言中，为了让代码更易读而稍微格式化一下，如果能让它更易读就添加新行，这是完全可以接受的。这样做的一种方式可能是这样的。

```python
students = {
    "Hermione": "Gryffindor",
    "Harry": "Gryffindor",
    "Ron": "Gryffindor",
    "Draco": "Slytherin"
}
```

我仍然有上面的开花括号，我仍然有下面的闭花括号，但请注意，它现在更易读了，因为我的键（keys）在左边，我的“某个东西”，我的值（values）在右边，我的“另一个东西”。从上到下浏览起来更容易一些。你也可以用不同的方式格式化它。但我现在要加入 Draco，他当然住在斯莱特林。

所以现在我左边有每个键，右边有值，这实际上，再次强调，只是这个想法的代码实现，就像你用纸笔画出的小图表，将某个东西与另一个东西关联起来。

那么我现在如何以一种有趣的方式使用这段代码呢？语法几乎是一样的。如果我想打印出第一个学生 Hermione 的学院，我可以这样做。打印出变量的名字，但我需要进入变量内部。我需要索引到它里面。字典的妙处在于，列表的位置是数字的——0, 1, 2；分别对应 Hermione, Harry, Ron，而字典允许你使用实际的单词作为你的索引，可以这么说，来进入它们内部。

所以如果你想打印出 Hermione 的学院，你关心的键是，引号括起来的 "Hermione"，这里的语法会做什么——注意，它不是数字0或1或2。它字面上就是 Hermione 的名字。这就像去看之前的图表然后说，好吧，给我 Hermione 作为我的键，Gryffindor 是值。这就是我们在这里用语法做的事情。我们在查找 Hermione 并获取它的值。

```python
print(students["Hermione"])
```

所以如果我回到我的代码，那应该会打印出 Gryffindor。如果我这样做几次：`students["Harry"]` 应该给我 Harry 的学院。`print(students["Ron"])` 应该给我 Ron 的学院。最后，如果我对 `students["Draco"]` 这样做，应该给我 Draco 的学院。

```python
print(students["Hermione"])
print(students["Harry"])
print(students["Ron"])
print(students["Draco"])
```

现在这仍然有点手动，我打赌我们可以改进它，但让我运行 `python hogwarts.py`，我们应该看到 Gryffindor, Gryffindor, Gryffindor, Slytherin，这正是我们期望的。

现在我们所做的，再次强调，只是从只有一个简单的名字列表，变成了两个维度，就像我们在纸笔上做的那样，将某个东西与另一个东西关联起来，分别是键和值。

如果可以的话，请允许我，尽管我意识到这有点花哨了，允许我稍微升级一下事情，从只看那个模式，只硬编码那些值，过渡到更动态地打印这些。

让我使用我们的循环，这个问题之前也提到了，让我这样做：`for student in students:`。

```python
students = { ... } # 前面的字典定义

for student in students:
    print(student)
```

这会打印出，例如，`students` 变量在——嗯，让我们先只打印 `student`。让我们保持简单。所以这还不会那么有趣，但是当我运行 `python hogwarts.py` 并敲回车时，注意，我应该看到什么？让我在这里提个问题，看看当我敲回车时，当我做 `for student in students:` 时，我会看到什么？

**观众提问：** 是的，我想我们只会看到键（keys）。

**DAVID MALAN：** 完美。很好的直觉。它本可以有两种可能。可能是值，也就是学院。但是当你在 Python 中使用 `for` 循环迭代一个字典时，按照设计，它会迭代所有的键。所以我想我们应该看到 Hermione, Harry, Ron, 和 Draco。让我现在敲回车，回车，确实，你完全正确，我们只看到了键。

但这并不是很有用，如果我真正关心的是谁住在哪里，我能同时打印两者吗？我想我可以。让我这样做。

```python
students = { ... }

for student in students:
    print(student, students[student])
```

让我不仅打印学生的名字（键），而且让我使用键（他们的名字）来索引到字典中。如果我知道字典里的单词，让我查找它的定义。如果我知道学生的名字，让我查找他们的学院，这样做的语法，就像列表一样，是 `students`，方括号。就像过去我们使用 `i` 当 `i` 是数字时一样，对于字典，我们也可以使用字符串。所以如果学生的名字是键，那么这个语法，`students[student]` 会去到 Hermione 的位置并取回她的学院。会去到 Harry 的位置并取回他的学院，依此类推。

所以如果我运行 `python hogwarts.py`，回车，现在我看到了 Hermione, Gryffindor; Harry, Gryffindor; Ron, Gryffindor; 和 Draco Slytherin。现在看起来我好像给了他们所有新的姓氏，但我可以清理一下。这只是一个打印的问题。让我们修改我们的分隔符，从默认的空格改成也许是逗号加空格。

```python
students = { ... }

for student in students:
    print(student, students[student], sep=", ")
```

仅仅使用 `print` 的特性，让我再次运行同一个程序，回车，现在我在那里有了一些漂亮的逗号，以明确 Hermione 的姓氏实际上不是 Gryffindor，但这只是一个打印的细节。

那么，关于这些字典以及我刚才所做的，有什么问题吗？关于这些字典和这种循环遍历它们的问题？

## **8. 字典列表 (Lists of Dictionaries)**

**观众提问：** 我只是无法理解 `for student in students`。如果我——如果我没理解错的话请纠正我。这是否意味着它导入了学生列表，并使用索引——换句话说，Hermione, Harry, 和 Ron 作为实际学生列表中的索引？

**DAVID MALAN：** 正确。所以这只是 Python 的一个特性。当你对字典使用 `for` 循环时，会发生这样的事情。如果这是这里的字典，键在上面，值在下面，你可以选择变量叫什么名字。我把我的变量叫做 `student` 只是因为它有意义，因为我想要一次一个学生。而 `for` 循环所做的，就像它之前对数字 0, 1, 和 2 做的那样，它允许我，例如，最初将 `student` 设置为等于 Hermione 的名字。然后循环的下一次迭代，下一个周期，将 `student` 设置为等于 Harry 的名字，然后是 Ron，然后是 Draco。它只是自动发生的。就像那是 Python 解释器在看到像那样的 `for` 循环时为你做的事情。所以它在精神上与用 `for` 循环迭代列表非常相似，但它不是迭代数字位置 0, 1, 2，而是迭代这个图形表示中加粗的键。

请允许我再给出一个霍格沃茨的例子，然后我们再看一个熟悉的领域。

冒着事情有点升级的风险，让我建议我们用最后一个像这样的霍格沃茨例子来继续这个故事。如果我们有关于每个学生的更多信息呢？这是不可避免的。如果你正在实现一个包含人物、客户、员工或任何其他东西的数据库程序，你可以想象你程序中代表的任何东西都有大量数据。

为了讨论方便，假设霍格沃茨的每个学生，当然，都有一个名字，他们已经有一个学院，但他们还有一个守护神。对于不熟悉的人来说，这是当他们施展某个魔法咒语时从他们魔杖末端出来的动物或实体。这里的重点是，我们想关联的不仅仅是一件事与学生，而是多件事——他们的名字、他们的学院，以及在这种情况下他们的守护神。

那么，这样的代码会是什么样子呢？好吧，让我回到 `hogwarts.py`，让我暂时重新开始。让我建议我用更多一点的数据来增强它。这个数据看起来会是这样的。

我的 `students` 变量现在，我建议我们把它看作一个列表。如果我们有一个字典列表，像下面这样呢？确实，我想字面上实现这里的这张图。注意我之前的图只代表了一个单一的字典。但假设我想组合一个字典列表。也就是，对于学生们——一个包含四个学生的列表。假设每个学生本身都是一个字典，一个键值对的集合，键和值，某个东西和另一个东西。

好吧，这是我们在代码中可以做的另一种方式。让我回到 VS Code，让我定义一个名为 `students` 的变量，它等于一个列表。我将预先将我的光标移到不同的行上，因为我知道这会很长，我想把这个列表的所有元素都放在里面。

我现在要创建一个字典，每个学生一个字典。我如何创建一个字典？我只需使用那些花括号。但由我来定义那些键是什么。我建议这次一个键不会明确是学生的名字，它会字面上是单词 `name`，在那里，将有名字 "Hermione"。同一个学生将有另一个叫做 `house` 的键，值将是 "Gryffindor"。同一个学生将有第三个叫做 `patronus` 的键，它的值将是——我得查一下——根据书上说，是一只水獭（Otter）。

```python
students = [
    {"name": "Hermione", "house": "Gryffindor", "patronus": "Otter"},
    # ... 其他学生
]
```

现在我将在这个列表内创建第二个字典。再次强调，字典就像字面意义上的人类词典。它是一本包含键和值的书，单词和定义。在我每个字典中存储的三个词是什么？`name`, `house`, 和 `patronus`。对于 Hermione，这些词的定义是什么？分别是 "Hermione", "Gryffindor", 和 "Otter"。

对于 Harry，在这个新字典中，定义将是不同的。让我给自己另一对花括号，然后这样说：`name`, 引号, 冒号, "Harry"。这里的 `house` 仍然是 "Gryffindor"。这个我知道，他的 `patronus` 将是，在这种情况下，一只雄鹿（Stag）。

```python
students = [
    {"name": "Hermione", "house": "Gryffindor", "patronus": "Otter"},
    {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
    # ... 其他学生
]
```

接下来，第三个字典。这里的 `name` 将是 "Ron"。我就直接这样做了。接下来，我有 `house`，他也在格兰芬多。最后，这个我得查一下，Ron 的守护神是一只杰克罗素梗（Jack Russell terrier）。

```python
students = [
    {"name": "Hermione", "house": "Gryffindor", "patronus": "Otter"},
    {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
    {"name": "Ron", "house": "Gryffindor", "patronus": "Jack Russell terrier"},
    # ... 其他学生
]
```

最后是 Draco。现在在第四个字典里——所以是另一对花括号，学生的名字当然是 "Draco"。这个学生的学院是 "Slytherin"。而 Draco，有趣的是，至少根据互联网上的说法，没有守护神。在书或电影中从未揭示过。所以事实证明，这实际上是一个绝佳的教学时刻。

Python 中有一个特殊的关键字，字面上就是 `None`，N-O-N-E，首字母大写。这正式表示值的缺失。所以我可以有点草率地做类似引号 `""` 的事情，但这是否意味着我没来得及输入它还是什么？在语义上更清楚地说字面上的 `None`，这是 Python 中的一个特殊关键字，以明确我知道 Draco 没有守护神，这不仅仅是我的疏忽。

```python
students = [
    {"name": "Hermione", "house": "Gryffindor", "patronus": "Otter"},
    {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
    {"name": "Ron", "house": "Gryffindor", "patronus": "Jack Russell terrier"},
    {"name": "Draco", "house": "Slytherin", "patronus": None}
]
```

现在我有了这个，我在计算机内存中拥有了什么？我有一个列表。我怎么知道它是一个列表？因为我看到开头有一个方括号，结尾有另一个方括号。这只是我的视觉线索，好的，我不一定知道这里发生了什么，但这有某个东西的列表。

那个列表里有什么？嗯，这里，语法也是我们的线索。因为第2行以花括号开始并以花括号结束，我只知道，那是一个字典，一个键值对的集合。现在这一切都完美地显示在我的屏幕上，所以我没有费心把所有的键值对移到新行上，那样会使它变得非常高，所以我这次把它们都放在一起了。

但是第一个字典有多少个键？换句话说，在 Hermione 的实体字典里，有多少个单词？三个。单词是 `name`, `house`, 和 `patronus`。在 Hermione 的字典里，这些单词的三个定义或值是什么？分别是 "Hermione", "Gryffindor", 和 "Otter"。

同样的故事也适用于 Harry，然后是 Ron，然后是 Draco。我通过设计，选择给他们所有具有相同键（`name`, `house`, `patronus`）的字典，但它们都有唯一的值。这是我的设计，这是我作为程序员的特权。

那么，这最终为什么有用呢？我现在可以访问关于所有这些学生的整个有趣数据的集合，并且我仍然可以做一个循环。我可以写 `for student in students:`，这将允许我迭代这个学生列表。让我一次只打印一样东西。让我打印当前学生的 `name`。

```python
for student in students:
    print(student["name"])
```

所以尽管字典很复杂，但这应该相当舒服。`for student in students:` 只是迭代列表中的每个学生。总共1, 2, 3, 4个。下一行只是打印出 `name` 键的值。这就像打开一本实体字典，查找单词 `name`，然后分别从每个字典中给我们 Hermione, Harry, Ron, 和 Draco。

所以如果我运行这个版本的霍格沃茨并敲回车，好了，我得到了他们所有三个（实际上是四个）的名字。

但如果我想要比这更多的信息呢？我想要他们的名字和他们的学院。好吧，只需在 `print` 的参数中添加 `student["house"]`。

```python
for student in students:
    print(student["name"], student["house"])
```

好的，让我们运行这个。`python hogwarts.py` 并敲回车。我现在看到 Hermione, Gryffindor; Harry, Gryffindor; 等等。好吧，我们可以通过用 `print` 添加一个分隔符，比如逗号和空格，来在美学上稍微清理一下，这样当我再次运行它时，我现在看到一些逗号分隔这些值。

但回想一下，学生们不仅有名字，不仅有学院，还有那个守护神。所以如果我们想也打印出那个，我们现在有了语法，可以通过它进入每个学生的同一个字典，并输出他们的守护神以及他们的学院和名字。

```python
for student in students:
    print(student["name"], student["house"], student["patronus"], sep=", ")
```

所以如果我最后一次运行这个程序，现在我看到了这个字典里所有的数据。

所以这一下子吸收了很多东西，我肯定。这是我们最后一种新的数据类型。在列表之上，我们有这些字典，但再次强调，字典，归根结底，只是一个值的集合，类似于这里的这些值，允许你将键与值关联起来。这个程序的第一个版本字面上将学生的名字与他们的学院关联起来，但后来我在我的下一个版本中意识到，等等，如果每个学生不仅有名字和学院，还有一个守护神呢？让我们实际上将我们键的名字标准化为 `name`, `house`, 和 `patronus`，然后这些键的值实际上可以是数据，比如 Hermione, Gryffindor, Otter, 等等。

现在关于这些字典及其迭代有什么问题吗？

**观众提问：** 我只是想知道，假设字典非常巨大，如果我想查找某个特定的学生，我怎么知道从哪里查找那个学生呢？比如我们可以按字母顺序或数字顺序排序吗？

**DAVID MALAN：** 简短回答是，可以。Python 的特性之一是它使这些字典对你来说性能非常高。也就是说，即使它们非常大，就像我们未来几周处理更多数据时会遇到的那样，Python 也会为你快速找到你关心的数据。事实上，这是语言的一个特性，是字典的一个特性，能让你快速获取数据。而且你可以使用一些函数。你可以对数据进行排序，你可以筛选它，你可以执行非常高效的操作，我们最终会的。

## **9. 嵌套循环 (Nested Loops)**

那么，请允许我建议，在我们结束这些循环的时候，我们只解决最后几个问题，这些问题也许会唤起往昔的美好回忆，至少对我来说是这样，我小时候最喜欢的游戏之一是这个，在最初的任天堂上。这是一个二维世界，角色向上、向下、向右移动，不怎么向左移动，跳过像这样的金字塔和障碍物。

请允许我建议我们只用这个作为灵感，不是要做像这样色彩丰富或图形化的东西，而只是关注，例如，世界中间的这个障碍物，马里奥或路易吉必须跳过去。所以这看起来像是三块砖叠在一起。我们不会做得那么图形化，但让我们只实现一个非常简单的基于 Python 的文本版本，也许只用井号 `#` 代表砖块。因为这里有一个模式，一个叠在另一个上面，我打赌我们可以用任何数量的方式来解决这个问题。

好吧，让我切换回 VS Code，我建议我们创建一个名为 `mario.py` 的程序，在终端窗口使用 `code` 命令。然后在这里上面，让我开始尽可能简单地实现同一幅图画，只打印字面上的井号，然后是井号，然后是第三个最后的井号。这将是一个非常文本化的近似，但我认为如果我运行 `python mario.py`，我就得到了那个砖块柱子的一个非常简单的版本，可以这么说。

```python
print("#")
print("#")
print("#")
```

但你可以想象，尤其是在一个游戏中，也许这些柱子会变高或变低，写出实际上比那更动态、不仅仅是使用 `print`, `print`, `print`（这看起来就是复制粘贴）的代码会很好。

所以让我至少采纳今天学到的一些教训，转而做类似这样的事情。`for _ in range(3):`，现在让我们一次只打印其中一个。

```python
for _ in range(3):
    print("#")
```

但现在我使用了 `range(3)` 这个事实意味着，如果我想把它改成更大或更小的值，我只需在一个地方修改，而不是在三个或更多地方修改。当然，如果我做对了，这段代码也只会打印出完全相同的东西。所以我们在这里进行了迭代。

但让我们看看我们现在是否能整合我们关于编写自己函数的讨论，开始编写一些更动态的东西，并最终解决更复杂的问题。

函数的好处之一是它们不仅允许我们编写可以复用和重用的代码，它们还允许我们创建抽象（abstractions），可以这么说。抽象是对一个潜在更复杂的想法的简化。我们在过去的几周里已经见过几次了。例如，我们有一个叫做 `hello` 的函数，诚然，它做的并不多，只是打印 "hello"。但它让我能够将函数视为它所做的事情，不是笼统地打印某些东西，而是字面上说 "hello"。我已经能够通过定义我自己的函数如 `get_number` 来用类似的方式获得一个数字。

好吧，让我，例如，暂时假设我有先见之明，在我的 `main` 函数中，使用了一个叫做 `print_column` 的函数。这似乎是用于打印一列砖块的函数的一个好名字。

```python
def main():
    print_column(3)

# 需要定义 print_column 函数

main()
```

那么，我现在如何用实际代码来实现这个抽象，这个 `print_column` 的简单想法呢？我们之前见过用 `def` 可以做到这一点。让我定义一个名为 `print_column` 的函数。让我接受一个泛指高度的参数，叫做 `height`。我可以叫它 `n` 或 `h`，但现在用 `height` 会更明确一点，只是为了提醒我自己它在做什么。现在我想我可以借用之前的一些相同代码。`for _ in range(height):`，然后打印一个单独的井号 `#`。

```python
def main():
    print_column(3)

def print_column(height):
    for _ in range(height):
        print("#")

main()
```

然后在这个整个程序的末尾，让我们只调用 `main`。所以我有点把代码复杂化了。它目前还没有做更多的事情，但它为我解决我认为将是更复杂的问题做好了准备。如果我运行 `python mario.py`，我们回到了起点。但我现在有了一个函数，一个抽象，`print_column`，它将让我能够考虑一次打印马里奥世界的一部分。

我也可以用不同的方式来做。注意，如果我真的想，我可以这样做。我现在可以用不同的方式实现 `print_column`，特别是如果我在我的代码中到处使用 `print_column`，或者更好的是，我的同事，我的朋友，互联网上的其他人正在使用我的 `print_column` 函数。你编写的函数还有一个好处是，你可以改变它们的底层实现细节，但只要你不改变函数的名字、它的参数或者它返回什么（如果有的话），别人是看不出区别的。如果你想改进它或者随着时间的推移进行修复，你可以随心所欲地改变内部实现。

例如，我们可以实现 `print_column` 的另一种方式，回想一下，可能是这样的。用一个井号 `#` 然后一个新行 `\n`，有点聪明，然后也许我们可以做字符串的乘法，然后用 `end=""` 来结束这一行。

```python
def print_column(height):
    print("#\n" * height, end="")
```

再次强调，如果你对这个语法不熟悉也没关系。这是我们过去看到的一种更聪明的方法。但如果我在这里运行 `python mario.py`，我仍然会看到一个三层高的柱子。但这里重要的是，`main` 函数不需要知道 `print_column` 的底层实现已经改变了。

好吧，让我们过渡到另一个维度，如果你愿意这么说的话，与其只打印这些垂直的砖块，让我们快进到游戏中的这个地方。在某个地方，马里奥会遇到空中这些砖块，如果他从下面跳起来顶它们，它们就会变成金币。这样他的分数就会增加。但让我们只关注那些金币，我建议我们打印出，哦，就这四个问号吧。

让我回到 VS Code。我建议在 VS Code 里，就像之前一样，我们尝试将这个抽象出来。所以让我去掉这个版本，因为我们现在是水平输出而不是垂直输出。让我只说，嗯，`print_row(4)`。让我只把手头的问题抽象出来。我还不知道我将如何打印那四个问号，但让我们称之为 `print_row(4)`，我假设我现在会解决这个问题。

```python
def main():
    print_row(4)

# 需要定义 print_row 函数

main()
```

现在让我们深入研究解决这个问题。定义一个名为 `print_row` 的函数。它将接受一个 `width` 而不是 `height`，因为它是水平而不是垂直的。我该怎么做呢？嗯，现在，我们有机会更优雅地使用字符串乘法。我可以说 `print("?" * width)`。这是一种非常漂亮、符合 Python 风格的方式来打印，否则可能需要一个循环，那也没关系，但这会为我打印那些问号。

```python
def main():
    print_row(4)

def print_row(width):
    print("?" * width)

main()
```

让我们运行 `python mario.py`，回车，现在我得到了四个问号。它远没有更图形化的版本那么漂亮，但它至少是朝着拥有像 `print_row` 这样的可重用函数迈出的一个构建块。

我为什么要这样做呢？比如为什么我们要过度设计这些问题的解决方案，弄出 `print_column` 和 `print_row`？嗯，这是一种有用的解决问题的技巧。一旦你的世界看起来不是像这样的一维，或者像柱子版本那样，那这个呢？在《超级马里奥兄弟》的后期，马里奥必须跳入这个世界，那里有很多这样的地下障碍物。例如，这里的这个看起来像一个正方形。它是二维的，有高度和宽度。也就是说，如果我们讨论，比如它是一个 $3 \times 3$ 的网格，一个 $3 \times 3$ 的正方形，我们有很多不同的方法可以实现这个东西。

那么，我们该如何解决这个问题呢？好吧，我建议我们回到 VS Code，我建议我们用几种不同的方式来思考这个问题。我可以这样做。如果我知道我要去哪里，也许我是一个经验丰富的程序员，让我这样做。

```python
def main():
    print_square(3)

# 需要定义 print_square 函数

main()
```

让我打印一个正方形，它的宽度和高度都是3。这是一个抽象。我只是暂时想当然地认为已经有一个叫做 `print_square` 的函数，它的宽度是3，高度也是3。但总得有人来实现这个，目前，键盘前只有我，所以让我们去实现那个正方形。

让我定义一个名为 `print_square` 的函数，它接受一个特定的 `size`，用于高度和宽度。

```python
def print_square(size):
    # ... 实现 ...
```

这就是我们有机会使用一些循环的地方。我们可以用一种我们还没用过的方式来使用这些循环。如果我想打印出所有这些行，但也打印出所有这些列，我现在不仅要像循环允许的那样周期性地思考，我还需要二维地思考。

如果你熟悉老式打字机，甚至现在的打印机，它通常是从上到下打印的。所以即使你有多列，你也是一次打印一行，当你在那一行上时，打印机或打字机是从左到右打印的。这就是你的黑白终端窗口要有的心智模型。到目前为止，每个例子的所有输出都是从顶部开始到底部结束。从上到下，从左到右。所以我们必须以同样的方式生成我们的输出，我们的正方形。

所以我建议我们这样做。我建议我们知道我们需要迭代这么多次，3次或更普遍地说是 `size` 次。所以让我这样做。`for i in range(size):`，我需要做三次什么？嗯，我想打印出什么？1, 2, 3 行砖块。但在每一行砖块内，我想打印什么？具体来说是 1, 2, 3 块砖。

所以如果我们回到我们的图表，并且我规定它确实是一个 $3 \times 3$ 的正方形，3宽3高，我想要做什么来打印第一行？我想打印砖块，砖块，砖块。我想在第二行打印什么？砖块，砖块，砖块。第三行呢？砖块，砖块，砖块。所以我做了三次同样的事情。必须进行大量的打印。

所以让我回到我的代码，现在我建议我们把这个我刚开始的外部循环看作代表我们的每一行。

```python
def print_square(size):
    # 对于正方形中的每一行
    for i in range(size):
        # ... 在这一行做什么 ...
```

`for i in range(size)` 将确保，无论我接下来做什么，我都可以打印出 1, 2, 3 行，或者更普遍地说是 `size` 行，其中 `size` 可以是3，但也可以更小或更大。

在每一行上我想做什么？嗯，就像老式打字机或打印机一样，在每一行上，我想打印出砖块，砖块，砖块；砖块，砖块，砖块；砖块，砖块，砖块。嗯，这听起来像一个周期，某种循环。所以也许我可以在一个循环内部有另一个循环。

```python
def print_square(size):
    # 对于正方形中的每一行
    for i in range(size):
        # 对于行中的每一块砖
        for j in range(size):
            # ... 打印砖块 ...
        # 打印完一行后...
```

我不想再用 `i` 了，因为我不想使用同一个变量而弄乱我的计数。所以我将按照惯例使用 `j`。非常常见的是先用 `i` 然后用 `j`——也许还有 `k`，但在那之后，你不应该继续相互嵌套。让我继续说 `for j in range(size)`，因为这是一个正方形，然后在每一行中，让我打印一个单独的井号 `#`，但没有新行，但在每一行之后，让我只打印一个新行。

```python
def print_square(size):
    # 对于正方形中的每一行
    for i in range(size):
        # 对于行中的每一块砖
        for j in range(size):
            print("#", end="")
        # 打印完一行后换行
        print()
```

这里有很多东西，特别是如果你以前从未接触过 Python，更不用说循环了，但请注意我在这里也做了什么，我将添加一些注释以便清晰。

```python
def print_square(size):
    # For each row in square
    for i in range(size):
        # For each brick in row
        for j in range(size):
            # Print brick
            print("#", end="")
        # Move to next line
        print()
```

这就是注释，以及更普遍的伪代码，真正能帮助向自己和他人解释你的代码行在做什么的地方。在第8行（指外层循环），我从 `$i = 0$` 迭代到 `size`。所以是 0, 1, 2。在第11行（指内层循环），我正在做完全相同的事情，但使用 `j` 从 0, 1, 2。但这很好，因为 `i` 代表我的每一行。当我在每一行上时，在这个外部循环内部，我将做砖块，砖块，砖块；1, 2, 3；1, 2, 3；1, 2, 3。但我不想让我的光标在我还在一行上时一直移动到下一行，所以我只是覆盖了那个行尾 `end=""`。

但让我向大家提一个问题，为什么在第16行（指最后的 `print()`）我有一个单独的 `print`？为什么我有一个单独的 `print`？注意它在内部循环之下，但在外部循环之内，可以这么说。第16行的那个 `print` 最终在做什么？

**观众提问：** 每次完成一行后，你必须在行尾添加一个新行。所以 `print()`，它会打印一个新行。

**DAVID MALAN：** 完美。我不想在每块砖之后都换行。我只想在行尾这样做，这就是为什么我的注释现在可能很有启发性。注意这个循环（指内层循环）只是为行中的每一块砖进行迭代。一旦我完成了那个内部循环，可以这么说，一旦我完成了这些高亮显示的行，正如 Evelyn 所说，我需要打印出一个空的新行。我们以前没有这样做过，但是当你调用不带参数的 `print()` 时，你得到的只是那个自动的行尾，即 `\n`，光标移动到下一行。

所以如果我现在回到我的终端窗口并运行 `mario.py`，我想我应该得到一个 $3 \times 3$ 的正方形。它在我的屏幕上看起来不太像一个正方形，因为这些井号有点高而不是宽，但它实际上是 $3 \times 3$。

但让我建议，就像我们一直在这里做的那样，我们如何进一步精简这段代码。为了清晰起见，让我暂时去掉我的注释，这样我们就能看到我们总共有多少行代码。

我建议我们也许这样做。我建议，你知道吗，这个内部循环，特别是如果你在理解一个循环嵌套在另一个循环内部时遇到困难，你并非严格需要它。如果我们再次使用那个技巧呢？如果我们打印出在外层也是唯一循环内部的每个井号 `#` 乘以我们想要它们的次数呢？我们从之前的方法中汲取灵感。

```python
def print_square(size):
    for i in range(size):
        print("#" * size)
```

现在运行 `python mario.py`，结果相同，但现在，`print_square` 非常漂亮和紧凑。它有一个显式的循环，并且它仍然使用字符串乘法一次性打印出该行上所有的井号。

如果你喜欢抽象，并且你想更好地理解代码在做什么，那么，让我们这样做。如果你不太清楚发生了什么，让我们建议你实现一个名为 `print_row` 的函数，传入 `size`。

```python
def main():
    print_square(3)

def print_square(size):
    for i in range(size):
        print_row(size)

def print_row(width):
    print("#" * width)

main()
```

我建议这个 `print_row` 函数，它简单地接受那个宽度 `width` 并打印出单个井号 `#` 乘以那么多次。换句话说，这里有一个抽象的机会，借此，嗯，打印一行意味着什么？嗯，当你在实现 `print_square` 时，我并不真正关心打印一行意味着什么，我只需要知道有人在负责打印那一行。你可以把责任完全推给另一个函数。`print_row` 是如何工作的？嗯，它可以使用 `for` 循环，它可以使用这个字符串乘法技巧。

这是一种将一个较大的程序——这可能是我们迄今为止看过的最复杂的一个——分解成这些较小的组件的方法，这些组件一旦组装起来，就能实现你的最终想法。

## **10. 总结**

没有看到问题，那么这就是我们对 Python 中循环的探讨的结束，这种能够周期性地、一次又一次地做事的能力，当我们把它们与条件语句（这种能够提出问题并回答问题的能力）以及我们的函数和变量结合起来时，我们现在真的拥有了解决更大、更有趣、更个性化问题所需的大部分构建块。

所以在接下来的几周里，我们将开始看到，当我们这样做时，到底可能会出什么问题，但我们将向你介绍更多的工具，通过这些工具你可以排除同样的问题。

---

# 要点回顾

**CS50P 第2讲 - 循环 (Loops)**

**1. 引言与循环的必要性**
- 目标：学习Python中的循环结构，实现代码的重复执行。
- 动机案例 (`cat.py`)：
    - 初始方案：重复使用 `print("meow")` 来打印三次 "meow"。
    - 问题：代码冗余，难以扩展（如打印500次），难以维护（如需将 "meow" 改为 "woof"）。
- 结论：需要更有效、更简洁的方法来处理重复任务，即循环。

**2. `while` 循环**
- 概念：`while` 关键字用于创建循环，只要给定条件（布尔表达式）为 `True`，循环体内的代码就会一直执行。
- 实现 `cat.py` 的 `while` 循环：
    - 需要一个计数器变量（如 `i`）。
    - **计数递减**:
        - 初始化 `i = 3`。
        - 循环条件：`while i != 0:`。
        - 循环体内：`print("meow")`，然后 `i = i - 1`。
    - **计数递增**:
        - 初始化 `i = 1`。
        - 循环条件：`while i <= 3:`。
        - 循环体内：`print("meow")`，然后 `i = i + 1`。
    - **从0开始计数（常用惯例）**:
        - 初始化 `i = 0`。
        - 循环条件：`while i < 3:`。
        - 循环体内：`print("meow")`，然后 `i = i + 1`。
    - **更新变量的简写**:
        - `i = i + 1` 可以写成 `i += 1`。
        - `i = i - 1` 可以写成 `i -= 1`。
- **无限循环**：
    - 如果循环条件永远为 `True`（例如忘记更新计数器），会导致无限循环。
    - 中断方法：通常使用 `Ctrl+C`。
- **流程图 (Flowchart)**：可用于可视化循环逻辑（开始 -> 初始化 -> 条件判断 -> (True) 执行代码块 -> 更新变量 -> 回到条件判断 -> (False) 结束）。

**3. `for` 循环与列表 (Lists)**
- 概念：`for` 循环提供另一种迭代方式，通常用于遍历序列中的每个元素。
- **列表 (List)**：
    - Python的一种数据类型，用于存储有序的项目集合。
    - 使用方括号 `[]` 定义，元素间用逗号 `,` 分隔。例如：`[0, 1, 2]` 或 `["Hermione", "Harry", "Ron"]`。
- 实现 `cat.py` 的 `for` 循环：
    - **遍历显式列表**: `for i in [0, 1, 2]: print("meow")`。变量 `i` 会依次取列表中的值 0, 1, 2。
    - **`range()` 函数**:
        - 用于生成一个数字序列。`range(3)` 生成序列 0, 1, 2。
        - 改进设计：`for i in range(3): print("meow")`。更简洁，易于扩展（如 `range(1000)`）。
        - `range(n)` 生成从 0 到 `n-1` 的整数。
    - **忽略循环变量**:
        - 如果循环变量（如 `i`）在循环体内未被使用，惯例上使用下划线 `_` 作为变量名：`for _ in range(3): print("meow")`。这向阅读者表明该变量仅用于计数，其值不重要。
- **Pythonic 技巧：字符串乘法**
    - 可以用乘法运算符 `*` 重复字符串。
    - 示例：`print("meow\n" * 3, end="")` 可以打印三行 "meow"。
        - `\n` 是换行符（转义序列）。
        - `print()` 函数的 `end=""` 参数可以取消默认打印后的换行。

**4. 循环与用户输入验证**
- 场景：需要从用户那里获取特定类型（如正整数）的输入。
- 问题：简单的 `if` 检查无法处理用户反复输入无效数据的情况。
- 解决方案：使用循环（通常是 `while`）来持续提示用户，直到获得有效输入。
- **常见模式 (无限循环与 `break`)**:
    - `while True:`：故意创建一个无限循环。
    - 循环内部获取输入：`n = int(input("What's n? "))`。
    - 验证输入：`if n > 0:`。
    - `break`：如果输入有效，使用 `break` 关键字跳出当前循环。
- `continue` 关键字：跳过当前迭代的剩余部分，直接进入下一次迭代（在本例中较少使用，但也是循环控制语句）。

**5. 结合函数进行抽象 (Abstraction with Functions)**
- 良好实践：将代码块封装到函数中，提高可重用性、可读性和可维护性。
- 示例：
    - `get_number()` 函数：封装获取并验证正整数输入的逻辑（使用 `while True` 和 `return n`）。
    - `meow(n)` 函数：封装打印 `n` 次 "meow" 的逻辑（使用 `for` 循环）。
- `main()` 函数：组织程序的主要流程，调用自定义函数。
- **函数返回值 (`return`)**: 函数可以使用 `return` 语句将计算结果或获取的值传递回调用者。

**6. 列表迭代与 `len()` 函数**
- `hogwarts.py` 示例：处理学生列表 `students = ["Hermione", "Harry", "Ron"]`。
- **列表索引 (Indexing)**：
    - 列表元素通过从 0 开始的数字索引访问。`students[0]` 是 "Hermione"。
- **直接遍历元素**:
    - `for student in students: print(student)`。这是最直接、最 Pythonic 的方式。
- **`len()` 函数**:
    - 返回列表（或其他序列类型）的长度（元素个数）。`len(students)` 返回 3。
- **通过索引遍历**:
    - `for i in range(len(students)): print(i + 1, students[i])`。
    - 当需要知道元素的位置（索引）以及元素本身时很有用。

**7. 字典 (Dictionaries)**
- **字典 (dict)**：
    - Python 的另一种核心数据类型，用于存储**键值对 (key-value pairs)**。
    - 使用花括号 `{}` 定义，键和值之间用冒号 `:` 分隔，键值对之间用逗号 `,` 分隔。例如：`{"name": "Harry", "house": "Gryffindor"}`。
    - 键必须是唯一的且通常是不可变类型（如字符串、数字）。
    - 用于关联相关信息，比使用平行列表（parallel lists）更清晰、更不易出错。
- `hogwarts.py` 示例 (v1 - 键是学生名):
    - `students = {"Hermione": "Gryffindor", "Harry": "Gryffindor", ...}`。
- **访问值**:
    - 通过键来访问对应的值：`students["Hermione"]` 返回 "Gryffindor"。
- **遍历字典**:
    - `for student in students:` 默认遍历字典的**键**。
    - 访问键和值：`print(student, students[student])`。

**8. 字典列表 (Lists of Dictionaries)**
- 场景：需要为每个项目存储多个属性（例如，每个学生有名字、学院、守护神）。
- 结构：创建一个列表，列表中的每个元素是一个字典。
- `hogwarts.py` 示例 (v2 - 列表，每个元素是包含学生信息的字典):
    ```python
    students = [
        {"name": "Hermione", "house": "Gryffindor", "patronus": "Otter"},
        {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
        # ... 其他学生
        {"name": "Draco", "house": "Slytherin", "patronus": None}
    ]
    ```
- **`None`**:
    - Python 中的特殊值，表示值的缺失或空。
- **遍历字典列表**:
    - `for student in students:`：`student` 在每次迭代中是列表里的一个字典。
    - 访问字典内的值：`print(student["name"], student["house"], student["patronus"])`。

**9. 嵌套循环 (Nested Loops)**
- 概念：将一个循环放在另一个循环的内部。
- 用途：常用于处理二维结构，如网格、矩阵或打印图案。
- `mario.py` 示例：打印一个由 `#` 组成的方块。
- **实现方块打印**:
    - **外层循环**控制行数。
    - **内层循环**控制每行打印的字符数（列数）。
    - 示例 (打印 3x3 方块):
        ```python
        for i in range(3):  # 控制行
            for j in range(3):  # 控制列
                print("#", end="")  # 打印字符，不换行
            print()  # 在内层循环结束后（即一行打印完毕后）换行
        ```
- **优化**:
    - 内层循环可以用字符串乘法代替：`for i in range(3): print("#" * 3)`。
- **抽象化**:
    - 可以将打印一行的逻辑封装到 `print_row(width)` 函数中。
    - 可以将打印整个方块的逻辑封装到 `print_square(size)` 函数中，内部调用 `print_row` 或直接使用嵌套/乘法。这体现了将复杂问题分解为小问题的思想。

**10. 总结**
- 循环（`while` 和 `for`）是编程中实现重复操作的关键结构。
- 结合条件语句、函数、变量以及列表和字典等数据结构，可以构建出功能强大的程序。
- 这些是解决更复杂问题的基础构建块。
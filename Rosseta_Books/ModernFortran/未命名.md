
# Modern Fortran 构建高效并行应用程序

[美] Milan Curcic 著
Damian Rouson 作序

![封面图片](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/7ffd35bb2135229d51e26a196e2172e831200e70398575b324a5dc7249306d4b.jpg)

*Fortran 程序、函数和子例程概览*

# Modern Fortran 构建高效并行应用程序

MILAN CURCIC 著
DAMIAN ROUSON 作序

曼宁 (MANNING)
SHELTER ISLAND

欲了解本书及其他 Manning 图书的在线信息和订购，请访问 www.manning.com。出版商对批量订购本书提供折扣。欲了解更多信息，请联系：

Special Sales Department (特殊销售部)
Manning Publications Co.
20 Baldwin Road
PO Box 761
Shelter Island, NY 11964
Email: orders@manning.com

©2020 by Manning Publications Co. 版权所有。

未经出版商事先书面许可，不得以任何形式或通过任何电子、机械、影印或其他方式复制、存储在检索系统中或传播本出版物的任何部分。

制造商和销售商用于区分其产品的许多名称均声称为商标。凡本书中出现这些名称，且 Manning Publications 已知晓商标声明之处，这些名称均以首字母大写或全部大写的形式印刷。

® 认识到保存已书写内容的重要性，Manning 的政策是使用无酸纸印刷我们出版的书籍，并且我们为此付出了最大的努力。同时，认识到我们保护地球资源的责任，Manning 图书使用至少 15% 的回收纸张印刷，并在不使用元素氯的情况下进行处理。

Manning Publications Co. 20 Baldwin Road PO Box 761 Shelter Island, NY 11964

开发编辑：Lesley Trites
技术开发编辑：Michiel Trimpe
审阅编辑：Aleksandar Dragosavljevic´
制作编辑：Lori Weidert
文字编辑：Frances Buran
校对：Melody Dolab
技术校对：Maurizio Tomasi
排版：Dennis Dalinnik
封面设计：Marija Tudor

---

序 xi
前言 xiii
致谢 xiv
关于本书 xvi
关于作者 xxii
关于封面插图 xxiii

---

# 目录
```
**第一部分 现代 FORTRAN 入门........ 1**

**第 1 章 Fortran 简介 3**

*   1.1 什么是 Fortran？ 4
*   1.2 Fortran 的特性 6
*   1.3 为什么要学习 Fortran？ 8
*   1.4 优点和缺点 10
    *   与 Python 的并排比较 10
*   1.5 并行 Fortran 图解 12
*   1.6 你将在本书中学到什么？ 13
*   1.7 并行思考！ 14
    *   将数组从一个处理器复制到另一个处理器 17
*   1.8 运行示例：并行海啸模拟器 22
    *   为什么是海啸模拟器？ 22
    *   浅水方程 23
    *   我们希望我们的应用做什么 24
*   1.9 进一步阅读 25

**第 2 章 入门：最小可行应用 26**

*   2.1 编译并运行你的第一个程序 27
*   2.2 模拟物体的运动 28
    *   我们的应用应该做什么？ 29
    *   什么是平流？ 30
*   2.3 实现最小可行应用 31
    *   实现策略 32
    *   定义主程序 33
    *   声明和初始化变量 34
    *   数值数据类型 35
    *   声明应用中要使用的数据 37
    *   使用 if 块进行分支 40
    *   使用 do 循环进行迭代 42
    *   设置初始水高值 44
    *   预测物体的运动 45
    *   将结果打印到屏幕 47
    *   整合所有内容 47
*   2.4 继续海啸模拟器 51
*   2.5 答案解析 52
    *   练习：冷锋传播 52
*   2.6 新 Fortran 元素概览 52
*   2.7 进一步阅读 52

---

**第二部分 FORTRAN 核心元素 55**

**第 3 章 使用函数和子例程编写可重用代码 57**

*   3.1 迈向更高的应用复杂度 58
    *   重构海啸模拟器 58
    *   重温冷锋问题 61
    *   Fortran 程序单元概述 63
*   3.2 不要重复自己，使用过程 65
    *   你的第一个函数 65
    *   在海啸模拟器中将有限差分表示为函数 70
*   3.3 使用子例程修改程序状态 72
    *   定义和调用子例程 72
    *   何时使用子例程而非函数？ 74
    *   在海啸模拟器中初始化水高 75
*   3.4 编写纯过程以避免副作用 76
    *   什么是纯过程？ 76
    *   纯过程的一些限制 77
    *   为什么纯函数很重要？ 77
*   3.5 编写可同时操作标量和数组的过程 77
*   3.6 带有可选参数的过程 79
*   3.7 海啸模拟器：整合所有内容 81
*   3.8 答案解析 82
    *   练习 1：使用子例程修改状态 82
    *   练习 2：编写一个可同时操作标量和数组的元素函数 83
*   3.9 新 Fortran 元素概览 83
*   3.10 进一步阅读 84

**第 4 章 使用模块组织你的 Fortran 代码 85**

*   4.1 访问模块 86
    *   获取编译器版本和选项 86
    *   使用可移植数据类型 89
*   4.2 创建你的第一个模块 91
    *   自定义模块的结构 92
    *   定义模块 93
    *   编译 Fortran 模块 95
    *   控制对变量和过程的访问 97
    *   在海啸模拟器中整合所有内容 98
*   4.3 迈向真实的波浪模拟 99
    *   物理学简述 101
    *   更新有限差分计算 102
    *   重命名导入的实体以避免名称冲突 104
    *   完整代码 105
*   4.4 答案解析 107
    *   练习 1：在海啸模拟器中使用可移植类型种类 107
    *   练习 2：在模块中定义 `set_gaussian` 子例程 107
*   4.5 新 Fortran 元素概览 108
*   4.6 进一步阅读 108

**第 5 章 使用数组分析时间序列数据 110**

*   5.1 使用 Fortran 数组分析股票价格 111
    *   本练习的目标 111
    *   关于数据 112
    *   获取数据和代码 114
*   5.2 寻找表现最佳和最差的股票 114
    *   声明数组 116
    *   数组构造器 118
    *   从文件读取股票数据 121
    *   分配特定大小或范围的数组 122
    *   从另一个数组分配数组 123
    *   赋值时自动分配 123
    *   使用后清理 124
    *   检查分配状态 126
    *   捕获分配和释放错误 126
    *   实现 CSV 读取器子例程 127
    *   数组索引和切片 129
*   5.3 识别风险股票 132
*   5.4 寻找买入和卖出的好时机 135
*   5.5 答案解析 139
    *   练习 1：便捷的（反）分配器子例程 139
    *   练习 2：反转数组 140
    *   练习 3：计算移动平均值和标准差 140
*   5.6 新 Fortran 元素概览 141
*   5.7 进一步阅读 141

**第 6 章 读取、写入和格式化你的数据 143**

*   6.1 你的第一个 I/O：从键盘输入和输出到屏幕 144
    *   最简单的 I/O 144
    *   一次读取和写入多个变量 147
    *   标准输入、输出和错误 148
*   6.2 格式化数字和文本 151
    *   设计飞机仪表盘 151
    *   格式化字符串详解 152
    *   旧式 Fortran 代码中的格式语句 157
*   6.3 写入磁盘文件：一个最小的笔记应用 157
    *   打开文件并写入 158
    *   打开文件 159
    *   写入文件 161
    *   追加到文件 162
    *   以只读或只写模式打开文件 163
    *   检查文件是否存在 164
    *   错误处理和关闭文件 167
*   6.4 答案解析 168
    *   练习：将标准输出和标准错误重定向到文件 168
*   6.5 新 Fortran 元素概览 169

---

**第三部分 高级 FORTRAN 应用 171**

**第 7 章 使用 Fortran 协同数组 (Coarrays) 进行并行化 173**

*   为什么要编写并行程序？ 174
*   7.2 处理真实的海洋浮标数据 175
    *   关于数据 176
    *   获取数据和代码 178
    *   目标 178
    *   程序的串行实现 179
*   7.3 使用映像 (images) 和协同数组进行并行处理 181
    *   Fortran 映像 182
    *   获取有关映像的信息 18? (*页码原文模糊*)
    *   告诉映像该做什么 184
    *   将所有数据收集到单个映像 186
*   7.4 协同数组和同步详解 187
    *   声明协同数组 188
    *   分配动态协同数组 188
    *   发送和接收数据 189
    *   控制映像执行顺序 191
*   7.5 迈向并行海啸模拟器 192
    *   实现策略 192
    *   查找邻居映像的索引 194
    *   分配协同数组 195
    *   主时间循环 196
*   7.6 答案解析 199
    *   练习 1：查找每个映像上的数组子范围 199
    *   练习 2：编写一个返回邻居映像索引的函数 200
*   7.7 新 Fortran 元素概览 201
*   7.8 进一步阅读 201

**第 8 章 使用派生类型处理抽象数据 202**

*   8.1 使用派生类型重构海啸模拟器 203
*   8.2 定义、声明和初始化派生类型 206
    *   定义派生类型 209
    *   实例化派生类型 210
    *   访问派生类型组件 212
    *   派生类型构造函数中的位置参数与关键字参数 212
    *   为派生类型组件提供默认值 214
    *   编写自定义类型构造函数 215
    *   Field 类型的自定义类型构造函数 218
*   8.3 将过程绑定到派生类型 220
    *   你的第一个类型绑定方法 220
    *   Field 类型的类型绑定方法 221
    *   控制对类型组件和方法的访问 222
    *   整合所有内容 224
*   8.4 将海啸模拟器扩展到二维 224
    *   从一维数组到二维数组 225
    *   更新方程组 226
    *   x 和 y 方向的有限差分 226
    *   将类实例传递给 `diffx` 和 `diffy` 函数 228
    *   海啸求解器的派生类型实现 229
*   8.5 答案解析 231
    *   练习 1：使用私有组件 231
    *   练习 2：从实例数组调用类型绑定方法 233
    *   练习 3：计算 y 方向的有限差分 233
*   8.6 新 Fortran 元素概览 234
*   8.7 进一步阅读 235

**第 9 章 适用于任何数据类型的泛型过程和运算符 236**

*   9.1 分析不同类型的天气数据 237
    *   关于数据 238
    *   目标 241
    *   本练习的策略 242
*   9.2 类型系统和泛型过程 242
    *   静态类型与强类型 242
*   9.3 编写你的第一个泛型过程 243
    *   强类型的问题 243
    *   编写特定函数 244
    *   编写泛型接口 247
    *   结果和完整程序 251
*   9.4 内置和自定义运算符 253
    *   什么是运算符？ 253
    *   运算符可以做什么 253
    *   Fortran 的内置运算符 255
    *   运算符优先级 257
    *   编写自定义运算符 257
    *   重定义内置运算符 258
*   9.5 海啸模拟器中的泛型过程和运算符 259
    *   为 Field 类型编写用户定义的运算符 259
*   9.6 答案解析 260
    *   练习 1：派生类型的特定平均函数 260
    *   练习 2：定义新的字符串连接运算符 262
*   9.7 新 Fortran 元素概览 263

**第 10 章 派生类型的用户定义运算符 264**

*   10.1 生日快乐！一个倒计时应用 265
    *   一些基本规格 265
    *   实现策略 266
*   10.2 获取用户输入和当前时间 266
    *   你的第一个 datetime 类 266
    *   读取用户输入 267
    *   获取当前日期和时间 271
*   10.3 计算两个时间之间的差值 272
    *   建模时间间隔 273
    *   实现自定义减法运算符 273
    *   时间差算法 275
    *   完整程序 280
*   10.4 在海啸模拟器中重载运算符 282
    *   Field 类回顾 283
    *   实现 Field 类的算术运算 284
    *   赋值时同步并行映像 286
*   10.5 答案解析 288
    *   练习 1：验证用户输入 288
    *   练习 2：公历中的闰年 289
    *   练习 3：实现 Field 类型的加法 289
*   10.6 新 Fortran 元素概览 290

---

**第四部分 最后冲刺 291**

**第 11 章 与 C 的互操作性：将你的应用暴露给 Web 293**

*   11.1 C 接口：编写最小的 TCP 客户端和服务器 294
    *   将网络引入 Fortran 295
    *   安装 libdill 297
*   11.2 TCP 服务器程序：接收网络连接 297
    *   IP 地址数据结构 299
    *   初始化 IP 地址结构 301
    *   检查 IP 地址值 306
    *   插曲：匹配兼容的 C 和 Fortran 数据类型 308
    *   创建套接字并监听连接 310 (*页码原文模糊*)
    *   接受套接字的传入连接 311
    *   向客户端发送 TCP 消息 312
    *   关闭连接 315
*   11.3 TCP 客户端程序：连接到远程服务器 317
    *   连接到远程套接字 317
    *   接收消息 319
    *   完整的客户端程序 321
*   11.4 一些有趣的混合 Fortran-C 项目 322
*   11.5 答案解析 322
    *   练习 1：`ipaddr_port` 的 Fortran 接口 322
    *   练习 2：`suffix_detach` 和 `tcp_close` 的 Fortran 接口 323
*   11.6 新 Fortran 元素概览 324
*   11.7 进一步阅读 324

**第 12 章 使用团队 (teams)、事件 (events) 和集体 (collectives) 进行高级并行 326**

*   12.1 从协同数组到团队、事件和集体 327
*   12.2 将映像分组到具有共同任务的团队中 328
    *   海啸模拟器中的团队 329
    *   组建新团队 331
    *   在团队之间切换执行 332
    *   同步团队和交换数据 335
*   12.3 发布和等待事件 338
    *   推送通知示例 339
    *   发布事件 341
    *   等待事件 341
    *   计算事件发布次数 342
*   12.4 使用集体进行分布式计算 343
    *   计算分布式数组的最小值和最大值 343
    *   集体子例程语法 345
    *   向其他映像广播值 346
*   12.5 答案解析 347
    *   练习 1：猎人和采集者 347
    *   练习 2：使用事件记录海啸时间步长 350
    *   练习 3：计算水高的全局平均值 351
*   12.6 新 Fortran 元素概览 353
*   12.7 进一步阅读 353

---

附录 A 设置 Fortran 开发环境 355
附录 B 从微积分到代码 361
附录 C 结束语 366
索引 381

---


```

# 序 (Foreword)

得知 Milan Curcic 将要撰写一本关于现代 Fortran 的书，我立刻感到兴奋。几乎每周，我都会遇到一些人，他们对 Fortran 在诞生 60 多年后仍在使用表示惊讶，因此，对于这样一门经常被认为已经死亡或正在消亡的语言来说，任何新生的迹象都值得庆祝。我通常会解释说，Fortran 在那些早期拥抱计算的领域拥有最稳固的立足点。我接着告诉他们，他们在查看天气预报时，几乎肯定每天都在使用 Fortran 程序的结果。Milan 的工作之所以引人入胜，在于它在多大程度上连接了 Fortran 长期占据主导地位的成熟领域和 Fortran 罕见的新兴领域。这本书源于 Milan 独特的视角，他参与了弥合分歧的工作——这些分歧阻碍了许多学科编写 Fortran，也阻碍了大多数 Fortran 程序员利用在其他语言中已广泛使用的编程范式。

值得称赞的是，本书专注于教授 Fortran 编程，而不是推广他所贡献的那些有趣的软件库和应用程序。幸运的读者如果跟随链接去了解他和别人的工作，将不仅仅获得对 Fortran 编程的理解。这样的读者将踏上一段旅程，连接数值天气预报（一个与计算一样古老的学科）和云计算（一项 21 世纪的创新）。这样的读者还将发现如何在 Fortran（所有高级编程语言的终极祖先）中融入函数式编程的方面——这是一种围绕其构建了整个语言的范式。这样的读者还将接触到神经网络——一个正在爆炸性增长并影响着从自动驾驶到癌症诊断等各种技术的学科。

Milan 在这些领域都领导或贡献了流行的软件，其中一些软件包源于本书，反之亦然。例如，他与他人共同开发的服务 Cloudrun (https://cloudrun.co) 开创了使用云计算平台的数值天气预报软件即服务 (SaaS)。开源的 functional-fortran 库 (http://mng.bz/vxy1) 提供了支持一种编程范式的实用工具，这种范式在 Fortran 世界的渗透程度不如我所希望的那样深。开源的 Fortran 标准库 (https://github.com/fortran-lang/stdlib) 旨在使 Fortran 与其他受益于被视为语言一部分的大型库的语言处于更平等的地位。他的 neural-fortran (https://github.com/modern-fortran/neural-fortran) 源于他对本书某一章的工作，展示了 Fortran 可扩展并行编程模型在一个由缺乏能够利用分布式内存平台的内置并行编程模型的语言主导的领域中的应用。总的来说，这些项目被全球数百名开发人员使用，他在这本书上的工作与在这些项目上的工作之间的相互作用，为本书对该语言的覆盖提供了信息和启发。

对于寻求现代 Fortran 生命力证据的读者来说，Milan 的工作为这门语言在技术现代化中持续扮演的角色提供了充分的证据。这本书是他工作中长出的更具活力的萌芽之一，感兴趣的读者将学习到在他上述广泛的项目组合中证明有用的语言特性。

——DAMIAN ROUSON 博士, P.E.
Sourcery Institute 总裁，美国加利福尼亚州奥克兰市

---

# 前言 (Preface)

当 Manning 的 Mike Stephens 在 2017 年夏天第一次联系我时，他写道：“我们看到你的一些论坛帖子和 GitHub 仓库；你会考虑和 Manning 一起写一本 Fortran 的书吗？”写书从未出现在我的脑海里，我也不相信自己能胜任这份工作。我闭上眼睛，纵身一跃。“当然，我很乐意！我应该把提案发到哪里？”到那个夏天结束时，我们已经签订了合同，并有了一个初步的目录。经历了两位开发编辑、两位技术编辑、四次同行评审、三次章节重写、两次飓风，以及将近三年的时间，我们完成了这本书。

欢迎来到《现代 Fortran：构建高效并行应用程序》！如果你手持这本书，很可能你要么想为学业或工作学习 Fortran 编程，要么你是一位经验丰富的 Fortran 程序员，希望温习该语言的最新发展。无论哪种情况，你都来对地方了。如果你是初学者，我写这本书的目标是为你提供一种直接、动手、实用的 Fortran 编程方法。如果你对这门语言有先前的经验，我希望这本书能成为 Fortran 世界中一本方便的生存指南。忘记了如何编写同时操作标量和数组的函数？想知道如何为并行执行编写程序？实用的项目和带有解决方案的练习将向你展示如何做。

我很高兴有机会与你分享我过去 14 年所学到的知识。预先感谢你信任我，花费你的时间和金钱。《现代 Fortran》是我回馈那些教导我、帮助我一路走来的数十位人士的方式。我希望你用这本书来教导下一代 Fortran 程序员。

---

# 致谢 (Acknowledgments)

成就一本好书需要众人的努力。Mike Stephens 是收购编辑——他把我带上船，帮助制定了目录，并明确了这本书的目标读者。我的开发编辑 Kristen Watterson 和 Lesley Trites 一路指导我，并勤奋地推动我前进。Kristen 与我一起完成了九个章节的初稿；然后 Lesley 接手了剩余部分和整合工作。技术编辑 Michiel Trimpe 和 Alain Couniot 确保指出了代码中的任何错误和令人困惑、不合逻辑的段落。Bert Bates 偶尔会介入，帮助我从抽象中提炼出具体内容。Maurizio Tomasi 是技术校对，确保书中的所有代码都按广告宣传的那样工作。Melody Dolab 是最终校对，Lori Weidert 是制作编辑。还有与我合作的其他 Manning 员工：Candace Gillhoolley, Ana Romac, Rejhana Markanovic, Aleksandar Dragosavljevic´, Matko Hrvatin 等等。感谢你们所有人——我从你们身上学到了很多。

我还要感谢所有的审阅者：Anders Johansson, Anton Menshov, Bridger Howell, David Celements, Davide Cadamuro, Fredric Ragnar, Jan Pieter Herweijer, Jose San Leandro, Joseph Ian Walker, Kanak Kshetri, Ken W. Alger, Konrad Hinsen, Kyle Mandli, Leonardo Costa Prauchner, Lottie Greenwood, Luis MouxDomínguez, Marcio Nicolau, Martin Beer, Matthew Emmett, Maurizio Tomasi, Michael Jensen, Michal Konrad Owsiak, Mikkel Arentoft, Ondrˇej Cˇertík, Patrick Seewald, Richard Fieldsend, Ryan B. Harvey, Srdjan Santic, Stefano Borini, Tiziano Müller, Tom Gueth, Valmiky Arquissandas, 以及 Vincent Zaballa。你们的建议帮助这本书变得更好。

Arjen Markus 在 Manning 早期访问计划 (Early Access Program) 中对每一章都提供了详尽的审阅和建议。Izaak Beekman, Jacob Williams, Marcus Van Lier-Walqui, 和 Steve Lionel 对本书的早期草稿提供了有益的评论。Damian Rouson 和他自己的书是我的灵感来源，他一路鼓励我前进。Michael Hirsch 帮助对与本书相关的一些 GitHub 仓库进行了持续集成。最后，所有信任我并在书还在创作过程中就购买了它的读者们——你们帮助我坚持下去并完成了这项工作。

最后但同样重要的是，感谢我的妻子、家人和朋友们，他们支持我并为我感到骄傲——没有你们的爱和帮助，我不可能完成这一切。

---

# 关于本书 (About this Book)

《现代 Fortran》旨在填补现有 Fortran 文献中一个明显的空白：一本通过实用、动手实践的例子来教授现代 Fortran 的书，特别关注并行编程和该语言的最新发展。这本书是为那些希望使用成熟、高性能、易于使用的技术来解决未来挑战性计算问题的科学家和工程师而写的。如果你对 Fortran 一无所知，并且想参与一个 Fortran 项目（新的或现有的），我相信这本书是让你快速入门的最简单、最快的方式。

《现代 Fortran》并非关于该语言所有特性的完整参考手册。相反，它是一门关于 Fortran 编程的直接、动手实践的课程，涵盖了你在工作中可能使用的最基本特性。我也希望它能成为解决科学和工程领域日常实际问题的有用参考文本。本书中的例子范围广泛，从更通用的，如笔记应用和处理日期时间；到更专业的，如股票价格和天气数据分析；再到更复杂的，如并行海啸模拟。你会发现许多例子和问题的解决方案，这些通常是其他 Fortran 书籍所不涵盖的。

此外，与大多数其他 Fortran 书籍不同，本书特别关注并行编程。自 2008 年发布以来，Fortran 成为一种原生并行编程语言，而最近的 2018 年发布版更是带来了更多功能。特别是，本书将向你展示如何使用协同数组 (coarrays)、团队 (teams)、事件 (events) 和集体 (collectives) 编写并行 Fortran 程序，而无需依赖外部库，如消息传递接口 (Message Passing Interface, MPI)。

然而，并行编程是一个高级主题，书中的大部分章节都侧重于温和地介绍非并行的语言概念。一本书能容纳的内容有限，因此像并行算法和可扩展性这样重要的主题并未涵盖。消息传递接口 (MPI)、OpenMP 和 OpenACC，虽然它们本身都是重要的技术，但超出了本书的范围。调试、预处理器和处理遗留代码也是如此。在适当的地方，我会提供进一步阅读的参考资料。

## 谁应该读这本书 (Who should read this book)

本书主要面向那些刚接触 Fortran 并希望学习它的读者。对于那些希望通过有趣的练习来温习 Fortran 最新发展的经验丰富的 Fortran 程序员来说，它也将非常有用。无论你之前是否接触过 Fortran，我都假设你至少有一些编程经验，并理解源代码、变量和函数的基本概念。也许你是一位熟练的 Fortran 程序员，希望提升你的并行编程技能。也许你的公司正在将一个大型 Fortran 模拟代码库嵌入到现有的软件栈中，而这个项目落到了你的头上。无论你的背景如何，我相信你都能从这本书中学到新的东西。

我相信以下职业将从本书中受益最多：

*   科学或工程专业的学生和研究人员，特别是涉及计算流体力学的学科
*   气象学家、海洋学家和气候科学家，特别是那些从事数值预测问题的人员
*   数据分析专业人士，如数据工程师和数据科学家
*   机器学习研究人员和实践者
*   量化金融分析师
*   高性能计算系统管理员
*   上述任何学科的教师和讲师，或任何对编程语言和计算感兴趣的人。

## Fortran 简史 (A bit of Fortran history)

Fortran 是一种编译型、静态类型、通用的编程语言。它由 John Backus 和他在 IBM 的团队开发，于 1957 年首次发布，用于 IBM 704 计算机。最初称为 FORTRAN (FORmula TRANslation，公式翻译)，它使程序员能够比编写当时的机器指令更容易地编写程序。Fortran 是历史上最早的高级编程语言之一，并且是至今仍在积极使用和发展的最古老的语言。从这个意义上说，Fortran 是我们今天实践的现代计算的开端。

此后，该语言经历了十几次修订和几个 ISO 标准。Fortran 仍然是高性能计算 (HPC) 的主导语言，在 HPC 领域，许多相互连接的处理器协同工作以解决巨大的问题。Fortran 2018 是该语言的最新版本。下一个修订版，目前的工作名称为 Fortran 202x，正在开发中，预计将在未来几年发布。

如今，Fortran 是物理科学和工程许多领域的主要编程语言。这些领域包括计算流体力学、数值天气预报、气候科学、空气动力学、天体物理学等等。Fortran 也用于对世界上最快、最大的超级计算机进行基准测试 (https://top500.org)。许多大学仍在科学和工程课程中教授 Fortran 编程，因为 Fortran 在这些行业中仍然具有重要意义。随着过去 20 年互联网和移动技术的爆炸式增长，Fortran 生态系统显然已经退居幕后，至少从主流计算的角度来看是这样。然而，其重要性在绝对尺度上从未减弱。事实上，Fortran 编译器、Fortran 库及其开源社区比以往任何时候都更强大。Fortran 是唯一具有原生并行编程模型的标准化语言，使用直观的类数组语法表示。随着当前向多核架构发展的趋势，可以肯定地说，Fortran 在未来许多年内仍将具有重要意义。

## 本书的组织结构：路线图 (How this book is organized: a roadmap)

《现代 Fortran》分为四个部分和十二章：

*   **第一部分——现代 Fortran 入门**
    *   第 1 章将让你初步了解 Fortran 以及它最擅长解决哪类问题。
    *   第 2 章将指导你完成一个基础但完整的 Fortran 程序。

*   **第二部分——Fortran 核心元素**
    *   第 3 章将教你使用过程来简化和重用你的 Fortran 程序。
    *   第 4 章解释了如何将你的过程和变量组织在模块中。
    *   第 5 章涵盖了数组和整数组运算。
    *   第 6 章处理输入输出，以及将数值数据格式化为文本。

*   **第三部分——高级 Fortran 应用**
    *   第 7 章将向你展示如何使用映像 (images) 和协同数组 (coarrays) 进行并行编程。
    *   第 8 章涵盖了用于处理抽象和复杂数据结构的派生类型 (derived types)。
    *   第 9 章解释了如何编写可以处理任何数据类型参数的泛型过程 (generic procedures)。
    *   第 10 章涵盖了派生类型的用户定义运算符 (user-defined operators)。

*   **第四部分——最后冲刺**
    *   第 11 章将教你如何从 Fortran 调用现有的 C 库。
    *   第 12 章涵盖了高级并行编程概念：团队 (teams)、事件 (events) 和集体 (collectives)。

第一部分将让你初步了解 Fortran。如果你是 Fortran 新手，请从这部分开始学习。即使你有一些 Fortran 经验，如果你想跟着完成运行示例（海啸模拟器），它是在第 2 章中介绍的。在第一部分结束时，你将能够编写、编译和运行基本的、可工作的 Fortran 程序。

在第二部分，我涵盖了该语言的核心元素：过程（函数和子例程）、模块、数组和 I/O。这些是你在大多数 Fortran 项目中会遇到的特性，对于编写干净、有组织、可重用的代码至关重要。在第二部分结束时，你将能够编写更复杂的 Fortran 程序和库来解决实际问题。如果你精通一种或多种其他编程语言，可以从这里开始。完成这部分的学习并积累一些实践经验后，你将成为一名功能齐全且独立的 Fortran 程序员。

第三部分介绍了使用协同数组 (coarrays) 的并行编程（第 7 章），以及派生类型（第 8 章）、泛型过程（第 9 章）和自定义运算符（第 10 章）。在这里，你将编写你的第一个并行程序，使用类对复杂数据结构进行建模，并编写可以处理任何数据类型的泛型过程。这部分依赖于第二部分介绍的概念。请先熟悉这些概念。完成第三部分的学习后，你将能够理解、重用和扩展现有的大部分 Fortran 代码，并能编写创新的并行 Fortran 解决方案。这是本书内容最重的一部分——请耐心并以开放的心态来学习。

最后，第四部分涵盖了特殊主题：从 Fortran 调用 C 代码（第 11 章）以及最近添加到该语言中的高级并行特性——团队 (teams)、事件 (events) 和集体 (collectives)（第 12 章）。前者对于将 Fortran 用于系统编程、网络、与仪器接口或重用现有 C 库来完成任何任务非常重要。后者是 Fortran 并行编程的前沿。我建议只有在熟悉第二部分和第三部分涵盖的概念之后再学习这些章节。

在决定组织不同章节和主题的顺序时，我们发现没有明显的最佳答案。根据你的经验和兴趣，你可能会发现一些更基础的主题可能在书的后面才涉及。如果是这样，请随时跳过并稍后再回来。就像任何新创作一样，这本书是一次实验。选择你自己的冒险，做你感觉舒服的事情。

## 关于代码 (About the code)

本书开发了相当多的源代码，主要组织在一个大型运行示例（海啸模拟器）和几个迷你项目中。本书中的所有代码都组织在 GitHub 上的 Git 仓库中：https://github.com/modern-fortran。海啸模拟器和迷你项目各有其独立的 GitHub 仓库，因此你可以独立地探索和修改它们。不属于任何单个项目的杂项示例和源代码清单组织在“listings”仓库中：https://github.com/modern-fortran/listings。我将这些作为活跃项目进行维护，所以如果你发现任何问题或对代码有疑问，请随时在相应的仓库中提出 issue。

虽然所有代码都可以下载，但我建议你在学习本书时手动输入源代码。这样做会让你熟悉 Fortran 的语法，并帮助你形成肌肉记忆。然而，如果你仍然只想下载代码并运行它，当然也可以。如果你熟悉 Git，获取代码最简单的方法是从命令行 `git clone` 每个项目仓库。如果你没有 Git 或不想使用它，只需从仓库页面下载源代码的 zip 压缩包即可。每个项目中的 README 文件会指导你如何构建它。

本书包含许多源代码示例，形式有编号列表、代码片段以及与普通文本内联。在所有情况下，除了代码注释外，源代码都以 `等宽字体` 格式显示，以区别于普通文本。

在许多情况下，原始源代码已被重新格式化；我们添加了换行符并调整了缩进，以适应书中可用的页面空间。此外，当代码在文本中被描述时，源代码中的注释通常会从列表中移除。许多列表附有代码注释，突出了重要的概念。

## 要求 (Requirements)

要学习本书，你需要一台计算机，最好是 Linux 或 macOS。如果你使用 Windows 10，你可能已经可以使用 Windows Subsystem for Linux (WSL)，它提供了一个原生的 Linux 环境，我推荐使用它。如果你使用的是旧版 Windows，我建议在你的系统上设置一个 Linux 虚拟机。Linux 操作系统的优势在于它们是为软件开发而设计的。在写这本书的时候，我使用了 Ubuntu 18.10（桌面）和 Fedora 28（笔记本）。它们都非常适合 Fortran 开发。

你还需要掌握一个带有语法高亮的文本编辑器的使用知识，以便阅读和编写源代码，以及知道如何使用 Linux/UNIX 命令行来编译程序。在文本编辑器方面，我是极简主义者，更喜欢 Vim (Vi IMproved)。如果你喜欢更复杂的编辑器，如 Sublime, Atom, 或 VS Code，这些也可以。毕竟，编辑器只是一个工具。选择一个不影响你实际工作的工具。你将在附录 A 中找到更多关于文本编辑器的信息。

## 参与其中 (Get involved)

如果你喜欢 Fortran，并且这本书激励你做更多事情，可以考虑加入 Fortran 开源社区和/或标准委员会：

*   Fortran 互联网之家: https://fortran-lang.org
*   Fortran GitHub 之家: https://github.com/fortran-lang
*   Fortran 标准库: https://github.com/fortran-lang/stdlib
*   Fortran 包管理器: https://github.com/fortran-lang/fpm
*   Fortran 标准委员会提案: https://github.com/j3-fortran/fortran_proposals
*   美国 Fortran 标准委员会: https://j3-fortran.org
*   国际 Fortran 标准委员会: https://wg5-fortran.org

社区是友好的，对所有怀有善意的新人开放。我们需要帮助——加入我们吧！

## liveBook 讨论论坛 (liveBook discussion forum)

购买《现代 Fortran：构建高效并行应用程序》包括免费访问由 Manning Publications 运营的私人网络论坛，你可以在那里对本书发表评论、提出技术问题，并从作者和其他用户那里获得帮助。要访问论坛，请访问 https://livebook.manning.com/#!/book/modernfortran/discussion。你也可以在 https://livebook.manning.com/#!/discussion 了解更多关于 Manning 论坛和行为规则的信息。

Manning 对读者的承诺是提供一个场所，让个体读者之间以及读者与作者之间能够进行有意义的对话。这并非承诺作者方面会有任何特定程度的参与，作者对论坛的贡献仍然是自愿的（且无偿的）。我们建议你尝试向作者提出一些有挑战性的问题，以免他的兴趣转移！只要本书在版，论坛和过往讨论的存档将可以从出版商的网站访问。

---

# 关于作者 (About the Author)

MILAN CURCIC 是一位气象学家和海洋学家。他在迈阿密大学研究海浪和湍流及其对数值天气和海洋预报的重要性。他还在致力于在可扩展的计算云中实现数值天气预报。自 2006 年以来，他一直是一名 Fortran 程序员，曾与美国海军和 NASA 的团队合作开发和改进地球系统预测模型。他撰写了几个开源 Fortran 库，并与 Fortran 标准委员会合作开发下一个 Fortran 版本及其标准库。

Milan 与他的妻子 Evelyn 和儿子 Nolan 居住在佛罗里达州的博卡拉顿。你可以通过 https://milancurcic.com 了解他的最新动态并与他联系。

xxii (*原文页码*)

---

# 关于封面插图 (About the Cover Illustration)

《现代 Fortran：构建高效并行应用程序》封面上的插图标题为“Ingrienne”，指的是来自芬兰湾南岸历史地理区域 Ingria 的一位女性。该插图取自 Jacques Grasset de Saint-Sauveur (1757–1810) 的各国服饰收藏集，名为 *Costumes Civils Actuels de Tous les Peuples Connus*（《所有已知民族的当代民用服饰》），于 1788 年在法国出版。每幅插图都经过精细绘制和手工上色。Grasset de Saint-Sauveur 收藏的丰富多样性生动地提醒我们，仅仅 200 年前，世界各地的城镇和地区在文化上是多么隔绝。人们彼此隔离，说着不同的方言和语言。在街道或乡村，仅凭衣着就很容易辨认出他们居住的地方以及他们的职业或社会地位。

自那时以来，我们的穿着方式发生了变化，那个时代如此丰富的地域多样性已经消逝。现在很难区分不同大陆的居民，更不用说不同的城镇、地区或国家了。也许我们用文化多样性换来了更加丰富多彩的个人生活——当然，也换来了更加多样化和快节奏的技术生活。

在难以区分一本计算机书籍与另一本的时代，Manning 以两百年前丰富多样的地域生活为基础的书籍封面来庆祝计算机行业的创造性和主动性，这些生活通过 Grasset de Saint-Sauveur 的图画得以复活。

---

# **第一部分 现代 FORTRAN 入门**

在本部分中，你将初步了解 Fortran 并温和地入门这门语言。

在第 1 章中，我们将讨论 Fortran 的设计和特性，以及 Fortran 适合解决哪类问题。你将了解为什么并行编程很重要以及何时应该使用它。

在第 2 章中，我们将构建一个海啸模拟器的最小可行示例，我们将在整本书中不断完善它。这个例子将让你初步了解 Fortran 的基本要素：变量声明、数据类型、数组、循环和分支。

如果你是 Fortran 新手，这里是起点。在本部分结束时，你将能够编写简单而有用的 Fortran 程序。更重要的是，你将准备好更深入地学习 Fortran 的核心要素。

---

# **第 1 章 Fortran 简介**

![插图](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/b9290e14521bd6fc7a7b777c1637017ad289d3f4ba072f7e363cb1d8c208f44c.jpg)

**本章内容包括**

*   什么是 Fortran 以及为什么要学习它？
*   Fortran 的优势和劣势
*   并行思考
*   从头开始构建并行模拟应用

这是一本关于 Fortran 的书，它是历史上最早的高级编程语言之一。它将通过引导你逐步开发一个功能齐全的并行物理模拟应用程序来教你这门语言。注意对**并行**的强调。并行编程允许你将问题分解成小块，让多个处理器各自处理问题的一部分，从而在更短的时间内达到解决方案。读完本书，你将能够识别可以并行化的问题，并使用现代 Fortran 技术来解决它们。

本书并非针对 Fortran 每个特性的全面参考手册——我特意省略了该语言的重要部分。相反，我专注于你在构建实际 Fortran 应用程序时会使用的最实用的特性。随着我们一章一章地开发我们的应用程序，我们将应用现代 Fortran 特性和软件设计技术，使我们的应用程序健壮、可移植、易于使用和扩展。这不仅仅是一本关于 Fortran 的书；这是一本关于使用现代 Fortran 构建健壮、并行软件的书。

## 1.1 什么是 Fortran？

> 我不知道 2000 年的语言会是什么样子，但我知道它会被称为 Fortran。
>
> ——Tony Hoare，1980 年图灵奖得主

Fortran 是一种通用的、并行的编程语言，在科学和工程应用中表现出色。它最初在 1957 年被称为 FORTRAN (FORmula TRANslation，公式翻译)，经过几十年的发展，已成为一种健壮、成熟且面向高性能的编程语言。如今，Fortran 仍然在许多我们习以为常的系统底层运行：

*   数值天气、海洋和海浪预报
*   气候科学与预测
*   机械和土木工程中使用的计算流体力学软件
*   用于设计汽车、飞机和航天器的空气动力学求解器
*   机器学习框架使用的快速线性代数库
*   对世界上最快的超级计算机进行基准测试 (https://top500.org)

这里有一个具体的例子。在我的工作中，我开发天气、海面波浪和深海环流的数值模型。多年来谈论这个工作时，我发现大多数人不知道天气预报是怎么来的。他们以为气象学家会聚在一起，画一张明天、下周或一个月后天气的图表。这只说对了一部分。实际上，我们使用复杂的数值模型，在仓库大小的计算机上处理海量数据。这些模型模拟大气，对未来的天气做出有根据的猜测。气象学家利用这些模型的输出来创建有意义的天气图，如图 1.1 所示。这张图只显示了该模型产生的全部数据的一小部分。像这样的天气预报的输出大小以数百 GB 计算。

最强大的 Fortran 应用程序在数百或数千个 CPU 上并行运行。Fortran 语言及其库的发展很大程度上是由解决物理、工程和生物医学领域极端庞大计算问题的需求驱动的。为了获得比当时最强大的单台计算机所能提供的计算能力还要强大的能力，在 20 世纪末，我们开始用高带宽网络连接许多计算机，让它们各自处理问题的一部分。结果就是超级计算机，一种由数千个商品级 CPU 组成的巨型计算机（图 1.2）。超级计算机类似于谷歌或亚马逊托管的现代服务器集群，不同之处在于超级计算机的网络基础设施旨在最大化服务器之间的带宽并最小化延迟，而不是服务器与外部世界之间的。因此，超级计算机中的 CPU 就像一个巨大的处理器，其分布式内存访问速度几乎与本地内存访问一样快。至今，Fortran 仍然是用于这种大规模并行计算的主要语言。

![图 1.1 2017 年 9 月 10 日飓风 Irma 的预报，由一个用 Fortran 编写的业务天气预报模型计算得出。阴影和风羽表示以米/秒为单位的地表风速，等值线是海平面气压等值线。典型的天气预报是使用数百或数千个 CPU 并行计算的。(数据由 NOAA 国家环境预报中心 [NCEP] 提供)](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/67e0161514c9ca6b375b1ef7cdb774a9cdd72051add7ee38c11e406b8bf6ec82.jpg)
*图 1.1 2017 年 9 月 10 日飓风 Irma 的预报，由一个用 Fortran 编写的业务天气预报模型计算得出。阴影和风羽表示以米/秒为单位的地表风速，等值线是海平面气压等值线。典型的天气预报是使用数百或数千个 CPU 并行计算的。(数据由 NOAA 国家环境预报中心 [NCEP] 提供)*

![图 1.2 巴塞罗那超级计算中心的 MareNostrum 4 超级计算机。该计算机位于西班牙加泰罗尼亚巴塞罗那的 Torre Girona 教堂内。高速网络将所有机柜连接在一起。MareNostrum 4 拥有 153,216 个 Intel Xeon 核心，是西班牙最快的超级计算机，截至 2020 年 6 月，在全球排名第 37 位。(https://www.top500.org/lists/2020/06)。它用于许多科学应用，从天体物理学和材料物理学，到气候和大气尘埃输送预测，再到生物医学。(图片来源: https://www.bsc.es/marenostrum/marenostrum)](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/214c0df9c5227df63b64a39368f723aea7f90fe85b6322fb5e6b4b8510d902dd.jpg)
*图 1.2 巴塞罗那超级计算中心的 MareNostrum 4 超级计算机。该计算机位于西班牙加泰罗尼亚巴塞罗那的 Torre Girona 教堂内。高速网络将所有机柜连接在一起。MareNostrum 4 拥有 153,216 个 Intel Xeon 核心，是西班牙最快的超级计算机，截至 2020 年 6 月，在全球排名第 37 位。(https://www.top500.org/lists/2020/06)。它用于许多科学应用，从天体物理学和材料物理学，到气候和大气尘埃输送预测，再到生物医学。(图片来源: https://www.bsc.es/marenostrum/marenostrum)*

## 1.2 Fortran 的特性

> 这不是你父母那辈的 Fortran。
>
> ——Damian Rouson

在编程语言的背景下，Fortran 具有以下所有特性：

*   **编译型 (Compiled)** — 你需要编写完整的程序，然后将其传递给编译器执行。这与 Python 或 JavaScript 等解释型编程语言不同，后者是逐行解析和执行的。虽然这使得编写程序稍微繁琐一些，但它允许编译器生成高效的可执行代码。在典型用例中，Fortran 程序比等效的 Python 程序快一到两个数量级的情况并不少见。

> **什么是编译器 (Compiler)？**
>
> 编译器是一种计算机程序，它读取用一种编程语言编写的源代码，并将其翻译成另一种编程语言的等效代码。在我们的例子中，Fortran 编译器将读取 Fortran 源代码并生成相应的汇编代码和机器（二进制）指令。

*   **静态类型 (Statically typed)** — 在 Fortran 中，你需要声明所有变量的类型，并且它们将在程序的整个生命周期内保持该类型：
    ```fortran
    ! 声明一个整数变量
    integer :: i
    ! 声明一个浮点数变量
    real :: x
    ! 声明一个复数变量
    complex :: z
    ! 声明一个逻辑变量
    logical :: l
    ! 声明一个字符变量
    character(len=80) :: message
    ```
    你还需要在使用变量之前显式声明它们，这被称为**显式类型 (manifest typing)**。最后，Fortran 采用所谓的**强类型 (strong typing)**，这意味着如果使用错误类型的参数调用过程，编译器将引发错误。虽然静态类型有助于编译器生成高效的程序，但显式类型和强类型强制执行良好的编程习惯，使 Fortran 成为一种安全的语言。我发现编写正确的 Fortran 程序比 Python 或 Javascript 更容易，后者带有许多隐藏的警告和“陷阱”。

*   **多范式 (Multiparadigm)** — 你可以用几种不同的范式或风格编写 Fortran 程序：命令式、过程式、面向对象，甚至函数式。根据你要解决的问题，某些范式比其他范式更合适。我们将在本书中开发代码时探索不同的范式。

*   **并行 (Parallel)** — Fortran 也是一种并行语言。并行性是指将计算问题分解给通过网络通信的进程的能力。并行进程可以在同一处理核心上运行（基于线程的并行），在共享 RAM 的不同核心上运行（共享内存并行），或分布在网络上（分布式内存并行）。协同处理同一并行程序的计算机可以在物理上位于同一机柜中，房间的两端，甚至世界各地。Fortran 的主要并行结构是**协同数组 (coarray)**，它允许你在没有任何外部库的情况下表达并行算法和远程数据交换。协同数组允许你像访问数组元素一样访问远程内存，如下清单所示。

**清单 1.1 并行映像之间的数据交换示例**
```fortran
program parallel_copy
  implicit none
  integer :: this_image, num_images, i
  integer, allocatable, codimension[*] :: x(:) ! 声明一个可分配的整型协同数组

  num_images = num_images() ! 获取映像总数
  this_image = this_image() ! 获取当前映像的索引

  if (this_image == 1) then
    allocate(x(5)[*]) ! 只有映像 1 分配协同数组 x
    ! 初始化数组 x
    do i = 1, size(x)
      x(i) = i
    end do
  end if

  sync all ! 等待所有映像到达此点

  ! 如果当前不是映像 1，从映像 1 获取数据
  if (this_image > 1) then
    ! 调整大小以匹配映像 1 上的数组大小
    allocate(x(size(x[1])))
    x = x[1] ! 从映像 1 复制数组
  end if

  print *, 'Image', this_image, 'received array', x ! 打印当前映像上的数组

end program parallel_copy
```

Fortran 标准并未规定底层如何实现数据交换；它仅指定语法和预期行为。这允许编译器开发人员在任何特定硬件上使用可用的最佳方法。有了强大的编译器和库，Fortran 程序员可以编写在传统 CPU 或通用 GPU 上都能运行的代码。清单 1.1 仅用于说明；但是，如果你想编译并运行它，请在按照附录 A 中的说明设置好 Fortran 开发环境后再进行。

*   **成熟 (Mature)** — 2016 年，我们庆祝了 Fortran 诞生 60 周年。该语言经历了标准的几次修订：
    *   FORTRAN 66，也称为 FORTRAN IV (ANSI, 1966)
    *   FORTRAN 77 (ANSI, 1978)
    *   Fortran 90 (ISO/IEC, 1991; ANSI, 1992)
    *   Fortran 95 (ISO/IEC, 1997)
    *   Fortran 2003 (ISO/IEC, 2004)
    *   Fortran 2008 (ISO/IEC, 2010)
    *   Fortran 2018 (ISO/IEC, 2018)
    Fortran 的开发和在编译器中的实现得到了业界的
    大力支持：IBM、Cray、Intel、NAG、NVIDIA 等。同时也有重要的开源发展，最著名的是免费编译器——gfortran (https://gcc.gnu.org/wiki/GFortran)、Flang (https://github.com/flang-compiler/flang) 和 LFortran (https://lfortran.org)——以及其他社区项目 (https://fortran-lang.org/community)。由于 Fortran 在计算机科学早期的主导地位，今天我们拥有大量健壮且成熟的库，它们是许多应用程序的计算支柱。凭借成熟的编译器和庞大的遗留代码库，Fortran 仍然是许多新软件项目的首选语言，特别是那些计算效率和并行执行至关重要的项目。

*   **易于学习 (Easy to learn)** — 信不信由你，Fortran 相当容易学习。这是我和我许多同事的经验。它易于学习的部分原因在于其严格的类型系统，这使得编译器能够在程序员犯错时在编译时检查并警告他们。虽然语法冗长，但清晰易读。然而，像其他任何编程语言或技能一样，Fortran 难以精通。这也是我选择写这本书的原因之一。

## 1.3 为什么要学习 Fortran？

> 这里有些程序是五千年前编写的，在人类离开地球之前。令人惊奇的是——苏拉说，令人恐惧的是——与堪培拉过去的无用残骸不同，这些程序仍然可以工作！通过百万亿条迂回的继承线索，许多最古老的程序仍然在 Qeng Ho 系统的底层运行。
>
> ——Vernor Vinge, 《天渊》 (A Deepness in the Sky)

自 20 世纪 90 年代初以来，我们见证了新的编程语言和框架的爆炸式增长，这主要是由互联网以及后来的移动设备的广泛使用推动的。C++ 占领了计算机科学系，Java 在企业界备受推崇，JavaScript 重新定义了现代 Web，R 成为统计学家的母语，而 Python 则席卷了机器学习世界。Fortran 在这一切中处于什么位置？通过对语言的稳步修订，Fortran 在其利基领域——高性能计算 (HPC)——保持了稳固的地位。其计算效率仍然无与伦比，只有 C 和 C++ 能与之接近。与 C 和 C++ 不同，Fortran 是为面向数组的计算而设计的，在我看来，学习和编程要容易得多。最近一个支持 Fortran 的有力论据来自于它对并行编程的原生支持。

> **什么是高性能计算 (High-performance computing, HPC)？**
>
> 高性能计算 (HPC) 是指整合计算机资源以解决单个台式计算机无法解决的计算问题的实践。HPC 系统通常聚合数百或数千台服务器，并用高速网络将它们连接起来。如今大多数 HPC 系统运行某种 Linux 操作系统。

尽管是一项有几十年历史的技术，Fortran 仍有几个吸引人的特性，使其即使与更新的语言相比也必不可少：

*   **面向数组 (Array-oriented)** — Fortran 提供整数组算术和操作，极大地简化了逐元素操作。考虑将两个二维数组相乘的任务：
    ```fortran
    do j = 1, jm
      do i = 1, im
        c(i,j) = a(i,j) * b(i,j)
      end do
    end do
    ```
    使用 Fortran 的整数组算术，你只需写：
    ```fortran
    c = a * b
    ```
    这不仅代码更具表现力、更易读，而且还向编译器暗示它可以选择最优的方式来执行该操作。数组非常适合 CPU 架构和计算机内存，因为它们是连续的数字序列，因此反映了内存的物理布局。Fortran 编译器能够生成极其高效的机器代码，这要归功于它们可以安全地做出的假设。
*   **唯一由标准委员会 (ISO) 开发的并行语言** — Fortran 标准委员会确保 Fortran 的发展方向能够支持其目标受众：计算科学家和工程师。
*   **用于科学、工程和数学的成熟库** — Fortran 在 20 世纪 50 年代作为科学、工程和数学的编程语言起步。几十年后，我们拥有了丰富的、健壮且值得信赖的库遗产，用于线性代数、数值微分和积分以及其他数学问题。这些库已被几代程序员使用和测试，以至于可以保证几乎没有错误。
*   **不断增长的通用库生态系统** — 在过去十年中，Fortran 也见证了一个不断增长的通用库生态系统：文本解析和操作、许多数据格式的 I/O 库、处理日期和时间、集合和数据结构等等。任何编程语言的强大程度取决于其库，而不断增长的 Fortran 库数量使其在今天比以往任何时候都更有用。
*   **无与伦比的性能** — 编译后的 Fortran 程序是高级编程语言中最接近硬件的。这既归功于其面向数组的设计，也归功于不断改进优化代码的成熟编译器。如果你正在处理一个对大型数组进行数学运算的问题，很少有其他语言能接近 Fortran 的性能。

总之，如果你需要在大规模多维数组上实现高效并行的数值运算，那么学习 Fortran 是明智的选择。

## 1.4 优点和缺点

Fortran 的许多特性既是优点也是缺点。例如，它具有以下所有特点：

*   **一种领域特定语言 (A domain-specific language)** — 尽管技术上是一种通用语言，但 Fortran 在很大程度上是一种领域特定语言，因为它主要是为科学、工程和数学应用而设计的。如果你的问题涉及对大型结构化数组进行算术运算，Fortran 将大放异彩。但如果你想编写网页浏览器或底层设备驱动程序，Fortran 则不是合适的工具。
*   **一种小众语言 (A niche language)** — Fortran 对相对少数人来说极其重要：特定学科的科学家和工程师。因此，可能很难像查找更主流语言那样找到同样多的 Fortran 教程或博客。
*   **一种静态强类型语言 (A statically and strongly typed language)** — 如前所述，这使得 Fortran 成为一种非常安全的编程语言，并有助于编译器生成高效的可执行文件。但反过来看，它也使得语言不够灵活，更为冗长，因此不是快速原型设计的理想语言。

接下来将 Fortran 与 Python 进行比较，这将帮助你更好地理解它在通用编程背景下的优缺点。

### 1.4.1 与 Python 的并排比较

现代 Fortran 与更新的通用编程语言相比如何？Python 在过去几年中，在数据分析和轻量级数值计算方面拥有增长最快的生态系统 (http://mng.bz/XP71)。许多 Fortran 程序员使用它来进行模型输出的后处理和数据分析。事实上，Python 是我第二喜欢的编程语言。由于 Fortran 和 Python 在应用领域上的重叠，总结两者之间的关键差异很有用，如表 1.1 所示。如果你是一名 Python 程序员，这个总结将让你了解你可以用 Fortran 做什么，以及不能做什么。

**表 1.1 Fortran 与 Python (特指 CPython) 的比较**

| 语言特性             | Fortran                           | Python                                                                 |
| -------------------- | --------------------------------- | ---------------------------------------------------------------------- |
| 首次出现             | 1957                              | 1991                                                                   |
| 最新版本             | Fortran 2018                      | 3.8.5 (2020)                                                           |
| 国际标准             | ISO/IEC                           | 无                                                                     |
| 实现语言             | C, Fortran, 汇编 (依赖编译器)     | C                                                                      |
| 编译型 vs. 解释型    | 编译型                            | 解释型                                                                 |
| 类型规程             | 静态，强类型                      | 动态，强类型                                                           |
| 并行性               | 共享和分布式内存                  | 仅共享内存 (原生), 分布式需库                                          |
| 多维数组             | 是，最多 15 维                    | 仅第三方库 (numpy)                                                     |
| 内置类型             | character, complex, integer, logical, real | bool, bytearray, bytes, complex, dict, ellipsis, float, frozenset, int, list, set, str, tuple |
| 常量                 | 是                                | 否                                                                     |
| 类 (Classes)         | 是                                | 是                                                                     |
| 泛型编程             | 有限                              | 是                                                                     |
| 纯函数 (Pure functions)| 是                                | 否                                                                     |
| 高阶函数             | 有限                              | 是                                                                     |
| 匿名函数             | 否                                | 是                                                                     |
| 与其他语言互操作性   | C (有限)                          | C                                                                      |
| 操作系统接口         | 有限                              | 是                                                                     |
| 异常处理             | 有限                              | 是                                                                     |

从表 1.1 中，Fortran 和 Python 之间的一些关键差异显而易见。首先，Fortran 是编译型和静态类型的，而 Python 是解释型和动态类型的。这使得 Fortran 更加冗长，编程速度较慢，但允许编译器生成快速的二进制代码。这是一把双刃剑：Fortran 不适合快速原型设计，但可以产生健壮高效的程序。其次，Fortran 是一种原生并行编程语言，其语法允许你编写与运行环境（无论是共享内存还是分布式内存计算机）无关的并行代码。相比之下，Python 中的分布式并行编程只能通过外部库实现，并且总体上更难做到。最后，Fortran 是一种更小的语言，专注于对几种不同数值数据类型的大型多维数组进行高效计算。另一方面，Python 内置了更广泛的数据结构、算法和通用工具。

总之，Python 好比一个全面而灵活的工具箱，而 Fortran 则像一个高度专业化的电动工具。因此，Fortran 不适合编写设备驱动程序、视频游戏或网页浏览器。但是，如果你需要解决一个可以分布在多台计算机上的大型数值问题，Fortran 是你的理想语言。

## 1.5 并行 Fortran 图解

我将举例说明 Fortran 真正擅长解决的那类问题。让我们称这个例子为“老拉尔夫农场的夏天结束了”。

农夫拉尔夫有两个儿子和两个女儿，还有一个大农场。夏天快结束了，是时候割草为牛准备干草了。但是牧场很大，老拉尔夫体力不支。然而，他的孩子们年轻力壮。如果他们都努力工作，像一个团队一样，他们可以在一天内完成。他们同意将工作平均分成四份。拉尔夫的每个孩子拿起一把镰刀和一把叉子，前往他们各自负责的牧场区域。他们努力工作，一排排地割草。大约每隔一小时，他们会在边界处碰头，磨快工具，聊聊进展。工作进展顺利，到下午三点左右，几乎所有的草都割完了。临近傍晚，他们把干草打成捆，运到谷仓。老拉尔夫很高兴他有强壮、勤劳的孩子，但更高兴的是他们组成了一个如此出色的团队！通过合作，他们完成的工作量，如果只有一个人干，将需要四倍的时间。

现在你一定在想，老拉尔夫的农场和并行 Fortran 编程有什么关系？关系比表面看起来要多得多！老拉尔夫和他的大牧场是对慢速计算机和大型计算问题的类比。就像拉尔夫让他的孩子们帮他干活一样，在一个典型的并行问题中，我们会将计算域或输入数据分成相等的部分，并将它们分配给 CPU。回想一下他的孩子们是一排排割草的——Fortran 代码中最有效、最具表现力的一些方面就是整数组操作和算术。他们会定期在边界碰头磨工具、聊天。在许多实际应用中，你会指示并行进程交换数据，这对于我将在本书中引导你完成的大多数并行示例来说都是如此。最后，每个并行进程异步地将其数据写入磁盘，就像把干草捆运到谷仓一样。我在图 1.3 中展示了这种模式。

就像农夫拉尔夫一样，Fortran 也很古老。但这绝不是坏事！它是一门成熟、健壮、可靠的语言，不会消失。虽然它确实有一些古老编程语言的怪癖，但它经过了几代计算机科学家和程序员几十年的改进，并在无数性能至关重要的应用中经受了实战检验。使用 Fortran 进行并行编程的简易性是高性能应用的关键，这也是我将其作为本书中心主题的原因。

![图 1.3 并行编程模式：分解问题、交换数据、计算并将结果存储到磁盘](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/2bf28c7395ff5d28f4492b47426b718c346915e9d4ff0d7ac8827dfc25f21425.jpg)
*图 1.3 并行编程模式：分解问题、交换数据、计算并将结果存储到磁盘*

## 1.6 你将在本书中学到什么？

本书将教你如何编写现代、高效、并行的 Fortran 程序。通过逐章学习，我们将从头开始构建一个功能齐全、并行的流体动力学求解器，并将其具体应用于海啸预测。如果你通读本书，你将获得三项独特的技能：

1.  **你将熟练掌握大多数现代 Fortran 特性。** 这在高性能计算 (HPC) 这个价值数十亿美元的稳健市场中是一项独特且受追捧的技能。
2.  **你将能够识别本质上是并行的问题。** 你会优先考虑并行，问题的并行解决方案将变得直观。相反，对并行问题采用串行解决方案将成为一种边缘情况。
3.  **你将掌握良好的软件设计、编写可重用代码以及与在线社区共享你的项目。** 你还将能够在你自己的项目中调整现有的 Fortran 库并回馈社区。这不仅能让你的项目对他人有用，还能在职业和学习机会方面为你打开大门。它对我就是如此！

虽然我不要求你具备 Fortran 先验知识，但我假设你至少在像 Python、R、MATLAB 或 C 这样的语言中有一些编程经验。我们不会详细解释什么是程序、变量、数据类型、源代码或计算机内存，我将假设你对这些概念有所了解。偶尔，我们会涉及微积分的元素，尽管你是否熟悉它并非至关重要。我们还将在终端中进行大量工作（编译和运行程序），所以我假设你至少熟悉命令行导航。无论如何，为了确保清晰，本书中的任何 Fortran 概念都将从头开始教授。

鉴于本书的主题，我预计它对于以下几类受众来说是理想的：

*   物理科学、工程或应用数学专业的本科生和研究生，特别是专注于流体动力学的学生
*   上述领域的教师和研究人员
*   在工业界工作的气象学家、海洋学家和其他流体动力学家
*   希望提升并行编程技能的串行 Fortran 程序员
*   HPC 系统管理员

如果你属于上述类别之一，你可能已经知道 Fortran 的主要卖点在于其为大型超级计算机编写高效并行程序的简易性。这使其一直保持着物理科学和工程领域主导 HPC 语言的地位。虽然本书将从头开始教你 Fortran，但我也会采取非传统的方法，从一开始就在并行编程的背景下进行教学。你将不仅仅是事后学习另一项技术技能，而是学会**并行思考**。你会认识到可以分配工作负载和内存以更有效地获得解决方案的方法。通过并行思考，你将获得两个关键优势：

1.  你将能够**在更短的时间内解决问题**。
2.  你将能够**解决单个计算机无法容纳的问题**。

虽然前者至少是“锦上添花”，但后者至关重要。有些问题根本**无法**在没有并行编程的情况下解决。下一节将为你提供并行编程的温和介绍和示例。

## 1.7 并行思考！

> 十多年来，预言家们一直声称，单一计算机的组织已经达到极限，真正重大的进步只能通过将多台计算机互连以实现协同解决的方式来取得。
>
> —— Daniel Slotnick, ILLIAC IV 首席架构师

并行编程的重要性与日俱增。尽管仍呈正增长，但摩尔定律描述的半导体密度增长率是有限的。传统上，我们通过在单个芯片上放置更多处理核心来突破这一限制。即使是当今大多数智能手机中的处理器也是多核的。在共享内存计算机之外，我们已将许多机器连接成网络，并让它们相互通信以解决巨大的计算问题。你今天早上的天气预报就是在数百或数千个并行处理器上计算出来的。由于摩尔定律的实际限制和当前向多核架构发展的趋势，有一种紧迫感，需要优先教授并行编程。

> **什么是摩尔定律 (Moore's law)？**
>
> 英特尔联合创始人戈登·摩尔在 1965 年注意到 CPU 中的晶体管数量每年翻一番。他后来将这一趋势修正为每两年翻一番。尽管如此，增长率是指数级的，并且与计算机成本的持续下降密切相关。你今天花 1000 美元买的计算机大约是两年前花同样钱买的计算机性能的两倍。
>
> 类似地，当你购买一部新智能手机时，操作系统和应用程序运行流畅快速。两年后会发生什么？随着应用程序更新并因新功能而膨胀，它们需要越来越多的 CPU 功率和内存。由于你手机中的硬件保持不变，最终应用程序会变得非常缓慢。

所有并行问题都分为两类：

1.  **易并行 (Embarrassingly parallel)** ——我指的是“极其容易”——这是件好事！这些问题可以毫不费力地分布在处理器之间（图 1.4，左）。任何在数组 x 上逐元素操作且元素之间无需通信的函数 f(x) 都是易并行的。由于易并行问题的域分解非常简单，现代编译器通常可以自动并行化此类代码。示例包括渲染图形、提供静态网站服务或处理大量独立数据记录。

2.  **非易并行 (Non-embarrassingly parallel)** ——任何进程之间存在相互依赖关系的并行问题都需要通信和同步（图 1.4，右）。大多数偏微分方程求解器都是非易并行的。通信量与计算量的相对比例决定了并行问题能扩展到什么程度。因此，大多数物理求解器的目标是最小化通信并最大化计算。示例包括天气预报、分子动力学以及任何其他由偏微分方程描述的物理过程。这类并行问题更难，在我看来也更有趣！

![图 1.4 易并行问题（左）与非易并行问题（右）。在这两种情况下，CPU 接收输入 (x1, x2) 并处理它以产生输出 (y1, y2)。在易并行问题中，x1 和 x2 可以相互独立地处理。此外，输入和输出数据对于每个 CPU 都是本地内存，用实线箭头表示。在非易并行问题中，输入数据并非总是每个 CPU 的本地内存，必须通过网络分发，用虚线箭头表示。此外，在计算步骤中，CPU 之间可能存在数据相互依赖关系，这需要同步（水平虚线箭头）。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/5102940a35d101c5d6cc43d1c08f59d06fbe4a8875c3509ec1da2e7481ad7f70.jpg)
*图 1.4 易并行问题（左）与非易并行问题（右）。在这两种情况下，CPU 接收输入 (x1, x2) 并处理它以产生输出 (y1, y2)。在易并行问题中，x1 和 x2 可以相互独立地处理。此外，输入和输出数据对于每个 CPU 都是本地内存，用实线箭头表示。在非易并行问题中，输入数据并非总是每个 CPU 的本地内存，必须通过网络分发，用虚线箭头表示。此外，在计算步骤中，CPU 之间可能存在数据相互依赖关系，这需要同步（水平虚线箭头）。*

> **为什么叫易并行 (Embarrassingly parallel)？**
>
> 它指的是过度丰富，就像“富得流油 (embarrassment of riches)”。这是你希望遇到的那种问题。这个术语归功于 Cleve Moler，他是 MATLAB 的发明者，也是 EISPACK 和 LINPACK（用于数值计算的 Fortran 库）的作者之一。LINPACK 至今仍用于对世界上最快的超级计算机进行基准测试。

由于我们的应用领域主要处理非易并行问题，我们将专注于以简洁、表达力强且最小化的方式实现并行数据通信。这将涉及将输入数据分发给处理器（图 1.4 中的向下虚线箭头）以及它们之间的数据通信（图 1.4 中的水平虚线箭头）。

过去的并行 Fortran 编程要么使用 OpenMP 指令（仅适用于共享内存计算机），要么使用消息传递接口 (MPI)（适用于共享和分布式内存计算机）。共享内存 (SM) 和分布式内存 (DM) 系统之间的差异如图 1.5 所示。SM 系统的主要优点是进程间通信延迟非常低。然而，SM 系统中可以拥有的处理核心数量有限。由于 OpenMP 专为 SM 并行编程设计，我们将针对我们的具体示例重点关注 MPI。

![图 1.5 共享内存系统（左）与分布式内存系统（右）。在共享内存系统中，处理器可以访问公共内存 (RAM)。在分布式内存系统中，每个处理器都有自己的内存，它们通过网络交换数据，用虚线表示。分布式内存系统最常见的是由多核共享内存系统组成。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/bd685b2ed0f1ea64e82ebfb3f43801eccc3664b46233972fde215ec871413bf9.jpg)
*图 1.5 共享内存系统（左）与分布式内存系统（右）。在共享内存系统中，处理器可以访问公共内存 (RAM)。在分布式内存系统中，每个处理器都有自己的内存，它们通过网络交换数据，用虚线表示。分布式内存系统最常见的是由多核共享内存系统组成。*

> **OpenMP 与 MPI**
>
> OpenMP 是一组指令，允许程序员向编译器指示要并行化的代码段。大多数 Fortran 编译器都实现了 OpenMP，并且不需要外部库。但是，OpenMP 仅限于共享内存机器。
>
> 消息传递接口 (MPI) 是一个标准化的规范，用于在任意远程进程之间进行可移植的消息传递（复制数据）。这意味着 MPI 可用于单核上的多线程、共享内存机器上的多核处理或跨网络的分布式内存编程。MPI 实现通常为 C、C++ 和 Fortran 提供接口。MPI 常被描述为并行编程的“汇编语言”，这说明了大多数 MPI 操作都是低级别的。

尽管在 HPC 中仍然无处不在，但 OpenMP 和 MPI 是并行计算的特定方法，可以用协同数组 (coarrays) 更优雅地表达。本书将专门使用协同数组进行并行编程。

### 1.7.1 将数组从一个处理器复制到另一个处理器

在大多数科学和工程并行应用中，进程之间存在数据依赖关系。通常，一个二维数组会像棋盘一样被分解成瓦片，每个瓦片的工作负载分配给一个处理器。每个瓦片在内存中拥有自己的数据，这些数据对其处理器来说是本地的。为了说明实际场景中最简单的并行编程情况，让我们以以下气象情况为例。假设数据包含两个变量：风和气温。风从一个温度较低的瓦片（冷瓦片）吹向另一个温度较高的瓦片（暖瓦片）。如果我们要求解温度随时间如何演变，暖瓦片需要知道从冷瓦片随风而来的温度是多少。由于这并非先验可知（记住数据对每个瓦片都是本地的），我们需要将数据从冷瓦片复制到属于暖瓦片的内存中。在最低层级，这是通过显式地将数据从一个处理器复制到另一个处理器来完成的。复制完成后，处理器可以继续进行剩余的计算。将一个或多个值从一个进程复制到另一个进程是并行编程中最常见的操作（图 1.6）。

![图 1.6 两个 CPU 之间远程数组复制的示意图。框内的数字表示初始数组值。我们的目标是将数组的值从 CPU 1 复制到 CPU 2。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/168c646eac8c53712202288111c9987a60be095a5ebf455d539819f41b8daedf.jpg)
*图 1.6 两个 CPU 之间远程数组复制的示意图。框内的数字表示初始数组值。我们的目标是将数组的值从 CPU 1 复制到 CPU 2。*

让我们只关注这一个操作。我们的目标是执行以下操作：

1.  在每个进程上初始化数组——CPU 1 上为 `[1, 2, 3, 4, 5]`，CPU 2 上全为零。
2.  将数组的值从 CPU 1 复制到 CPU 2。
3.  打印 CPU 2 上数组的新值。这些值应该是 `[1, 2, 3, 4, 5]`。

我将向你展示这个问题的两个示例解决方案。一个是使用像 MPI 这样的外部库的传统方法。除非你是一位经验相当丰富的 Fortran 程序员，否则不要试图理解这个示例中的每一个细节。我只是想展示它是多么复杂和冗长。然后，我将向你展示使用协同数组的解决方案。与 MPI 相比，协同数组使用类似数组索引的语法在并行进程之间复制远程数据。

**MPI：传统的并行编程方式**

如前所述，MPI 常被描述为并行编程的“汇编语言”，事实上，这正是其开发者最初的意图。MPI 旨在由编译器开发者实现，以支持原生并行编程语言。然而，在过去的三十年里，应用程序开发者更快地直接在他们的程序中采用了 MPI，并且它已经（无论好坏）成为 Fortran、C 和 C++ 中并行编程的事实标准工具。因此，如今大多数 HPC 应用程序都依赖于低级的 MPI 调用。

以下 Fortran 程序使用 MPI 将数据从一个进程发送到另一个进程。

**清单 1.2 使用 MPI 将数组从一个进程复制到另一个进程**
```fortran
program mpi_copy
  use mpi ! 导入 MPI 模块

  implicit none

  integer :: ierr, proc_id, num_procs, i
  integer :: sender, receiver, tag
  integer :: stat(mpi_status_size) ! MPI 状态数组
  integer, dimension(5) :: array ! 要复制的数组
  integer :: request ! 非阻塞请求句柄

  call mpi_init(ierr) ! 初始化 MPI 环境
  call mpi_comm_rank(mpi_comm_world, proc_id, ierr) ! 获取当前进程 ID
  call mpi_comm_size(mpi_comm_world, num_procs, ierr) ! 获取进程总数

  sender = 0 ! 发送者进程 ID
  receiver = 1 ! 接收者进程 ID
  tag = 1 ! 消息标签

  ! 在每个进程上初始化数组
  if (proc_id == sender) then
    array = [1, 2, 3, 4, 5]
  else if (proc_id == receiver) then
    array = 0
  end if

  print *, 'array on proc ', proc_id, ' before copy:', array

  ! 使用非阻塞发送和接收发送数据
  if (proc_id == sender) then
    ! 发送数据到接收者
    call mpi_isend(array, size(array), mpi_integer, receiver, tag, &
                   mpi_comm_world, request, ierr)
    call mpi_wait(request, stat, ierr) ! 等待发送完成
  else if (proc_id == receiver) then
    ! 从发送者接收数据
    call mpi_irecv(array, size(array), mpi_integer, sender, tag, &
                   mpi_comm_world, request, ierr)
    call mpi_wait(request, stat, ierr) ! 等待接收完成
  end if

  print *, 'array on proc ', proc_id, ' after copy:', array

  call mpi_finalize(ierr) ! 结束 MPI 环境

end program mpi_copy
```

在两个处理器上运行此程序会输出以下内容：

```
 array on proc           0  before copy:           1           2           3           4           5
 array on proc           1  before copy:           0           0           0           0           0
 array on proc           0  after copy:           1           2           3           4           5
 array on proc           1  after copy:           1           2           3           4           5
```

这证实了我们的程序按预期工作：将数组从进程 0 复制到了进程 1。

> **编译和运行示例**
>
> 现在不必担心自己构建和运行这些示例。在下一章开始时，我会要求你设置完整的工作环境，以便处理本书中的示例，包括这个示例。如果你愿意，也可以现在就按照附录 A 中的说明进行操作，而不必等待。

**进入 FORTRAN 协同数组 (COARRAYS)**

协同数组 (Coarrays) 是 Fortran 中用于原生并行编程的主要数据结构。它最初由 Robert Numrich 和 John Reid 在 20 世纪 90 年代作为 Cray Fortran 编译器的扩展开发出来，从 2008 年版本开始被引入标准。顾名思义，协同数组非常像数组，只是它们的元素分布在并行进程（核心或线程）的轴上。因此，它们提供了一种直观的方式来在远程进程之间复制数据。

以下清单显示了我们数组复制示例的协同数组版本。

**清单 1.3 使用协同数组将数组从一个进程复制到另一个进程**
```fortran
program coarray_copy
  implicit none
  integer :: this_image, i
  integer, dimension(5), codimension[*] :: array ! 声明一个整型协同数组

  this_image = this_image() ! 获取当前映像的索引

  ! 在每个映像上初始化数组
  if (this_image == 1) then
    array = [1, 2, 3, 4, 5]
  else
    array = 0
  end if

  print *, 'array on proc ', this_image, ' before copy:', array

  sync all ! 同步所有映像

  ! 映像 2 从映像 1 获取数据
  if (this_image == 2) then
    array = array[1] ! 从映像 1 复制数组
  end if

  sync all ! 再次同步以确保复制完成

  print *, 'array on proc ', this_image, ' after copy:', array

end program coarray_copy
```

该程序的输出与 MPI 变体相同：

```
 array on proc           1  before copy:           1           2           3           4           5
 array on proc           2  before copy:           0           0           0           0           0
 array on proc           1  after copy:           1           2           3           4           5
 array on proc           2  after copy:           1           2           3           4           5
```

因此，这两个程序在语义上是相同的。让我们看看代码中的关键差异：

*   代码行数 (LOC) 从 MPI 示例中的 27 行减少到协同数组示例中的 14 行。这几乎减少了 2 倍。然而，如果我们专门查找与 MPI 相关的样板代码，可以数出 15 行这样的代码。相比之下，与协同数组相关的代码只有两行！由于调试时间大致与 LOC 成正比，我们可以看到协同数组对于开发并行 Fortran 应用程序可能更具成本效益。
*   对于如此简单的操作，MPI 示例中数据复制的核心代码相当冗长：
    ```fortran
    if (proc_id == sender) then
      call mpi_isend(array, size(array), mpi_integer, receiver, tag, &
                     mpi_comm_world, request, ierr)
      call mpi_wait(request, stat, ierr)
    else if (proc_id == receiver) then
      call mpi_irecv(array, size(array), mpi_integer, sender, tag, &
                     mpi_comm_world, request, ierr)
      call mpi_wait(request, stat, ierr)
    end if
    ```
    相比之下，协同数组直观的数组索引和赋值语法：
    ```fortran
    if (this_image == 2) then
      array = array[1]
    end if
    ```
*   最后，MPI 需要使用 `mpi_init()` 和 `mpi_finalize()` 子例程进行初始化和终结。协同数组则不需要这样的代码。这是一个微小但受欢迎的改进。

> **并行进程索引**
>
> 你注意到在 MPI 示例中我们的并行进程索引是 0 和 1，而在协同数组示例中是 1 和 2 吗？MPI 是用 C 实现的，C 语言的数组索引从 0 开始。相比之下，协同数组映像 (images) 默认从 1 开始。

正如我们在本例中看到的，MPI 和协同数组都可以有效地用于在并行进程之间复制数据。然而，MPI 代码是低级的、冗长的，并且随着应用程序规模和复杂性的增长，很快就会变得乏味且容易出错。协同数组提供了类似于数组操作的直观语法。此外，使用 MPI 时，你告诉编译器*要做什么*；使用协同数组时，你告诉编译器你*想要什么*，并让它决定如何最好地去做。这减轻了你肩上的重大责任，让你能够专注于你的应用程序。我希望这能说服你，Fortran 协同数组是在并行进程之间进行富有表现力且直观的数据复制的方式。

> **分区全局地址空间 (PGAS) 语言**
>
> Fortran 是一种分区全局地址空间 (Partitioned Global Address Space, PGAS) 语言。简而言之，PGAS 抽象了分布式内存空间，并允许你执行以下操作：
>
> *   **将内存布局视为共享内存空间** — 这将在设计并行算法时极大地提高你的生产力和编程便利性。执行数据复制时，你无需将数组索引从一个映像转换到另一个映像。属于远程映像的内存将表现得像本地内存一样，你将能够以这种方式表达你的算法。
> *   **利用引用局部性 (locality of reference)** — 你可以设计和编码你的并行算法，而无需预先考虑内存的某个子部分是否是当前映像的本地内存。如果是，编译器将利用该信息发挥优势。如果不是，则将执行可用的最高效的数据复制模式。
>
> PGAS 允许你使用一个映像来启动两个远程映像之间的数据复制：
> ```fortran
> if (this_image() == 1) array(:)[7] = array(:)[8]
> ```
> `if` 语句确保赋值仅在映像 1 上执行。然而，方括号内的索引指向映像 7 和 8。因此，映像 1 将异步请求将数组从映像 8 复制到映像 7。从我们的角度来看，方括号内的索引可以像内存中本地的任何其他数组元素一样对待。实际上，这些映像可以映射到同一共享内存计算机上的不同核心，跨越服务器机房，甚至遍布全球。

## 1.8 运行示例：并行海啸模拟器

学习是通过实践而非阅读发生的，尤其是当我们沉浸在一个较长的项目中时。因此，本书的课程围绕着开发你自己的、最小但完整的海啸模拟器展开。

### 1.8.1 为什么是海啸模拟器？

海啸是由大型水体（如海洋）中的位移引发的一系列长水波。这通常由地震、水下火山爆发或滑坡引起。一旦生成，海啸会沿径向向外传播穿过海洋表面。当它进入浅水区时，其高度和陡峭度会增加。海啸模拟器是本书的一个很好的运行示例，因为海啸具有以下特点：

*   **有趣** — 纯粹从科学家的角度来说！海啸是一个在数值沙盒中观看和玩耍都很有趣的过程。
*   **危险** — 海啸对低洼且人口稠密的沿海地区构成巨大威胁。有必要更好地理解和预测它们。
*   **数学简单** — 可以使用一组最小的方程——浅水方程 (Shallow Water Equations, SWEs)——来模拟它们。这将帮助我们不被数学细节所困扰，而专注于实现。
*   **可并行化** — 它们涉及一个适合教授并行编程的物理过程，特别是考虑到它是一个非易并行问题。为了使其工作，我们需要仔细设计映像之间的数据复制模式。

为了模拟海啸，我们将编写一个浅水方程组的求解器。

### 1.8.2 浅水方程

浅水方程 (SWEs) 是从纳维-斯托克斯方程 (Navier-Stokes equations) 推导出来的一个简单方程组。它们也称为圣维南方程 (Saint-Venant equations)，以法国工程师和数学家 A. J. C. Barre de Saint-Venant 的名字命名，他在研究水力工程和明渠流时推导了这些方程。SWEs 功能强大，因为它们可以重现大气和海洋中许多观测到的运动：

*   大尺度天气，如气旋和反气旋
*   西边界流，如大西洋的墨西哥湾流和太平洋的黑潮
*   长重力波，如海啸和潮涌
*   陆地上的降雨和融雪形成的流域
*   风生（冲浪）波
*   池塘中的涟漪

该系统仅由几个项组成，如图 1.7 所示。

![图 1.7 浅水方程。顶部方程是动量（速度）守恒定律，底部是质量（水位）守恒定律。u 是二维速度矢量，g 是重力加速度，h 是水面高程，H 是未扰动的水深，t 是时间。“Nabla”符号（倒三角）是矢量微分算子。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/c4f72f5ba5ed291d84147c9c18795b809aca96e557837cd4f2e488e61380148c.jpg)
*图 1.7 浅水方程。顶部方程是动量（速度）守恒定律，底部是质量（水位）守恒定律。u 是二维速度矢量，g 是重力加速度，h 是水面高程，H 是未扰动的水深，t 是时间。“Nabla”符号（倒三角）是矢量微分算子。*

这个系统的物理意义是什么？顶部方程表明，在水面存在坡度的地方，由于压力梯度的作用，水会加速并向水位较低的区域移动。平流项是非线性的，会导致流体中的混沌行为（湍流）。底部方程表明，在存在辐合（水汇聚）的地方，水位会升高。这是因为水必须有去处，这也是我们称之为质量守恒的原因。类似地，如果水在辐散，其水位会相应降低。

> **对数学感到舒适？**
>
> 如果你熟悉微积分和偏微分方程，太好了！附录 B 中有更多内容等着你。否则，别担心！本书不会过多涉及数学；它将专注于编程。

浅水方程对我来说很亲切，因为我第一次学习 Fortran 编程就是在贝尔格莱德大学的气象学本科课程中通过模拟这些方程。在某种程度上，写这本书让我回到了我的根源。尽管我现在的 Fortran 代码看起来（和工作方式）与那时大不相同，但我仍然认为这个例子是教授并行 Fortran 编程的理想案例研究。我希望你和我一样享受这个过程。

### 1.8.3 我们希望我们的应用做什么

让我们明确一下我们海啸模拟器的规格：

*   **并行** — 该模型将仅使用纯 Fortran 代码扩展到数百个处理器。这不仅对于加快程序速度和减少计算时间很重要，而且对于实现否则无法容纳在单台计算机内存中的非常大的模拟也至关重要。由于大多数现代笔记本电脑至少有四个核心，你应该能够享受到你（并行编程）劳动的成果。
*   **可扩展** — 物理项可以很容易地制定并添加到求解器中。这对于模型的通用可用性很重要。如果我们能以可重用类和函数的形式设计我们的计算核心，我们就能像 Damian Rouson (http://mng.bz/vxPq) 的方法那样，轻松地将新的物理项添加为功能性的、并行的运算符。这样，技术实现被抽象在这些函数内部，而在高层级，我们编写方程就像在黑板上写一样。
*   **软件库** — 这将提供一组可重用的类和函数，可用于构建其他并行模型。
*   **文档化** — 所有软件都应该是有用的，任何用户都不应该猜测程序作者的意图。我们将以易于阅读和理解的方式编写和记录我们的应用程序。
*   **在线可发现** — 仅仅为自己编写程序对于学习和探索来说很棒。然而，当你能与他人分享软件以解决他们的问题时，软件才真正变得有用。本书中开发的海啸模拟器和其他项目都在 GitHub 上：https://github.com/modern-fortran。请随意探索它们并四处看看，我们将在本书的学习过程中一起深入细节。

通过逐章学习本书，你将获得从头开始开发功能齐全的并行应用程序的经验。如果这是你的第一个软件项目，我希望它能激发你内心的软件开发者，并激励你自己去创造一些东西。我们将在下一章开始时设置开发环境，以便你可以编译和运行海啸模拟器的最小可行版本。

> **可视化海啸输出**
>
> 在我们构建和运行模拟器时，我们主要会查看它记录到终端的原始数字和时间步计数。然而，能够可视化模型的输出既有帮助又令人满意。每当我们向模拟器添加新部分，使解决方案变得不同且更有趣时，我们都会这样做。我在项目的 GitHub 仓库中提供了 Python 脚本，以便你可以自己可视化输出。虽然可以直接从 Fortran 创建高质量的图形，但这不像使用 Python 那样容易。

## 1.9 进一步阅读

*   Fortran 网站: https://fortran-lang.org
*   维基百科上关于 Fortran 的历史: https://en.wikipedia.org/wiki/Fortran
*   分区全局地址空间 (PGAS): http://mng.bz/4A6g
*   本书配套博客: https://medium.com/modern-fortran

# 总结

*   Fortran 是至今仍在使用的最古老的高级编程语言。
*   它是科学和工程许多应用领域的主导语言。
*   Fortran 不适合编写视频游戏或网页浏览器，但在大型多维数组上的数值、并行计算方面表现出色。
*   它是唯一标准化的原生并行编程语言。
*   与传统的 MPI 编程相比，协同数组 (Coarrays) 为并行数据交换提供了更清晰、更具表现力的语法。
*   Fortran 编译器和库是成熟且经过实战检验的。

---

# **第 2 章 入门：最小可行应用**

**本章内容包括**

*   编译并运行你的第一个 Fortran 程序
*   数据类型、声明、算术和控制流
*   构建并运行你的第一个模拟应用

在本章中，我们将实现海啸模拟器的最小可行版本。为简单起见，我们将首先模拟水体在背景流作用下在空间中的运动，而不改变其形状。这个问题足够复杂，足以介绍 Fortran 的基本元素：数值数据类型、声明、算术表达式和赋值，以及控制流。一旦我们在本章成功模拟了物体的运动，我们将在第 3 章和第 4 章中重构代码以添加其他物理过程，这将使模拟的水流更真实。实现其他过程会更容易，因为我们将能够重用本章编写的大部分代码。

我们将从编译、链接和运行你的第一个 Fortran 程序开始。然后，我将介绍我们想要解决的物理问题，并向你展示如何将其表达为计算机程序的形式。接着，我们将深入探讨 Fortran 的基本元素：数据类型、声明、算术和控制流。在本章结束时，你将具备编写基本但有用的 Fortran 程序的实践知识。

## 2.1 编译并运行你的第一个程序

让我们从创建、编译和运行你的第一个 Fortran 程序开始。我假设你已经在系统上安装了 GNU Fortran 编译器 (gfortran)。如果还没有，请按照附录 A 中的说明进行设置。

安装好编译器后，通过编译并运行你的第一个 Fortran 程序来测试它，如下清单所示。

**清单 2.1 你的第一个 Fortran 程序：hello.f90**
```fortran
program hello
  implicit none
  print *, 'Hello, Modern Fortran!' ! 打印问候语到终端
end program hello
```

这个程序只做一件事——向终端打印一条简短的问候消息——这是大多数编程书籍中第一个例子的常见做法。让我们将其保存在名为 `hello.f90` 的文件中。编译非常简单，只需将源文件传递给编译器，并可选地指定输出 (`-o`) 可执行文件的名称：

```bash
gfortran hello.f90 -o hello
```

如果你不使用 `-o` 指定输出文件的名称，可执行文件的名称默认为 `a.out`。

运行该程序会产生预期的输出：

```
 Hello, Modern Fortran!
```

就这样——你编写并编译了你的第一个 Fortran 程序！让我们看看底层发生了什么。构建一个程序通常涉及两个步骤：

1.  **编译 (Compiling)** — 编译器解析高级语言（这里是 Fortran）的源代码，并输出一组相应的机器指令。在我们的例子中，`gfortran` 将读取带有 `.f90` 后缀的 Fortran 源文件，并输出一个带有 `.o` 后缀的相应二进制目标文件。其他源文件后缀，如 `.f`、`.f03` 或 `.f08`，大多数编译器也接受；但是，为了保持一致性，我建议坚持使用 `.f90`。
2.  **链接 (Linking)** — 二进制目标文件 (`.o`)，即编译步骤的结果，本身是不可执行的。链接器，通常由编译器在底层调用，将二进制目标文件组合成一个或多个可执行程序。

为了构建我们的第一个程序，我们只发出了一条命令 `gfortran hello.f90 -o hello`，这意味着编译和链接没有分成两个独立的步骤。当整个程序包含在单个文件中时，这样做就足够了，编译和链接步骤合并在一个命令中。该命令等效于以下清单。

**清单 2.2 编译和链接作为独立步骤**
```bash
# 仅编译 hello.f90，生成 hello.o
gfortran -c hello.f90
# 将 hello.o 链接成可执行文件 hello
gfortran hello.o -o hello
```

在这个片段中，编译器选项 `-c` 表示**仅编译，不链接**。每当我们需要在将多个源文件链接成单个程序之前编译它们时，此过程是必需的。随着你的应用程序或库规模的增长，你会发现将其拆分成多个文件将使其更易于组织和进一步开发。

我在图 2.1 中说明了构建顺序。

![图 2.1 编译和链接步骤，接收输入源代码并生成二进制目标文件和可执行文件。源文件 hello.f90 被传递给编译器，编译器输出二进制目标文件 hello.o。然后目标文件被传递给链接器，链接器输出二进制可执行文件 hello。链接器隐式包含在编译器命令 (gfortran) 中。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/01f952eba6a231384a34952d85955a203c6582798894d3795982e1e4ac4ec5df.jpg)
*图 2.1 编译和链接步骤，接收输入源代码并生成二进制目标文件和可执行文件。源文件 hello.f90 被传递给编译器，编译器输出二进制目标文件 hello.o。然后目标文件被传递给链接器，链接器输出二进制可执行文件 hello。链接器隐式包含在编译器命令 (gfortran) 中。*

GNU Fortran 编译器可以接受许多其他选项，用于控制语言规则、警告消息、优化和调试。我鼓励你继续浏览手册。你可以通过在命令行输入 `man gfortran` 来访问它。如果你的系统上没有手册页，你总是可以在 https://gcc.gnu.org/onlinedocs/gfortran 访问 gfortran 的最新文档。

## 2.2 模拟物体的运动

在上一章末尾，我介绍了浅水方程系统，我们将在本书的整个过程中致力于求解它，以产生逼真的海啸模拟。在这里，我们将从头开始实现模拟器，无论是源代码方面还是我们将用它模拟的物理过程方面。我们将模拟的第一个过程是物体由于背景流而发生的运动。在物理学中，我们称之为**线性平流 (linear advection)**。平流意味着通过空间的运动，而线性属性意味着背景流与物体的形状和位置无关。别担心，如果你不是数学或物理高手并且这听起来令人生畏！在接下来的小节中，我将说明平流是如何工作的，并向你展示如何在不必理解其背后所有数学知识的情况下进行计算。

> **从微积分到代码**
>
> 如果你想深入了解这个问题背后的数学知识，请前往附录 B。在那里，我解释了梯度（平流背后的关键概念），以及如何使用有限差分在计算机代码中表达它。这一步很重要，因为它构成了表达浅水方程中所有其他项的基础。否则，如果你想跳过数学直接进入编程，请继续！

在下一小节中，我将陈述问题并为我们的应用程序设定一些要求。然后，我将通过一个平流的说明性示例引导你，并向你展示如何在不编写任何代码的情况下自己计算它。最后，在本章的剩余部分，我们将一起努力实现我们应用程序的第一个版本。

### 2.2.1 我们的应用应该做什么？

在这个阶段，我们将只模拟物体（或流体）由于背景流而发生的运动。这将为我们将在后续章节中添加到求解器的其他物理过程提供基础。现在只模拟一个过程将指导我们程序结构及其元素的设计：数据的声明和初始化、将模拟向前迭代推进时间，以及将结果写入终端。我绘制了我们期望的结果草图，如图 2.2 所示。

![图 2.2 将物体在空间中从左向右平流。左侧是初始状态。物体被背景流从左向右平流，经过一段时间后到达右侧的最终位置。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/afa9bc39a73e21be5265c7f7451a029f8d05226ce437d658908d3fd21f306397.jpg)
*图 2.2 将物体在空间中从左向右平流。左侧是初始状态。物体被背景流从左向右平流，经过一段时间后到达右侧的最终位置。*

注意，被平流的物体可以是任何量，例如水高、温度或污染物的浓度。现在，为了简单起见，我们仅将其称为“物体”。物体的形状也是任意的——它可以是任何连续或不连续的函数。为了方便，我选择了一个平滑的凸起。在初始时刻，物体位于域的左边缘附近。我们的目标是模拟物体由于背景流而发生的运动，并记录物体在某个未来时间的状态。在内部，我们的应用程序需要执行以下步骤：

1.  **初始化 (Initialize)** — 定义将在计算机内存中保存物体状态的数据结构，并初始化其值。
2.  **模拟 (Simulate)** — 此步骤将计算物体的位置随时间如何变化。在这个阶段，我们只期望它从左向右移动，形状不变。模拟是在许多离散的时间步长上完成的，并占据了程序花费的大部分计算时间。
3.  **输出 (Output)** — 在每个时间步，我们将记录物体的状态，以便我们可以使用外部程序将其可视化。

正如你可以猜到的，我们程序的核心将围绕模拟步骤展开。我们如何模拟物体的运动？在编写任何代码之前，我们需要了解平流是如何工作的。

### 2.2.2 什么是平流？

维基百科将平流定义为“物质或量通过整体运动进行的输运”。平流是物理学、工程学和地球科学中的一个基本过程。它决定了固体物体或流体由于背景流而在空间中如何移动。当游泳者逆流游泳时，他们会被水流平流，他们相对于地面的速度会低于没有水流时的速度。平流也是为什么我们在加勒比海、巴西或北欧上空的大气中发现撒哈拉沙漠的尘埃，或者为什么垃圾带汇聚在海洋盆地中心的原因。

我之前提到，在本章中我们只处理线性平流。这里的“线性”一词意味着可以假设背景流是恒定的，并且不会因为与被平流物体本身的相互作用而改变。如图 2.2 所示，物体以恒定速度移动，该速度与物体本身无关。换句话说，物体的形状和位置不影响背景流。然而，在现实世界中，这几乎从未发生！速度的非线性平流是产生湍流的原因。溪流中的小漩涡、商业航班上偶尔的颠簸，以及我们在木星大气照片中看到的纹理，都是由不同空间尺度上的非线性平流引起的湍流示例。我们将把非线性平流留到第 4 章；这里，我们只关注线性部分。

为了更好地理解平流是如何工作的，考虑一个冷锋移动穿过美国东南部（图 2.3）。冷锋是与中纬度气旋相关的大尺度天气现象。在北半球，它通常从西北向东南移动（在南半球则从西南向东北移动），并在其后带来凉爽干燥的空气。在我居住的南佛罗里达，人们热切期待冷锋的到来，因为它们会带来来自北方的清爽凉爽干燥的空气。

![图 2.3 从亚特兰大向迈阿密移动的冷锋示意图。曲线是等温线。虚线箭头显示锋面传播方向。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/3b990c01ee893bd271c1c9acddc883432277ed703a506b51f98abafea14b20ba.jpg)
*图 2.3 从亚特兰大向迈阿密移动的冷锋示意图。曲线是等温线。虚线箭头显示锋面传播方向。*

现在我有一个小练习给你。考虑以下情况：

*   亚特兰大的温度是 12°C，迈阿密是 24°C。
*   亚特兰大和迈阿密之间的距离是 960 公里。
*   锋面正以 20 公里/小时 (km/h) 的恒定速度向迈阿密移动。

假设没有其他过程在起作用，并且温度的变化在空间上是均匀的：

1.  亚特兰大和迈阿密之间的**温度梯度**是多少？梯度是某个量（这里是温度）在两个位置之间的差异，除以它们之间的距离。在这种情况下，温度梯度的单位是 °C/km。
2.  迈阿密的温度降至 12°C 需要多少**小时**？
3.  最后，24 小时后迈阿密的**温度**将是多少？你是如何得出这个结果的？

尝试用笔和纸解决这个问题。完成这个练习后，你就求解了线性平流方程，即使你没有意识到这一点。平流方程预测任何量由于该量的空间梯度和背景流而发生的变化。我们将进行完全相同的计算来预测我们模拟器中物体的运动。你可以在本章末尾附近的“答案解析”部分找到这个练习的解答。

## 2.3 实现最小可行应用

设定了要解决的问题后，我们很快就能投入 Fortran 编码了。但首先，我们将在下一小节回顾实现策略（你总是应该有一个策略）。然后，我们将回顾该语言的核心元素，并应用它们来实现海啸模拟器的第一个版本。

### 2.3.1 实现策略

在我们进行任何编码之前，勾勒出我们实现应用程序第一个版本的初步策略会很有帮助：

1.  **定义主程序 (main program)**。这将定义程序名称和范围。主程序单元提供了一个骨架，用于容纳数据声明和可执行代码，如算术运算、循环等。
2.  **声明和初始化变量和常量**。我们需要声明我们打算在程序中使用的所有变量和常量：
    *   整数计数器 `i` 和 `n`，分别用于空间和时间，以及相应的循环维度 `grid_size` 和 `num_time_steps`。空间维度大小 `grid_size` 将决定数组的长度，而时间维度大小 `num_time_steps` 将决定我们计算解的迭代次数。
    *   物理常量，用于背景流速 `c`、时间步长 `dt` 和网格间距 `dx`。
    *   包含水高值的实数数组 `h`，以及其有限差分 `dh`，使得对于每个 `i`，`dh(i) = h(i) - h(i-1)`。数组 `dh` 对于在不将多个时间层级保留在内存中的情况下计算解是必需的。
3.  **计算方程解达到设定的时间步数**。此步骤包括三个不同部分：
    *   循环达到设定的时间步数 (`num_time_steps`)。
    *   在每个步骤中，根据上一个时间步的值计算水高 `h` 的新值。
    *   由于我们的域大小有限 (`grid_size`)，我们需要定义**边界条件**。当物体到达域的最右边缘时会发生什么（图 2.4）？

    ![图 2.4 边界条件决定了当物体到达域边缘时会发生什么。它应该直接离开吗？像球撞墙一样反射回域内？或者循环并从左侧重新出现？](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/db6b96f92302cbe544ca48534a412b206eb39d8a0f5e025da6221a8469a553b4.jpg)
    *当物体离开域时会发生什么？*
    *图 2.4 边界条件决定了当物体到达域边缘时会发生什么。它应该直接离开吗？像球撞墙一样反射回域内？或者循环并从左侧重新出现？*

    这里我们有几个选择。物体可能被边界吸收并完全离开域而不留痕迹，或者它可能像球撞墙一样被反射回域内。另一个选择是**周期性（或循环）边界条件**，它连接域的右边缘和左边缘。在这种情况下，物体会从右侧穿过并在左侧重新出现。这是全球大气和海洋预测中常见的选择，因为我们的行星在计算域中就是这样表示的。如果你一直向东走足够远，你最终会到达西方！因此，我们将在我们的应用程序中实现周期性边界条件。
4.  **在每一步将解打印到终端**。开始时，我们不需要花哨或特殊格式的输出。让我们只以默认文本格式将我们的解输出到屏幕。如果我们想将输出存储在文件中以供分析或绘图，我们可以轻松地将输出重定向到文件。

听起来不错？让我们开始，逐一解决这些问题。

### 2.3.2 定义主程序

主程序 (main program) 是 Fortran 中的基本程序单元。它允许你为程序指定一个名称并定义程序范围，如下清单所示。

**清单 2.3 定义程序单元和范围**
```fortran
program tsunami  ! 定义程序名称
  ! 程序代码（声明和可执行语句）将放在这里
end program tsunami ! 结束程序定义
```

为程序指定名称在实践中并没有什么作用，但当你开始处理数十个不同的程序时，它可以帮助你保持组织性。

编译和链接主程序源文件会生成一个可执行文件，你可以从宿主操作系统调用该文件（参见图 2.1）。你不能从其他程序单元调用主程序。

> **还有哪些其他程序单元？**
>
> 这里，我让你先睹为快第 3 章和第 4 章的内容。不同的程序单元可以一起组成一个可执行程序或一个不可执行的库：
>
> *   **主程序 (Main program)** — 顶层单元，只能从操作系统调用。
> *   **函数 (Function)** — 一种可执行子程序，从表达式中调用，并且总是返回单个结果。
> *   **子例程 (Subroutine)** — 一种可执行子程序，可以就地修改多个参数，但不能在表达式中使用。
> *   **模块 (Module)** — 变量、函数和子例程定义的非可执行集合。
> *   **子模块 (Submodule)** — 扩展现有模块，用于定义只有该模块才能访问的变量和过程定义；对于更复杂的应用程序和库很有用。
>
> 目前，我们可以只使用主程序。我们将在第 3 章深入探讨函数和子例程，在第 4 章深入探讨模块。

`program` 语句不是强制性的。对于简短的测试程序，省略它可能很有用。然而，包含它并与匹配的 `end program` 语句配对是良好的实践。严格来说，`end` 是任何 Fortran 程序唯一必需的语句。该语句也构成了可能的最短但无用的 Fortran 程序。

> **提示**：始终将 `program` 语句与匹配的 `end program` 语句配对。

### 2.3.3 声明和初始化变量

> Explicit is better than implicit. (显式优于隐式。)
>
> —— Tim Peters，《Python 之禅》

任何程序单元的第一部分是**声明部分 (declaration section)**。Fortran 采用**静态 (static)、显式 (manifest)、强类型 (strong typing)** 系统：

*   **静态** — 每个变量在编译时都有一个数据类型，并且该类型在程序的整个生命周期内保持不变。
*   **显式** — 所有变量必须在使用前在声明部分显式声明。一个例外和需要注意的是隐式类型，在侧边栏中有描述。
*   **强** — 当变量在程序与函数或子例程之间传递时，它们必须是类型兼容的。

> **隐式类型 (Implicit typing)**
>
> Fortran 有一个历史特性叫做隐式类型，它允许编译器根据变量的第一个字母推断变量类型。是的，你没看错。
>
> 隐式类型源于 Fortran 的早期（咳咳，FORTRAN），那时类型声明尚未引入该语言。任何以 I, J, K, L, M, 或 N 开头的变量都是整数 (integer)，否则是实数 (real，即浮点数)。FORTRAN 66 引入了数据类型，而 FORTRAN 77 引入了 `IMPLICIT` 语句来覆盖默认的隐式类型规则。直到 Fortran 90，该语言才允许通过在声明之前使用语句 `implicit none` 来完全禁用隐式类型行为。
>
> `implicit none` 语句将指示编译器，如果你尝试使用未声明的变量，则报告错误。**始终使用 `implicit none`！**

**内部 (Intrinsic) 类型**由语言标准定义，可立即可用。Fortran 有三种数值类型：

*   `integer` — 整数，例如 `42` 或 `-17`
*   `real` — 浮点数，例如 `3.141` 或 `1.82e4`
*   `complex` — 一对数字：一个用于复数的实部，一个用于虚部；例如 `(0.12, -1.33)`

数值类型也有不同的**种类 (kinds)**。Fortran 的种类指的是为变量保留的内存大小。它决定了允许的值范围，对于实数和复数，还决定了精度。通常，较高的整数种类允许更宽的值范围。较高的实数和复数种类产生更高的允许范围和更高的值精度。你将在第 4 章学习更多关于数值类型种类的知识。

除了数值内部类型，Fortran 还有用于表示布尔（真或假）状态的 `logical` 类型和用于文本数据的 `character` 类型。这五种内部类型（`integer`, `real`, `complex`, `logical`, 和 `character`）是 Fortran 程序中所有变量的基础。你还可以使用它们来创建任意复杂度的复合类型，称为**派生类型 (derived types)**，类似于 C 中的 `struct` 和 Python 中的 `class`。我们将在第 8 章深入探讨派生类型。

> **提示**：始终使用 `implicit none`。该语句强制对所有变量进行显式声明，这既为程序员提供了文档，也允许编译器为你查找并报告类型错误。

### 2.3.4 数值数据类型

Fortran 开箱即用地提供了三种数值数据类型：`integer`, `real`, 和 `complex`。

**整数 (INTEGER)**

整数是 Fortran 中最简单的数值类型。以下是一些整数字面量的例子：

```
0 1 42 100 -500 +1234567
```

你可以像这样声明一个或多个整数：

```fortran
integer :: i, n
```

该语句指示编译器为整数变量 `i` 和 `n` 在内存中保留空间。它由左侧的类型语句 (`integer`)、中间的双冒号 (`::`) 以及由逗号分隔的变量列表组成。

整数的一般规则：

*   整数总是有符号的——它们可以是负数、正数或零。
*   它们有一个由其类型种类决定的有限范围。较大的类型种类导致更宽的范围。

超出变量允许的范围会导致**溢出 (overflow)**。在这种情况下，变量的值将环绕其范围限制。默认整数在内存中的大小并未由 Fortran 标准定义，并且依赖于系统。然而，在大多数系统上，默认整数大小为 4 字节。

**实数 (REAL)**

实数，也称为浮点数，描述了在连续（非离散）轴上具有值的任何数字。以下是一些实数的例子：

```
0.0 1.000 42. 3.14159256 -5e2 +1.234567e5
```

前四个很直观——小数点分隔左侧的整数部分和右侧的小数部分。最后两个可能看起来奇怪，因为它们是用指数表示法编写的。它们由字符 `e` 左侧的一个整数或实数，以及其右侧表示十进制指数的一个整数组成。因此，`-5e2` 对应于 $-5 \times 10^2$，而 `+1.234567e5` 对应于 $1.234567 \times 10^5$。对于正数，一元加号是可选的。我们将在第 6 章更多地讨论格式化实数。

> **注意小数点！**
>
> 编写字面常量时，编译器将其理解为整数还是实数之间有一条细微的界线。数字后面的一个句点就能产生区别。例如，`42` 是整数，但 `42.` 是实数。这与 C 或 Python 中的行为相同。

我们使用关键字 `real` 来声明实数：

```fortran
real :: x
```

这个声明语句类似于整数的声明语句，只是类型和变量名不同。

**复数 (COMPLEX)**

复数只是**一对实数**，一个用于实部，一个用于虚部。它们的声明和初始化方式如下：

```fortran
complex :: c = (1.1, 0.8)
```

引入 `complex` 内部类型到 Fortran 是为了使复数算术更容易编程。根据你的应用，你要么会经常使用它们，要么根本不会使用。

### 2.3.5 声明应用中要使用的数据

现在你对如何声明特定数值类型的变量有了概念，让我们声明一些我们将在海啸模拟器中使用的变量、常量和数组。

**声明变量**

我们需要哪些类型的变量？提醒一下，根据我们在 2.3.1 节中的实现策略，我们需要以下内容：

*   空间数组大小 `grid_size` 和时间步数 `num_time_steps`
*   物理常量，如时间步长 `dt`、网格大小 `dx` 和背景流速 `c`
*   用于承载水高值 `h` 及其空间差分 `dh` 的一维数组
*   一个整数索引 `i`，用于引用单个数组元素 `h(i)`，以及另一个用于时间循环的 `n`

由于我们需要在声明数组 `h` 之前先指定 `grid_size`，让我们先声明标量变量和常量，然后再声明数组，如下清单所示。

```fortran
program tsunami
  implicit none

  integer :: grid_size ! 网格点数
  integer :: num_time_steps ! 时间步数
  real :: dt ! 时间步长 (秒)
  real :: dx ! 网格间距 (米)
  real :: c ! 背景流速 (米/秒)
  integer :: i, n ! 循环计数器

  ! 设置参数
  grid_size = 100
  num_time_steps = 100
  dt = 1.0
  dx = 1.0
  c = 1.0

  ! 此处将声明数组

end program tsunami
```
*清单 2.4 声明和初始化整数和实数变量*

声明部分以 `implicit none` 开始，并在第一个可执行代码行 (`grid_size = 100`) 之前立即结束。所有声明都在一个地方完成，即程序的开头。

> **注释代码**
>
> Fortran 注释以感叹号 (`!`) 开始。它们可以从行首开始，也可以跟在任何有效语句之后。
>
> 理想情况下，你的代码应该足够清晰，不需要任何注释。然而，这通常是不可能的，大多数程序至少需要一些注释。请运用你的最佳判断。如果意图不能从代码本身明显看出，请在注释中描述它。
>
> 最后，**没有注释总是比有不准确或过时的注释要好**。

对于在程序运行期间值不会改变的变量，将它们声明为**常量**很有用。这允许编译器更好地优化代码，并防止你意外地更改常量的值。我们将在下一节声明常量。

我们的程序目前还做不了太多事情，因为我们只有数据声明。不过，请随意调整它、重新编译它，甚至更好的是，尝试破坏它！看看编译器是否会抱怨。

**声明常量**

一些变量将是恒定的，Fortran 允许你显式地将它们声明为常量。这样做将通过在你试图更改常量值时触发编译器错误来帮助你编写正确的代码，并有助于编译器优化代码。你可以使用 `parameter` 属性声明常量（也称为不可变变量），如下清单所示。

**清单 2.5 声明和初始化常量**
```fortran
program tsunami
  implicit none

  integer, parameter :: grid_size = 100 ! 网格点数 (常量)
  integer, parameter :: num_time_steps = 100 ! 时间步数 (常量)
  real, parameter :: dt = 1.0 ! 时间步长 (秒) (常量)
  real, parameter :: dx = 1.0 ! 网格间距 (米) (常量)
  real, parameter :: c = 1.0 ! 背景流速 (米/秒) (常量)

  integer :: i, n ! 循环计数器

  ! 此处将声明数组

end program tsunami
```

使用 `parameter` 属性要求我们在同一行初始化变量。

> **提示**：如果变量的值在编译时已知并且在程序运行期间不会改变，请将其声明为 `parameter`。

**声明数组**

数组是 Fortran 最强大的特性之一。它们具有几个有用的属性：

*   **连续 (Contiguous)** — 数组元素在内存中是连续的。在现代处理器上，对它们进行索引和执行逐元素算术运算非常高效。
*   **多维 (Multidimensional)** — Fortran 标准允许数组最多有 15 个维度。相比之下，在 C 语言中，你必须通过定义数组的数组来模拟多维。
*   **静态或动态 (Static or dynamic)** — Fortran 数组可以是静态的，维度在编译时设置；也可以是动态的，维度在运行时设置。
*   **整数组算术 (Whole-array arithmetic)** — 你可以将通常的标量算术运算符和数学函数也用于数组。
*   **列主序索引 (Column-major indexing)** — Fortran 数组使用列主序索引，像 MATLAB 或 R 一样，与行主序的 C 或 Python 不同。因此，第一个（最左边）索引变化最快。例如，`a(1,1)`, `a(2,1)`, `a(3,1)` 等是数组 `a` 的连续元素。当你循环遍历多维数组的元素时，请记住这一点。

将整数网格大小声明为 `parameter` 后，我们可以用它来设置保存水高值的数组 `h` 的大小。你可以使用 `dimension` 属性和数组大小的整数参数来声明一个固定长度（静态）的实数数组：

```fortran
real, dimension(grid_size) :: h
```

`dimension` 的参数是数组的整数长度——在我们的例子中是参数 `grid_size`。

> **声明数组的简写语法**
>
> 你可以用更短的形式声明数组，省略 `dimension` 属性，并在数组名称后立即用括号指定数组长度：
>
> ```fortran
> real :: h(grid_size)
> ```
>
> 是使用 `dimension` 属性还是更简洁的形式完全取决于你。然而，为了节省代码清单中的空间，我将在本书中始终使用简写语法。

如前所述，Fortran 的优势之一是其对多维数组的内在支持。你可以通过在声明语句中指定来定义最多 15 个维度的数组，例如：

```fortran
real, dimension(10, 5, 2) :: h
```

这里，`h` 被声明为一个三维数组，总共有 100 个元素 ($10 \times 5 \times 2$)。

> **动态数组呢？**
>
> 你可能已经注意到，在两个数组声明中，我们都使用了整数字面量来设置数组的大小和形状。但是，如果我们的数组维度直到运行时才知道怎么办？Fortran 对动态数组（也称为**可分配数组 (allocatable arrays)**）提供了极好的支持。当你声明一个可分配数组时，你只在声明中指定数组的秩（维度数），而不指定维度的大小。一旦大小已知，就使用 `allocate` 语句来分配具有指定维度的数组。可分配数组也可以在运行时动态地重新分配任意次数。你将在第 5 章看到更多关于可分配数组的内容，届时我们将在我们的应用程序中充分利用它们。

目前，我们的应用程序中需要两个数组——一个用于水高 `h`，另一个用于其有限差分 `dh`：

```fortran
real :: h(grid_size), dh(grid_size)
```

现在我们已经声明了数据结构并准备好行动了，让我们看看能用它们做什么。

### 2.3.6 使用 if 块进行分支

几乎每个计算机程序的关键元素之一是根据某些标准采取不同的执行路径（分支）。以一个解析客户银行账户注册表单的程序为例。如果其中一个输入字段未正确输入，例如社会安全号码包含字母或姓名包含数字，程序应提醒用户并要求正确输入，而不是继续进行。你可以使用 `if` 块来定义这种程序行为。在我们的海啸模拟器中，目前我们将使用 `if` 块来检查输入网格和物理参数的值，如下清单所示。

**清单 2.6 检查输入参数的值**
```fortran
if (grid_size <= 0) stop 'grid_size must be > 0'
if (dt <= 0.0) stop 'time step dt must be > 0'
if (dx <= 0.0) stop 'grid spacing dx must be > 0'
if (c <= 0.0) stop 'background flow speed c must be > 0'
```

在这里，我们检查参数的值，以确保程序能够执行有意义的模拟。具体来说，我们需要一个至少包含一个元素的网格，尽管这不会产生特别有趣的模拟。我们还需要时间步长、网格间距和背景流速都具有正值。条件在 `if` 之后紧跟的括号中说明。在右侧，我们指定了如果括号中的条件评估为真 (`.true.`) 则要执行的语句。在这种情况下，我们使用 `stop` 语句中止程序执行并向用户打印一条有用的消息。

这只是 `if` 语句最简单的一种用法。其通用语法如下：

```fortran
if (condition) statement ! 如果 condition 为 .true.，则执行 statement
```

如果你需要在某个条件下执行多个语句，可以使用更冗长的 `if` 块，如下清单所示。

**清单 2.7 具有一个条件和一个分支的 if 块的通用语法**
```fortran
if (condition) then
  ! 如果 condition 为 .true.，此分支将执行。
  ! 可以有多行语句。
end if
```

到目前为止，这个 `if` 块内的语句仅在条件评估为真时执行，否则什么也不发生。如果我们需要我们的程序在两种情况下都做些事情，我们可以使用更通用的 `if/else/end if` 块，如下清单所示。

**清单 2.8 具有一个条件和两个分支的 if 块的通用语法**
```fortran
if (condition) then
  ! 如果 condition 为 .true.，此分支将执行。
else
  ! 如果 condition 为 .false.，此分支将执行。
end if
```

与单行 `if` 和 `if/end if` 块不同，这个块允许两个执行分支：一个在 `condition` 为真时执行，另一个在为假时执行。也可以在单个 `if` 块中测试多个特定条件，如下清单所示。

**清单 2.9 if 块的最通用语法**
```fortran
if (condition_1) then
  ! 如果 condition_1 为 .true.，则执行。
else if (condition_2) then
  ! 如果 condition_1 为 .false. 且 condition_2 为 .true.，则执行。
else if (condition_3) then
  ! 如果 condition_1 和 condition_2 都为 .false.
  ! 且 condition_3 为 .true.，则执行。
else
  ! 如果所有前面的条件都为 .false.，则执行。
end if
```

条件是 `logical` 类型的表达式。比较运算符，就像我们用来检查输入参数值的那些（例如 `<=`，小于等于），其工作方式与我们在小学学到的普通算术中的比较运算符一样。还有一些其他的边界情况和逻辑运算符，我现在暂时搁置，我们将在后面遇到它们时再探讨。

总结一下，我们有几种不同形式的 `if` 块：

1.  **`if` 单行式** — 对于简单的检查和适合单行的语句很有用；例如，如果 `a` 为负则将其置零：`if (a < 0) a = 0`
2.  **`if/end if`** — 单行 `if` 的更冗长形式；当你只有一个条件但需要执行多个语句时很有用。
3.  **`if/else/end if`** — 允许根据条件的真假值执行不同的语句。
4.  **`if/else if/else/end if`** — 类似于 `if/else/end if`，但允许检查多个特定条件的值。

这就是目前你需要了解的关于分支的所有内容。我们将在接下来的章节中应用这些更复杂的 `if` 块。

### 2.3.7 使用 do 循环进行迭代

我们需要在我们的应用程序中实现循环来做两件事：

1.  循环遍历数组元素以设置水高的初始值，并在下一个时间步计算解。
2.  循环一定数量的时间步，以将数值解向前迭代推进时间。

在 Fortran 中用于循环或迭代的主要结构是 `do` 循环：

```fortran
do n = start, end ! 将 n 从 start 递增到 end。
  ! 循环体代码
end do ! 循环内的代码将执行 end - start + 1 次。
```

这里，`n` 是随每次迭代改变值的整数索引。在第一次迭代中，`n` 等于 `start`。当程序到达 `end do` 行时，`n` 增加 1。在内部，程序然后检查 `n` 是否大于 `end`。如果是，程序跳出循环并继续执行循环之后的代码。否则，控制权返回到循环的开头并进行另一次迭代。该过程重复进行，直到程序退出循环。

默认情况下，`do` 循环将计数器递增 1。但是，你可以在 `end` 索引之后立即指定一个自定义的整数增量：

```fortran
do n = start, end, increment ! 将 n 从 start 按 increment 递增到 end。
  ! 循环体代码
end do ! do 循环内的代码将执行 (end - start) / increment + 1 次。
```

在这种情况下，循环以 `n` 等于 `start` 开始，并在每次迭代中增加 `increment` 的值。

编码 `do` 循环时需要记住几条规则：

*   循环索引 (`n`) 必须是整数变量（不是参数）。
*   `start`, `end`, 和 `increment` 必须是任意符号的整数。它们可以是变量、参数或求值为整数值的表达式。
*   如果 `start` 等于 `end`，循环体将只执行一次。
*   如果 `start` 大于 `end` 且 `increment` 为正，循环体将不执行。
*   如果 `start` 小于 `end` 且 `increment` 为负，循环体将不执行。
*   没有计数器以及 `start` 和 `end` 索引的裸 `do` 语句是一个无限 `do` 循环，必须通过其他方式（例如 `exit` 语句）跳出。
*   循环可以嵌套（循环内部有循环）。
*   循环可以命名。这对于嵌套循环很有用，当你想将 `end do` 与其匹配的 `do` 关联起来时，如下清单所示。

**清单 2.10 对嵌套 do 循环使用名称**
```fortran
outer_loop: do i = 1, n
  inner_loop: do j = 1, m
    ! 做一些工作
  end do inner_loop
end do outer_loop
```

虽然命名循环起初可能看起来不必要地冗长，但当程序变大且嵌套层级增多时，名称会变得很有用。此外，你可以使用循环名称通过 `exit` 语句从任何层级跳出特定的 `do` 循环。

最后，`do` 循环的通用语法形式如图 2.5 所示。

![图 2.5 Fortran do 循环的通用语法。可选语法元素在方括号中。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/c8a2e67d7c8d95330beb15978499549e8e36bd5b98b7f03bb18b9c0908b18a69.jpg)
*图 2.5 Fortran do 循环的通用语法。可选语法元素在方括号中。*

在图中，`expr1`, `expr2`, 和 `expr3` 分别是起始和结束索引（包含），以及增量。`name` 可以是任何给定的名称。

### 2.3.8 设置初始水高值

在将解向前迭代推进时间之前，我们需要指定水高的初始状态。换句话说，我们需要设置数组 `h` 的初始值。在我们这样的小模型中，常见的选择是高斯（钟形）形状（图 2.6）。

![图 2.6 水高的初始值](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/7b261391aa40180d8df3fffddecd09d5a11edff6f0cf7cf019c474301890565b.jpg)
*图 2.6 水高的初始值*

这是一个定义良好、平滑的函数，我们可以使用指数函数来计算它，如下清单所示。

**清单 2.11 用高斯形状初始化水高**
```fortran
integer, parameter :: icenter = grid_size / 2 ! 扰动中心
real, parameter :: decay = 0.01 ! 指数衰减率

! 设置初始条件 (高斯形状)
do i = 1, grid_size
  h(i) = exp(-decay * real(i - icenter)**2)
end do
```

在这里，我们第一次实际使用了以下内容：

*   一个 `do` 循环来迭代数组元素。由于我们将 `h` 声明为大小为 `grid_size` 的数组，这个循环将迭代数组的所有元素。
*   算术运算符 `-`, `*`, 和 `**` (幂)。
*   一个内部数学函数 `exp` (指数)。这个和其他内部数学函数在 Fortran 程序中立即可用，不需要以任何特殊方式导入。
*   算术赋值 (`=`)，将右侧表达式的结果赋给左侧的变量。左侧的值仅在右侧整个表达式求值完成后才更新。

参数 `icenter` 和 `decay` 分别控制水高扰动的位置和宽度。整数 `icenter` 是扰动中心的数组索引。例如，当 `i` 等于 `icenter` 时，指数参数减少到零，`h(i)` 等于 1。实数参数 `decay` 决定了指数衰减的速率。较大的值产生较窄的扰动。

> **我们的数组赋值能并行完成吗？**
>
> 回忆一下我们在上一章中关于易并行问题的讨论。我们说过，如果各个迭代之间没有数据依赖关系，那么问题就是易并行的。看看我们 `h` 初始值的表达式。我们能否将这个工作负载分配给多个处理器？
>
> 开始养成对你遇到的每个计算问题、公式或方程都问这个问题的习惯。随着时间的推移，你会发现更多分配计算的机会，或者至少标记出编译器可以安全向量化的代码段。Fortran 为此提供了一个特殊的 `do` 循环，称为 `do concurrent`。它向编译器保证各个迭代之间没有依赖关系，并且可以乱序执行，我们将在下一小节看到。

### 2.3.9 预测物体的运动

我们已经初始化了水高的值，准备进入我们模拟的核心——向前迭代时间并在每个时间步计算解。这包括两个步骤：

1.  计算水高的空间差分 (`dh`)，包括周期性边界条件。
2.  使用 `dh` 计算水高 `h` 的新值。

以下清单提供了求解器的核心部分。

**清单 2.12 将解向前迭代推进时间**
```fortran
time_loop: do n = 1, num_time_steps

  ! 计算 h 的有限差分
  ! 应用周期性边界条件
  dh(1) = h(1) - h(grid_size)
  do i = 2, grid_size
    dh(i) = h(i) - h(i-1)
  end do

  ! 使用有限差分和平流速度更新 h
  do i = 1, grid_size
    h(i) = h(i) - c * dt / dx * dh(i)
  end do

end do time_loop
```

外层循环，我们称之为 `time_loop`，将整数 `n` 从 1 递增到 `num_time_steps`。虽然我们在循环体内没有使用 `n`，但我们使用这个循环将循环体重复执行 `num_time_steps` 次。在 `time_loop` 内部，我们执行两个计算：

1.  我们计算 `h` 在空间上的差分并将其存储在数组 `dh` 中。我们分两步完成：
    a. 我们计算 `dh(1)` 的值，它对应于域左边缘的元素。因为我们应用了周期性（循环）边界条件，`dh(1)` 依赖于域右边缘的 `h` 值。
    b. 我们循环遍历剩余的元素（从 2 到 `grid_size`），并将 `dh(i)` 设置为 `h` 在空间上的差分 $(h(i) - h(i-1))$。
2.  一旦我们计算好了数组 `dh`，我们用它来计算 `h` 的新值并更新它。这里我们不需要存储每个时间步的 `h` 值，我们用新值覆盖旧值。

Fortran 遵循与普通算术相同的运算符优先级规则：

1.  **幂运算 (`**`)** 首先求值。
2.  **乘法 (`*`) 和除法 (`/`)** 其次求值。
3.  **加法 (`+`) 和减法 (`-`)** 最后求值。
4.  最后，优先级可以用**括号**覆盖。

此外，Fortran 中优先级相同的运算从左到右求值。例如，这个表达式：

```
h(i) = h(i) - c * dt / dx * dh(i)
```

等价于这个表达式：

```
h(i) = h(i) - (((c * dt) / dx) * dh(i))
```

几页前，我问你是否可能以一种简单的方式并行化这个循环：

```fortran
do i = 1, grid_size
  h(i) = exp(-decay * real(i - icenter)**2)
end do
```

你应该寻找的是是否有任何迭代依赖于在任何其他迭代中计算的数据。这里，右侧仅依赖于循环计数器 `i` 和参数 `decay` 和 `icenter`，而左侧的变量 (`h(i)`) 并未在右侧使用。每次迭代是否可以在不改变最终结果的情况下以任何顺序执行？如果是，则该计算可以很容易地并行化。

第一步是通知编译器这部分代码可以以它认为最优的任何顺序执行。Fortran 2008 引入了 `do concurrent` 结构来实现此目的。该结构使用稍微修改过的语法，如下清单所示。

**清单 2.13 使用 do concurrent 进行易并行计算**
```fortran
do concurrent (i = 1:grid_size)
  h(i) = exp(-decay * real(i - icenter)**2)
end do
```

这里，我们使用 `(i = 1:grid_size)` 语法而不是 `i = 1, grid_size`。我们将在第 6 章更详细地介绍这一点，但现在我们将使用这种语法将我们所有可并行化的循环提升为 `do concurrent`。

> **`do concurrent` 是什么，不是什么**
>
> `do concurrent` 究竟做了什么？这是程序员向编译器做出的承诺，即循环内的代码可以安全地进行向量化或并行化。实际上，一个好的编译器会使用系统线程库或 SIMD 机器指令（如果可用）来做到这一点。
>
> `do concurrent` **绝不保证**循环会并行运行！在诸如具有简单计算的短循环等情况下，编译器可能会确定串行执行更有效。我们将在第 7 章研究使用协同数组的显式分布式内存并行性。现在，我们将 `do concurrent` 用作给自己和编译器的注释，表明代码的某些区域可以安全地并行化。

在 `time_loop` 内部，你能找到任何其他可以用 `do concurrent` 表达的循环吗？如果是，请使用修改后的语法将它们重写为 `do concurrent` 循环。

### 2.3.10 将结果打印到屏幕

我们现在有了时间循环，它将求解器迭代精确地 `num_time_steps` 个时间步。本章剩下的最后一步是将结果打印到屏幕上。最简单的方法是将结果打印到终端，我们可以从那里将输出重定向到文件以供后续使用，例如绘图。为此，你可以使用 `print` 语句，你在第 1 章已经遇到过：

```fortran
print *, n, h ! 使用默认格式将 n 和 h 的值打印到终端
```
`print` 是 Fortran 中最简单的输出语句。紧跟在 `print` 后面的 `*` 符号表示**默认格式**，它告诉编译器使用它认为方便的任何格式来输出数据。在大多数情况下，默认格式是合理的。如前所述，这里我们将 `n`（整数标量）和 `h`（包含 100 个元素的实数数组）的值打印到屏幕上。因此，该语句将在终端的一行中输出恰好 101 个值。

我们将在第 6 章更详细地探讨 Fortran 输入/输出。目前，`print *` 就是我们所需要的全部。

### 2.3.11 整合所有内容

终于，我们到了激动人心的部分：将我们学到的各个部分组合成一个完整且可工作的程序。我们将首先查看我们程序的解（用 Python 脚本可视化），然后浏览完整的代码。

**结果**

我们简单应用程序的数值解如图 2.7 所示。从上到下，每个面板显示了以 25 个时间步为增量的水高状态。顶部面板对应于初始条件，如图 2.6 所示。每个面板中水高波峰的位置与模拟的物理参数配置一致：背景流速 (`c = 1.0`)、网格间距 (`dx = 1.0`) 和时间步长 (`dt = 1.0`)。在底部面板中，我们可以看到水高波峰从右侧移出并从左侧重新进入。这证实了我们的周期性边界条件按预期工作。

![图 2.7 预测物体的线性平流，使用周期性边界条件。水高扰动以 1 m/s 的恒定速度从左向右平流。当水到达右侧边界时，它从左侧重新进入域。](https://cdn-mineru.openxlab.org.cn/extract/835492be-df92-4072-9cb1-7d6f5c56b9ec/e41c617765ddba40dfc842f5168b23f06f5ac4732e45b0ab98f0bc151e9a40f2.jpg)
*图 2.7 预测物体的线性平流，使用周期性边界条件。水高扰动以 1 m/s 的恒定速度从左向右平流。当水到达右侧边界时，它从左侧重新进入域。*

虽然 Fortran 非常适合高性能数值工作，但在图形和数据可视化方面则不那么优雅。为简洁起见，我使用 Python 脚本来可视化海啸结果。你可以在 GitHub 上的 `tsunami` 仓库 (https://github.com/modern-fortran/tsunami) 中找到可视化代码，以及每个章节目录中的 Fortran 源代码。

**完整代码**

我们海啸模拟器第一个版本的完整代码在以下清单中给出。

**清单 2.14 最小可行海啸模拟器的完整代码**
```fortran
program tsunami
  implicit none

  integer, parameter :: grid_size = 100      ! 网格点数
  integer, parameter :: num_time_steps = 100 ! 时间步数
  real, parameter :: dt = 1.0             ! 时间步长 (秒)
  real, parameter :: dx = 1.0             ! 网格间距 (米)
  real, parameter :: c = 1.0              ! 背景流速 (米/秒)
  integer, parameter :: icenter = grid_size / 2 ! 扰动中心
  real, parameter :: decay = 0.01           ! 指数衰减率

  real :: h(grid_size), dh(grid_size) ! 水高和水高差分数组
  integer :: i, n                       ! 循环计数器

  ! 检查输入参数
  if (grid_size <= 0) stop 'grid_size must be > 0'
  if (dt <= 0.0) stop 'time step dt must be > 0'
  if (dx <= 0.0) stop 'grid spacing dx must be > 0'
  if (c <= 0.0) stop 'background flow speed c must be > 0'

  ! 设置初始条件 (高斯形状)
  do concurrent (i = 1:grid_size)
    h(i) = exp(-decay * real(i - icenter)**2)
  end do

  ! 时间循环
  time_loop: do n = 1, num_time_steps

    ! 计算 h 的有限差分
    ! 应用周期性边界条件
    dh(1) = h(1) - h(grid_size)
    do concurrent (i = 2:grid_size)
      dh(i) = h(i) - h(i-1)
    end do

    ! 使用有限差分和平流速度更新 h
    do concurrent (i = 1:grid_size)
      h(i) = h(i) - c * dt / dx * dh(i)
    end do

    ! 打印当前时间步和水高到屏幕
    print *, n, h

  end do time_loop

end program tsunami
```

仅用 30 行代码，这就是一个有用的小求解器！如果你编译并运行这个程序，你会在屏幕上得到一长串数字作为文本输出，如下清单所示。

**清单 2.15 当前版本海啸模拟器的文本输出**
```
           1   5.04307148E-11  6.09643073E-11 ... 6.09643073E-11  5.04307148E-11
           2   4.58014888E-11  5.53698771E-11 ... 6.68934081E-11  5.53698771E-11
         ...
         100   1.00000000      9.90049839E-01 ... 9.90049839E-01  1.00000000
```

虽然看起来可能像乱码，但这些是我们预测的水高值（单位：米）。然而，输出很长，会淹没你的终端窗口。如果你将其重定向到文件，你将能够更容易地浏览输出，如下清单所示。

**清单 2.16 构建、运行和可视化海啸模拟器的输出**
```bash
# 编译 tsunami.f90
$ gfortran tsunami.f90 -o tsunami

# 运行并将输出重定向到 data/output.txt
$ ./tsunami > data/output.txt

# 使用 Python 脚本绘制结果
$ python viz.py data/output.txt
```

或者，GitHub 上的源代码仓库也附带了一个 Makefile 来简化构建过程，你可以从顶层目录输入 `make ch02`。这也假设你已经按照仓库中 README.md 文件中的说明设置了 Python 虚拟环境。

去试试吧，玩一下。一些想法：

*   调整初始条件，也许通过改变初始扰动的形状和位置。例如，你可以更改 `decay` 和 `icenter` 参数的值，或者在初始化 `h` 数组时使用不同的函数。试试正弦波（内部函数 `sin`）。
*   更改 `grid_size` 和 `num_time_steps` 参数。

记住 Fortran 是编译型语言。每次更改代码后，都需要在运行之前重新编译它。

## 2.4 继续海啸模拟器

回顾本章以及我们到目前为止所做的工作，总结一下我们**尚未拥有**的内容以及我们将在本书第二部分如何实现它们是很有帮助的：

*   在**第 3 章**中，你将学习函数和子例程，并将我们模拟器中的一些计算重构为可重用的过程。
*   在**第 4 章**中，你将使用 Fortran 模块来重组我们的应用程序，并将实现更真实的物理过程。
*   在**第 5 章**中，你将学习关于数组和整数组算术的所有知识。
*   在**第 6 章**中，我们将深入探讨输入和输出，你将学习如何以可移植的方式输出数据、格式化数据并将其写入磁盘文件。

除此之外，在本书的第三部分，我们将探索使用协同数组的并行计算，以及高级数据结构和过程。

> **关于抽象 (Abstractions)**
>
> 随着我们学习本书，我们将在每一章遇到新的抽象层。这里，**抽象**是一种编程机制，旨在将内部实现对程序员隐藏起来（黑盒化）。例如，在下一章中，函数和子例程是对显式命令式代码的一种抽象。在第 8 章中，你将学习派生类型，它可以包含任意数量的变量和附加到它们的过程，这是又一层抽象。
>
> 每一层抽象都带来了好处和成本。好处通常归结为需要编写更少的样板代码，尤其是在编写重复性任务时。成本是抽象不仅隐藏了实现细节，而且如果不谨慎、小心地使用，还会隐藏含义和副作用。每次我们在本书中遇到新的抽象时，我都会提醒你。仔细考虑每种抽象，并且只有在好处大于感知到的成本时才使用它们。

## 2.5 答案解析

本节包含本章练习的解答。如果你还没有完成练习，请跳过此节。

### 2.5.1 练习：冷锋传播

1.  **亚特兰大和迈阿密之间的温度梯度是多少？**
    这里的梯度是两个地点之间的温差除以它们之间的距离。因此答案是 (24°C - 12°C) / 960 km = 12°C / 960 km = **0.0125 °C/km**。
2.  **迈阿密的温度达到 12°C 需要多少小时？**
    首先计算迈阿密的降温速率。锋面以 20 km/h 的速度移动，我们知道梯度是 0.0125 °C/km。那么降温速率是 20 km/h × 0.0125 °C/km = **0.25 °C/小时**。迈阿密的初始温度是 24°C，所以它达到 12°C 需要的时间是 (24°C - 12°C) / (0.25 °C/小时) = 12°C / (0.25 °C/小时) = **48 小时**。
3.  **24 小时后迈阿密的温度将是多少？**
    我们知道迈阿密的初始温度是 24°C，降温速率是 0.25 °C/小时。那么答案是 24°C - (0.25 °C/小时 × 24 小时) = 24°C - 6°C = **18°C**。

## 2.6 新 Fortran 元素概览

*   `program`/`end program` 语句定义主程序
*   内部数值类型 `integer`, `real`, 和 `complex`
*   `dimension` 属性声明数组
*   算术运算符 `+`, `-`, `*`, `/`, 和 `**`，以及赋值 `=`
*   `if` 语句和 `if` 块用于分支
*   `stop` 语句中止程序并向终端打印消息
*   `do`/`end do` 结构迭代执行代码的任何可执行部分
*   `do concurrent` 标记易并行代码段
*   `print *` 语句是将文本和变量值打印到终端的最简单方法

## 2.7 进一步阅读

*   GNU Fortran 编译器文档: https://gcc.gnu.org/onlinedocs/gfortran
*   维基百科关于平流的文章: https://en.wikipedia.org/wiki/Advection
*   维基百科关于有限差分的文章: https://en.wikipedia.org/wiki/Finite_difference

# 总结

*   构建可执行的 Fortran 程序包括编译和链接两个步骤。
*   Fortran 中有五种程序单元：主程序、函数、子例程、模块和子模块。
*   程序以 `program` 语句开始，以 `end program` 语句结束。
*   在每个程序中，我们首先声明数据，可执行代码紧随其后。在声明代码的顶部使用 `implicit none` 来强制对所有变量进行显式声明。
*   Fortran 中有五种内置数据类型：`integer`, `real`, `complex`, `character`, 和 `logical`。
*   `if` 块用于测试条件并根据其值采取不同的执行分支。
*   使用 `stop` 语句立即中止程序并向终端打印有用的消息。
*   `do` 循环用于将代码段迭代执行指定的次数。`do` 循环计数器的起始值、结束值和增量可以是任何整数值。
*   Fortran 的算术规则与我们在学校学到的一样：首先计算幂运算，然后计算乘法和除法，最后计算加法和减法；这个顺序可以用括号覆盖。
*   `print *` 是将任何变量或字面常量的值打印到终端的简单方法。

---

# **第二部分 FORTRAN 核心元素**

本部分涵盖 Fortran 的核心元素：过程、模块、数组和 I/O。

在**第 3 章**中，你将学习关于函数和子例程（统称为过程）需要了解的最重要的事情。它们将允许你抽象出任何你需要多次运行的代码片段。函数和子例程是基本的构建块，将使你能够编写可重用、可组合且复杂（但不难懂）的代码。你将应用这些知识来重构我们在第 2 章开始的海啸模拟器。

在**第 4 章**中，你将学习模块以及如何使用它们将你的数据和过程组织成可重用和可移植的组件。

**第 5 章**涵盖数组，这是 Fortran 的基本数据结构。你将学习如何声明、初始化和使用数组，以及如何利用整数组算术来大大简化你的代码。你将使用数组来分析股价时间序列。

最后，**第 6 章**涵盖 I/O。你将学习如何从标准输入、输出和错误流中读取和写入数据，以及如何从磁盘文件读取和写入数据。你还将学习如何将数值数据格式化为文本。你将通过为命令行编写一个最小的笔记应用程序来练习这些技能。

完成本书这部分的学习并进行一些实践后，你将成为一名功能齐全且独立的 Fortran 程序员。你将能够从头开始编写 Fortran 程序和库来解决实际问题。

